<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wordpack Data Structure Debugger</title>

  <!--
    ============================================================
    PAKO.JS DEPENDENCY - Required for decompressing obfuscated modules
    ============================================================
    Our obfuscated modules use zlib compression (via pako library).
    This CDN script provides the pako.inflate() function for decompression.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>

  <!--
    ============================================================
    WORDPACK DATA STRUCTURE DEBUGGER
    ============================================================

    PURPOSE:
    This document serves as a technical reference and debugging tool for our
    language learning game's wordpack data structure. It demonstrates how to:
    - Load obfuscated JavaScript modules containing wordpack data
    - Extract and display vocabulary for language learning
    - Navigate through acts and packs
    - Map columns to different languages

    TARGET LANGUAGES WE TEACH:
    - Spanish (7 acts, 5 column structure)
    - Chinese (5 acts, 12 column structure)
    - English (5 acts, 5 column structure)

    DATA STRUCTURE OVERVIEW:
    Each language has multiple "acts" (learning stages), and each act contains
    multiple "wordpacks" (vocabulary sets).

    OBFUSCATED MODULE STRUCTURE:
    Each module exports a dictionary of wordpacks with this structure:

    {
      "p{act}_{pack}_{name}": {
        "meta": {
          "wordpack": 1,                    // Pack number (integer)
          "english": "Greetings & Goodbyes", // Pack title in English
          "chinese": "问候语",                // Pack title in Chinese
          "spanish": "Saludos y Despedidas", // Pack title in Spanish
          ... // Other language translations as supported
        },
        "words": [
          ["word1_col1", "word1_col2", "word1_col3", ...],  // Each word is an array
          ["word2_col1", "word2_col2", "word2_col3", ...],
          ["word3_col1", "word3_col2", "word3_col3", ...]
        ]
      },
      "p{act}_{pack}_{name}": { ... },
      ...
    }

    COLUMN MAPPING BY LANGUAGE:
    The words array contains arrays where each index maps to a specific language:

    SPANISH (5 columns):
      [0] = Spanish (language being learned)
      [1] = English
      [2] = Chinese
      [3] = Pinyin
      [4] = Portuguese

    CHINESE (12 columns):
      [0] = Chinese (language being learned)
      [1] = Pinyin
      [2] = English
      [3] = Spanish
      [4] = French
      [5] = Portuguese
      [6] = Vietnamese
      [7] = Thai
      [8] = Khmer
      [9] = Indonesian
      [10] = Malay
      [11] = Filipino

    ENGLISH (5 columns):
      [0] = English (language being learned)
      [1] = Chinese
      [2] = Pinyin
      [3] = Spanish
      [4] = Portuguese

    HOW TO USE THIS DATA IN A GAME:
    1. Import the obfuscated module using decodeObfuscatedModule()
    2. Select a wordpack from the returned dictionary
    3. Access wordpack.meta for pack information
    4. Access wordpack.words for the vocabulary array
    5. Each word is wordpack.words[i], where i is the word index
    6. Each column is wordpack.words[i][columnIndex]
    7. Column 0 is always the language being learned
    8. Other columns provide translations in various languages

    ============================================================
  -->

  <h1>Wordpack Data Structure Debugger</h1>
  <p>Technical reference for language learning game data architecture</p>

  <hr>

  <!--
    ============================================================
    LANGUAGE SELECTION - Radio Buttons
    ============================================================
    Choose which target language's wordpacks to load.
    Default: Spanish
  -->
  <h2>1. Select Target Language</h2>
  <p>Which language are you learning?</p>
  <label>
    <input type="radio" name="language" value="Spanish" checked>
    Spanish
  </label>
  <label>
    <input type="radio" name="language" value="Chinese">
    Chinese
  </label>
  <label>
    <input type="radio" name="language" value="English">
    English
  </label>

  <hr>

  <!--
    ============================================================
    ACT SELECTION - Dropdown
    ============================================================
    Acts are learning stages. Each language has different numbers of acts:
    - Spanish: 7 acts
    - Chinese: 5 acts
    - English: 5 acts
  -->
  <h2>2. Select Act (Learning Stage)</h2>
  <p>Acts are grouped learning stages containing multiple wordpacks.</p>
  <select id="actSelect">
    <option value="">Loading...</option>
  </select>

  <hr>

  <!--
    ============================================================
    WORDPACK SELECTION - Dropdown
    ============================================================
    Each act contains multiple wordpacks (vocabulary sets).
    This dropdown populates based on the selected act.
  -->
  <h2>3. Select Wordpack</h2>
  <p>Individual vocabulary set within the selected act.</p>
  <select id="packSelect">
    <option value="">First select an act</option>
  </select>

  <hr>

  <!--
    ============================================================
    NATIVE LANGUAGE SELECTION - "I Speak" Dropdown
    ============================================================
    This determines which column to display in the right column of the table.
    Column 0 (left) is always the target language being learned.
    Column N (right) is the native language the user speaks.

    Available options depend on the target language's column structure.
  -->
  <h2>4. Select Your Native Language (I Speak)</h2>
  <p>Which language do you speak? This determines the translation column shown.</p>
  <select id="nativeLanguageSelect">
    <option value="">Loading...</option>
  </select>

  <hr>

  <!--
    ============================================================
    VOCABULARY TABLE - With Optional Multiple Choice Mode
    ============================================================
    Displays the selected wordpack's vocabulary.

    BASIC MODE (Default):
    - 2 columns: Target language (column 0) and Native language (selected)

    MULTIPLE CHOICE MODE (Checkbox enabled):
    - 6 columns total:
      1. Target language (correct answer, column 0)
      2. Native language translation (column N)
      3-6. Four wrong answers (randomly selected from ENTIRE ACT, ~2,500 words)

    WRONG ANSWER POOL:
    Wrong answers are now pulled from ALL wordpacks in the current act,
    not just the current wordpack. This provides:
    - Greater variety (2,500 options vs 50)
    - Less predictable patterns
    - Better simulation of real game mechanics
    - Zero performance cost (all data already loaded in memory)

    DUPLICATE FILTERING:
    Uses normalized string comparison (lowercase, no spaces/symbols)
    to avoid showing essentially identical words:
    - "hola" vs "Hola" (case difference) - filtered
    - "hello friend" vs "hellofriend" (spacing) - filtered
    - "hello!" vs "hello" (punctuation) - filtered

    This demonstrates the CORE LOGIC for generating multiple choice questions
    used in language learning games. Different game mechanics require different
    numbers of choices:
    - Temple Run style: 3 choices (1 correct + 2 wrong)
    - Quiz games: 4 choices (1 correct + 3 wrong)
    - This demo: 6 choices (1 correct + 4 wrong) to show extensibility

    The algorithm works for ANY target language (Spanish, Chinese, English, etc.)
    and ANY future language packs we add to the system.
  -->
  <h2>5. Vocabulary Table</h2>
  <p><strong>Pack Title:</strong> <span id="packTitle">Select a wordpack to view</span></p>

  <!--
    MULTIPLE CHOICE MODE CHECKBOX
    When enabled, adds 4 columns of wrong answers randomly selected from
    ALL wordpacks in the current act (~2,500 words). This shows how game
    mechanics generate distractors with variety and duplicate filtering.
  -->
  <p>
    <label>
      <input type="checkbox" id="multipleChoiceMode">
      Multiple Choice Mode (adds 4 wrong answer columns from entire act - game mechanics demo)
    </label>
  </p>

  <!--
    TYPING MODE CHECKBOX
    When enabled, adds 3 columns for interactive typing practice:
    - Column 3: Typing input box with masked placeholders (X for each letter)
    - Column 4: Wrong letters attempted (crossed out display)
    - Column 5: Wrong attempt count

    This demonstrates the CORE TYPING MECHANIC used in language learning games
    like SimpleFlashCards.html. The mechanic includes:
    - Character-by-character input validation
    - Accent-insensitive comparison (á = a, ñ = n, etc.)
    - Case-insensitive matching
    - Satisfying typing sound on every keypress (correct or wrong)
    - Automatic space handling (spaces ignored, auto-advanced)
    - Wrong letter tracking for feedback

    IMPROVEMENTS OVER SimpleFlashCards.html:
    - Simpler state management (per-row instead of global)
    - More modular code structure (easier to copy to other games)
    - Cleaner normalization logic
    - Better commented for human/LLM understanding
  -->
  <p>
    <label>
      <input type="checkbox" id="typingMode">
      Typing Mode (adds typing practice columns - game mechanics demo)
    </label>
  </p>

  <table border="1" cellpadding="8" cellspacing="0">
    <thead>
      <tr id="tableHeaderRow">
        <th id="col1Header">I am learning</th>
        <th id="col2Header">I speak</th>
      </tr>
    </thead>
    <tbody id="vocabularyTable">
      <tr>
        <td colspan="2">Loading data...</td>
      </tr>
    </tbody>
  </table>

  <hr>

  <!--
    ============================================================
    DEBUG INFORMATION
    ============================================================
    Shows technical details about loaded data for debugging purposes.
  -->
  <h2>6. Debug Information</h2>
  <pre id="debugInfo">Initializing...</pre>

  <!--
    ============================================================
    JAVASCRIPT MODULE - Main Logic
    ============================================================
    This section contains all the JavaScript logic for:
    1. Decoding obfuscated modules (3-layer: base64 + zlib + string reversal)
    2. Loading language data automatically on page load
    3. Populating dropdowns dynamically
    4. Displaying vocabulary in 2-column table
    5. Handling user interactions (language/act/pack/native language changes)
  -->
  <script type="module">

    // ============================================================
    // CONFIGURATION: Language Module Paths and Column Structures
    // ============================================================

    /*
      This configuration maps each target language to:
      1. Module file paths (obfuscated .js files for each act)
      2. Column structure (what each column index represents)
      3. Available native languages (for "I speak" dropdown)
    */
    const LANGUAGE_CONFIG = {
      'Spanish': {
        modules: [
          { act: 1, name: 'Foundation', path: './SpanishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './SpanishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Daily Life', path: './SpanishWords/Jsmodules-js/act3-daily-life-js.js' },
          { act: 4, name: 'Expanding Expression', path: './SpanishWords/Jsmodules-js/act4-expanding-expression-js.js' },
          { act: 5, name: 'Intermediate Mastery', path: './SpanishWords/Jsmodules-js/act5-intermediate-mastery-js.js' },
          { act: 6, name: 'Advanced Constructs', path: './SpanishWords/Jsmodules-js/act6-advanced-constructs-js.js' },
          { act: 7, name: 'Mastery Fluency', path: './SpanishWords/Jsmodules-js/act7-mastery-fluency-js.js' }
        ],
        columns: ['Spanish', 'English', 'Chinese', 'Pinyin', 'Portuguese'],
        nativeLanguages: {
          'English': 1,
          'Chinese': 2,
          'Pinyin': 3,
          'Portuguese': 4
        }
      },
      'Chinese': {
        modules: [
          { act: 1, name: 'Foundation', path: './ChineseWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Development', path: './ChineseWords/Jsmodules-js/act2-development-js.js' },
          { act: 3, name: 'Expansion', path: './ChineseWords/Jsmodules-js/act3-expansion-js.js' },
          { act: 4, name: 'Mastery', path: './ChineseWords/Jsmodules-js/act4-mastery-js.js' },
          { act: 5, name: 'Refinement', path: './ChineseWords/Jsmodules-js/act5-refinement-js.js' }
        ],
        columns: ['Chinese', 'Pinyin', 'English', 'Spanish', 'French', 'Portuguese', 'Vietnamese', 'Thai', 'Khmer', 'Indonesian', 'Malay', 'Filipino'],
        nativeLanguages: {
          'English': 2,
          'Spanish': 3,
          'French': 4,
          'Portuguese': 5,
          'Vietnamese': 6,
          'Thai': 7,
          'Khmer': 8,
          'Indonesian': 9,
          'Malay': 10,
          'Filipino': 11
        }
      },
      'English': {
        modules: [
          { act: 1, name: 'Foundation', path: './EnglishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './EnglishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Everyday Life', path: './EnglishWords/Jsmodules-js/act3-everyday-life-js.js' },
          { act: 4, name: 'Expanding Horizons', path: './EnglishWords/Jsmodules-js/act4-expanding-horizons-js.js' },
          { act: 5, name: 'Advanced Mastery', path: './EnglishWords/Jsmodules-js/act5-advanced-mastery-js.js' }
        ],
        columns: ['English', 'Chinese', 'Pinyin', 'Spanish', 'Portuguese'],
        nativeLanguages: {
          'Chinese': 1,
          'Pinyin': 2,
          'Spanish': 3,
          'Portuguese': 4
        }
      }
    };

    // ============================================================
    // GLOBAL STATE: Stores loaded data and current selections
    // ============================================================

    /*
      Global state object tracks:
      - currentLanguage: Which target language is selected
      - loadedData: Dictionary mapping act numbers to decoded wordpack data
      - currentAct: Currently selected act number
      - currentPack: Currently selected wordpack key
      - currentNativeLanguage: Column index for native language
      - multipleChoiceMode: Boolean flag for showing wrong answer columns
      - typingMode: Boolean flag for showing typing practice columns
      - typingStates: Map tracking typing state for each word (wordIndex -> state object)
    */
    let state = {
      currentLanguage: 'Spanish',  // Default language
      loadedData: {},               // { actNumber: { packKey: {meta, words}, ... } }
      currentAct: null,
      currentPack: null,
      currentNativeLanguage: 1,     // Default to English column (index 1 for Spanish)
      multipleChoiceMode: false,    // Default to basic 2-column mode
      typingMode: false,            // Default to typing mode off
      typingStates: new Map()       // Per-word typing state { typed: Set(), wrongLetters: [], wrongCount: 0 }
    };

    // ============================================================
    // DECODER FUNCTION: Decodes Obfuscated Modules
    // ============================================================

    /*
      Our wordpack modules are obfuscated using 3 layers of protection:
      1. Base64 encoding - Allows safe transport as JavaScript string
      2. Zlib compression (via pako) - Reduces file size by ~60%
      3. String reversal - Simple salt to prevent casual JSON parsing

      This function reverses all 3 steps to extract the original JSON data.

      INPUT: URL path to obfuscated module (e.g., './SpanishWords/Jsmodules-js/act1-foundation-js.js')
      OUTPUT: JavaScript object containing all wordpacks in that act

      EXAMPLE OUTPUT STRUCTURE:
      {
        "p1_1_greetings__goodbyes": {
          meta: { wordpack: 1, english: "Greetings & Goodbyes", ... },
          words: [
            ["hola amigo", "hello friend (masculine)", "你好朋友", "nǐ hǎo péngyǒu", "olá amigo"],
            ["hola amiga", "hello friend (feminine)", "你好朋友", "nǐ hǎo péngyǒu", "olá amiga"],
            ...
          ]
        },
        "p1_2_another_pack": { ... },
        ...
      }
    */
    async function decodeObfuscatedModule(url) {
      try {
        // STEP 1: Import the obfuscated module
        // The module exports a single variable 'w' containing the base64 string
        const module = await import(url);
        const compressedB64 = module.w;

        // STEP 2: Decode base64 to binary
        // atob() converts base64 string to binary string
        // We then convert to Uint8Array for pako
        const compressedBinary = Uint8Array.from(atob(compressedB64), c => c.charCodeAt(0));

        // STEP 3: Decompress with pako (zlib decompression)
        // This inflates the compressed data back to original size
        const decompressedBinary = pako.inflate(compressedBinary);

        // STEP 4: Convert binary to UTF-8 string
        const reversedJson = new TextDecoder('utf-8').decode(decompressedBinary);

        // STEP 5: Reverse the string (undo the salt)
        // Original was reversed character-by-character
        const jsonStr = reversedJson.split('').reverse().join('');

        // STEP 6: Parse JSON to get the original JavaScript object
        const data = JSON.parse(jsonStr);

        return data;
      } catch (error) {
        console.error('Failed to decode module:', url, error);
        throw error;
      }
    }

    // ============================================================
    // INITIALIZATION: Load Data on Page Load
    // ============================================================

    /*
      This function runs automatically when the page loads.
      It loads the default language (Spanish) data and populates UI.

      WORKFLOW:
      1. Load all acts for the default language
      2. Populate act dropdown
      3. Populate native language dropdown
      4. Auto-select first act
      5. Display vocabulary
    */
    async function initialize() {
      updateDebugInfo('Initializing... Loading Spanish data (default)');

      // Load data for default language (Spanish)
      await loadLanguageData('Spanish');

      // Setup UI
      setupLanguageRadioButtons();
      setupMultipleChoiceCheckbox();
      setupTypingModeCheckbox();
      populateActDropdown();
      populateNativeLanguageDropdown();

      // Auto-select first act
      if (state.loadedData && Object.keys(state.loadedData).length > 0) {
        const firstAct = Math.min(...Object.keys(state.loadedData).map(Number));
        state.currentAct = firstAct;
        document.getElementById('actSelect').value = firstAct;

        // Populate pack dropdown for first act
        populatePackDropdown();

        // Auto-select first pack
        const firstActData = state.loadedData[firstAct];
        if (firstActData) {
          const firstPackKey = Object.keys(firstActData)[0];
          state.currentPack = firstPackKey;
          document.getElementById('packSelect').value = firstPackKey;

          // Display vocabulary
          displayVocabulary();
        }
      }

      updateDebugInfo('Initialization complete. Ready to use.');
    }

    // ============================================================
    // LOAD LANGUAGE DATA: Fetches and Decodes All Acts
    // ============================================================

    /*
      Loads all act modules for the specified language.

      INPUT: languageName (string) - 'Spanish', 'Chinese', or 'English'
      OUTPUT: Populates state.loadedData with decoded wordpacks

      PROCESS:
      1. Get module list from LANGUAGE_CONFIG
      2. Loop through each act module
      3. Decode the obfuscated module
      4. Store in state.loadedData[actNumber]
    */
    async function loadLanguageData(languageName) {
      updateDebugInfo(`Loading ${languageName} data...`);

      const config = LANGUAGE_CONFIG[languageName];
      state.loadedData = {};  // Clear previous data

      // Load each act module
      for (const moduleInfo of config.modules) {
        updateDebugInfo(`Loading Act ${moduleInfo.act}: ${moduleInfo.name}...`);

        try {
          const actData = await decodeObfuscatedModule(moduleInfo.path);
          state.loadedData[moduleInfo.act] = actData;
          updateDebugInfo(`✓ Act ${moduleInfo.act} loaded (${Object.keys(actData).length} packs)`);
        } catch (error) {
          updateDebugInfo(`✗ Failed to load Act ${moduleInfo.act}: ${error.message}`);
        }
      }

      updateDebugInfo(`${languageName} data loading complete.`);
    }

    // ============================================================
    // SETUP LANGUAGE RADIO BUTTONS: Event Listeners
    // ============================================================

    /*
      Attaches change event listeners to language radio buttons.
      When user changes language, reload all data for that language.
    */
    function setupLanguageRadioButtons() {
      const radios = document.querySelectorAll('input[name="language"]');
      radios.forEach(radio => {
        radio.addEventListener('change', async (e) => {
          const newLanguage = e.target.value;
          state.currentLanguage = newLanguage;
          state.currentAct = null;
          state.currentPack = null;

          // Reset native language to first available option
          const nativeLanguages = LANGUAGE_CONFIG[newLanguage].nativeLanguages;
          state.currentNativeLanguage = Object.values(nativeLanguages)[0];

          // Reload data for new language
          await loadLanguageData(newLanguage);

          // Update UI
          populateActDropdown();
          populateNativeLanguageDropdown();

          // Auto-select first act and pack (same as initialize())
          if (state.loadedData && Object.keys(state.loadedData).length > 0) {
            const firstAct = Math.min(...Object.keys(state.loadedData).map(Number));
            state.currentAct = firstAct;
            document.getElementById('actSelect').value = firstAct;

            // Populate pack dropdown for first act
            populatePackDropdown();

            // Auto-select first pack
            const firstActData = state.loadedData[firstAct];
            if (firstActData) {
              const firstPackKey = Object.keys(firstActData)[0];
              state.currentPack = firstPackKey;
              document.getElementById('packSelect').value = firstPackKey;

              // Display vocabulary
              displayVocabulary();
            }
          }
        });
      });
    }

    // ============================================================
    // SETUP MULTIPLE CHOICE CHECKBOX: Event Listener
    // ============================================================

    /*
      Attaches change event listener to multiple choice mode checkbox.
      When toggled, refreshes the vocabulary table to show/hide wrong answer columns.
    */
    function setupMultipleChoiceCheckbox() {
      const checkbox = document.getElementById('multipleChoiceMode');
      checkbox.addEventListener('change', (e) => {
        state.multipleChoiceMode = e.target.checked;
        displayVocabulary();  // Refresh table with new mode
      });
    }

    // ============================================================
    // SETUP TYPING MODE CHECKBOX: Event Listener
    // ============================================================

    /*
      Attaches change event listener to typing mode checkbox.
      When toggled, refreshes the vocabulary table to show/hide typing columns.
      Also resets all typing states when enabled.
    */
    function setupTypingModeCheckbox() {
      const checkbox = document.getElementById('typingMode');
      checkbox.addEventListener('change', (e) => {
        state.typingMode = e.target.checked;

        // Reset typing states when toggling mode
        state.typingStates.clear();

        displayVocabulary();  // Refresh table with new mode
      });
    }

    // ============================================================
    // AUDIO CONTEXT: For Typing Sound Generation
    // ============================================================

    /*
      Creates and returns the Web Audio API context for sound generation.
      This is used for the satisfying typing/scribble sound.
    */
    let audioContext = null;

    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // ============================================================
    // TYPING SOUND: Mechanical Click (Improved from SimpleFlashCards)
    // ============================================================

    /*
      Plays a satisfying mechanical keyboard click sound on every keypress.
      This sound plays for BOTH correct and wrong keypress (instant feedback).

      SOUND CHARACTERISTICS:
      - Very short duration (0.015-0.025 seconds) for crisp click
      - High frequency (2000-3500 Hz) for mechanical feel
      - Random variation in frequency and volume for natural typing feel
      - Sharp decay envelope for crisp, defined click

      USAGE IN GAMES:
      This sound provides immediate tactile feedback that makes typing feel
      satisfying and responsive. It's crucial for engagement - even wrong
      keypresses should "feel good" to maintain flow state.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Slightly cleaner filter chain
      - Better commented for understanding
    */
    function playTypingSound() {
      const ctx = getAudioContext();

      // Very short duration for crisp mechanical click
      const duration = 0.015 + Math.random() * 0.01;  // 0.015-0.025 seconds
      const bufferSize = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      // Generate sharp click noise with very fast decay
      for (let i = 0; i < bufferSize; i++) {
        const envelope = Math.pow(1 - i/bufferSize, 8);  // Very sharp decay
        const noise = (Math.random() * 2 - 1);
        data[i] = noise * envelope;
      }

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // High frequency bandpass for mechanical click (2000-3500 Hz)
      const bp1 = ctx.createBiquadFilter();
      bp1.type = 'bandpass';
      bp1.frequency.value = 2000 + Math.random() * 1500;  // Random variation
      bp1.Q.value = 4.0;  // High Q for sharp, defined click

      // Mid frequency for body (1000-1500 Hz)
      const bp2 = ctx.createBiquadFilter();
      bp2.type = 'bandpass';
      bp2.frequency.value = 1000 + Math.random() * 500;
      bp2.Q.value = 2.5;

      // Remove low mud
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 400;

      // Moderate volume for satisfying click
      const gain = ctx.createGain();
      gain.gain.value = 0.35 + Math.random() * 0.1;  // 0.35-0.45 with random variation

      // Connect audio chain
      source.connect(hp);
      hp.connect(bp1);
      bp1.connect(bp2);
      bp2.connect(gain);
      gain.connect(ctx.destination);

      source.start();
    }

    // ============================================================
    // CHARACTER NORMALIZATION: For Typing Comparison
    // ============================================================

    /*
      Normalizes a character for typing comparison.

      NORMALIZATION RULES:
      1. Convert to lowercase
      2. Remove accents/diacritics (á → a, ñ → n, ü → u, etc.)

      EXAMPLES:
      - 'Á' → 'a'
      - 'ñ' → 'n'
      - 'Ü' → 'u'
      - 'É' → 'e'

      WHY THIS MATTERS FOR GAMES:
      Most English keyboards don't have accent keys, so learners type
      'hola' instead of 'hóla'. We want to accept their answer as correct.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Same logic, but more clearly documented
      - Explains the "why" for future game developers

      INPUT: Single character string
      OUTPUT: Normalized single character (lowercase, no accents)
    */
    function normalizeCharForTyping(char) {
      return char
        .normalize('NFD')                    // Decompose accents (á → a + ´)
        .replace(/[\u0300-\u036f]/g, '')    // Remove accent marks
        .toLowerCase();                      // Convert to lowercase
    }

    // ============================================================
    // POPULATE ACT DROPDOWN: Based on Loaded Data
    // ============================================================

    /*
      Populates the act dropdown with available acts for current language.

      PROCESS:
      1. Get acts from state.loadedData
      2. Get act names from LANGUAGE_CONFIG
      3. Create option elements
      4. Add change event listener
    */
    function populateActDropdown() {
      const actSelect = document.getElementById('actSelect');
      actSelect.innerHTML = '<option value="">Select an act</option>';

      const acts = Object.keys(state.loadedData).map(Number).sort((a, b) => a - b);
      const config = LANGUAGE_CONFIG[state.currentLanguage];

      acts.forEach(actNum => {
        const moduleInfo = config.modules.find(m => m.act === actNum);
        const option = document.createElement('option');
        option.value = actNum;
        option.textContent = `Act ${actNum}: ${moduleInfo.name}`;
        actSelect.appendChild(option);
      });

      // Event listener for act change
      actSelect.addEventListener('change', (e) => {
        state.currentAct = parseInt(e.target.value);
        state.currentPack = null;
        populatePackDropdown();
        displayVocabulary();
      });
    }

    // ============================================================
    // POPULATE PACK DROPDOWN: Based on Selected Act
    // ============================================================

    /*
      Populates the pack dropdown with wordpacks from selected act.

      PROCESS:
      1. Get pack keys from state.loadedData[currentAct]
      2. Extract pack metadata (title in English)
      3. Create option elements
      4. Add change event listener
    */
    function populatePackDropdown() {
      const packSelect = document.getElementById('packSelect');

      if (!state.currentAct) {
        packSelect.innerHTML = '<option value="">First select an act</option>';
        return;
      }

      packSelect.innerHTML = '<option value="">Select a wordpack</option>';

      const actData = state.loadedData[state.currentAct];
      if (!actData) return;

      // Get all pack keys and sort by wordpack number
      const packKeys = Object.keys(actData);
      packKeys.sort((a, b) => {
        const numA = actData[a].meta.wordpack;
        const numB = actData[b].meta.wordpack;
        return numA - numB;
      });

      packKeys.forEach(packKey => {
        const pack = actData[packKey];
        const option = document.createElement('option');
        option.value = packKey;
        option.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;
        packSelect.appendChild(option);
      });

      // Event listener for pack change
      packSelect.addEventListener('change', (e) => {
        state.currentPack = e.target.value;
        displayVocabulary();
      });
    }

    // ============================================================
    // POPULATE NATIVE LANGUAGE DROPDOWN: Based on Current Language
    // ============================================================

    /*
      Populates the "I speak" dropdown with available native languages.
      Available options depend on the column structure of target language.

      EXAMPLE:
      If learning Spanish, can choose: English, Chinese, Pinyin, Portuguese
      If learning Chinese, can choose: English, Spanish, French, Portuguese, etc.
    */
    function populateNativeLanguageDropdown() {
      const nativeSelect = document.getElementById('nativeLanguageSelect');
      nativeSelect.innerHTML = '';

      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const nativeLanguages = config.nativeLanguages;

      Object.entries(nativeLanguages).forEach(([langName, columnIndex]) => {
        const option = document.createElement('option');
        option.value = columnIndex;
        option.textContent = langName;
        if (columnIndex === state.currentNativeLanguage) {
          option.selected = true;
        }
        nativeSelect.appendChild(option);
      });

      // Event listener for native language change
      nativeSelect.addEventListener('change', (e) => {
        state.currentNativeLanguage = parseInt(e.target.value);
        displayVocabulary();
      });
    }

    // ============================================================
    // STRING NORMALIZATION: For Duplicate Detection
    // ============================================================

    /*
      Normalizes strings for comparison to detect duplicates across wordpacks.

      NORMALIZATION PROCESS:
      1. Convert to lowercase
      2. Remove all spaces
      3. Remove all symbols/punctuation

      EXAMPLES:
      - "Hola Amigo" → "holaamigo"
      - "hello, friend!" → "hellofriend"
      - "你好 朋友" → "你好朋友"

      This catches duplicates that may appear with slight variations:
      - "hola" and "Hola" (case difference)
      - "hello friend" and "hellofriend" (spacing difference)
      - "hello!" and "hello" (punctuation difference)

      INPUT: String to normalize
      OUTPUT: Normalized string (lowercase, no spaces, no symbols)
    */
    function normalizeString(str) {
      return str
        .toLowerCase()
        .replace(/[\s\.,!?;:'"()\[\]{}\-_]/g, '');  // Remove spaces and common symbols
    }

    // ============================================================
    // GENERATE WRONG ANSWERS: Random Selection from Entire Act
    // ============================================================

    /*
      Generates random wrong answers for multiple choice mode.

      UPDATED ALGORITHM (Act-Wide Selection):
      Instead of pulling from just the current wordpack (50 words),
      we now pull from the ENTIRE ACT (all wordpacks, ~2,500 words).

      BENEFITS:
      ✓ More variety (2,500 options vs 50)
      ✓ Less predictable for players
      ✓ Better for advanced learners
      ✓ No additional performance cost (data already in memory)

      PROCESS:
      1. Collect all words from all packs in the current act
      2. Filter out the correct answer (exact match)
      3. Filter out normalized duplicates (case/space/symbol variations)
      4. Shuffle remaining pool using Fisher-Yates
      5. Take first K words as wrong answers (K=4 in this demo)

      EXAMPLE:
      - Act 1 has 50 packs with 50 words each = 2,500 total words
      - Current correct answer: "hola amigo"
      - Normalized: "holaamigo"
      - Filter out: "hola amigo", "Hola Amigo", "hola-amigo" (all normalize to same)
      - Remaining pool: ~2,499 words
      - Randomly select 4 from this pool

      DUPLICATE DETECTION:
      We use normalized string comparison to avoid showing essentially
      the same word with minor variations:
      - "hello" vs "Hello" (different case)
      - "hello friend" vs "hellofriend" (different spacing)
      - "hello!" vs "hello" (different punctuation)

      GAME USAGE:
      Different games need different numbers of wrong answers:
      - Temple Run (3-lane runner): Need 2 wrong answers (3 total choices)
      - Quiz game (4 options): Need 3 wrong answers (4 total choices)
      - This demo: 4 wrong answers to show extensibility

      This algorithm works for ANY language (Spanish, Chinese, English, etc.)
      because it always uses column 0 (target language) from the words array.

      INPUT:
        - actData: Dictionary of all wordpacks in the current act
        - correctAnswer: The correct answer string (to filter out)
        - count: Number of wrong answers to generate (default 4)

      OUTPUT:
        - Array of wrong answer strings from column 0 (target language)
    */
    function generateWrongAnswers(actData, correctAnswer, count = 4) {
      // STEP 1: Normalize the correct answer for comparison
      const normalizedCorrect = normalizeString(correctAnswer);

      // STEP 2: Collect all words from all packs in the act
      const allWords = [];

      // Loop through each pack in the act
      Object.keys(actData).forEach(packKey => {
        const pack = actData[packKey];

        // Loop through each word in this pack
        pack.words.forEach(word => {
          const targetLanguageWord = word[0];  // Column 0 is always target language

          // Filter out the correct answer and normalized duplicates
          if (targetLanguageWord !== correctAnswer) {
            const normalizedWord = normalizeString(targetLanguageWord);

            // Only add if normalized version is different from correct answer
            if (normalizedWord !== normalizedCorrect) {
              allWords.push(targetLanguageWord);
            }
          }
        });
      });

      // STEP 3: Shuffle using Fisher-Yates algorithm for uniform randomness
      for (let i = allWords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
      }

      // STEP 4: Take first 'count' words (or fewer if pool is small)
      const wrongAnswers = allWords.slice(0, Math.min(count, allWords.length));

      return wrongAnswers;
    }

    // ============================================================
    // HANDLE TYPING INPUT: Process Key Presses for Typing Mode
    // ============================================================

    /*
      Handles typing input for a specific word in the vocabulary table.
      This is the CORE TYPING MECHANIC that can be reused in any language game.

      TYPING ALGORITHM (IMPROVED over SimpleFlashCards.html):
      1. Get or initialize typing state for this word
      2. Find next position to type (first untyped non-space character)
      3. Normalize both the typed key and target character (remove accents, lowercase)
      4. Compare:
         - If match: Mark position as typed, play sound
         - If mismatch: Track wrong letter, increment counter, play sound
      5. Update the display (shows X→letter progressively)

      STATE MANAGEMENT (PER-ROW):
      Each word has its own typing state stored in state.typingStates Map:
      {
        typed: Set(),          // Set of character positions successfully typed
        wrongLetters: [],      // Array of wrong letters attempted
        wrongCount: 0          // Total wrong attempts
      }

      KEY IMPROVEMENTS OVER SimpleFlashCards.html:
      - Per-row state instead of global state (more modular)
      - Simpler state structure (easier to understand)
      - Inline in table (no separate card flipping)
      - Better for debugging/testing multiple words at once

      PARAMETERS:
      - wordIndex: Index of the word in the pack (used as state key)
      - correctWord: The correct answer string (target language)
      - key: The key that was pressed
      - inputElement: The input element to update

      RETURNS: Nothing (updates state and DOM directly)
    */
    function handleTypingInput(wordIndex, correctWord, key, inputElement) {
      // STEP 1: Get or create typing state for this word
      if (!state.typingStates.has(wordIndex)) {
        state.typingStates.set(wordIndex, {
          typed: new Set(),
          wrongLetters: [],
          wrongCount: 0
        });
      }

      const typingState = state.typingStates.get(wordIndex);
      const chars = correctWord.split('');

      // STEP 2: Find next unfilled position (skip already typed and spaces)
      let nextPos = 0;
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] === ' ') {
          typingState.typed.add(i);  // Auto-mark spaces as typed
          continue;
        }
        if (!typingState.typed.has(i)) {
          nextPos = i;
          break;
        }
        if (i === chars.length - 1) {
          // Already completed
          return;
        }
      }

      // STEP 3: Normalize characters for comparison (remove accents, lowercase)
      const normalizedKey = normalizeCharForTyping(key);
      const normalizedTarget = normalizeCharForTyping(chars[nextPos]);

      // STEP 4: Play sound for ANY keypress (instant feedback)
      playTypingSound();

      // STEP 5: Check if correct
      if (normalizedKey === normalizedTarget) {
        // CORRECT! Mark position as typed
        typingState.typed.add(nextPos);
      } else {
        // WRONG! Track the wrong letter and increment counter
        typingState.wrongLetters.push(key.toLowerCase());
        typingState.wrongCount++;
      }

      // STEP 6: Update display to show progress
      updateTypingDisplay(wordIndex, correctWord, inputElement);
    }

    // ============================================================
    // UPDATE TYPING DISPLAY: Show Progress in Input Box
    // ============================================================

    /*
      Updates the typing input box to show current progress.

      DISPLAY FORMAT:
      - Untyped characters: Shown as 'X'
      - Typed characters: Shown as actual letter
      - Spaces: Shown as space (auto-typed)

      EXAMPLE PROGRESSION for "hola amigo":
      Initial:  "XXXX XXXXX"
      After 'h': "hXXX XXXXX"
      After 'o': "hoXX XXXXX"
      After 'l': "holX XXXXX"
      After 'a': "hola XXXXX"
      After 'a': "hola aXXXX"
      ... etc ...
      Final:    "hola amigo"

      PARAMETERS:
      - wordIndex: Index of word (to get state)
      - correctWord: The correct answer
      - inputElement: The input element to update
    */
    function updateTypingDisplay(wordIndex, correctWord, inputElement) {
      const typingState = state.typingStates.get(wordIndex);
      if (!typingState) return;

      const chars = correctWord.split('');
      const display = chars.map((char, i) => {
        if (typingState.typed.has(i)) {
          return char;  // Show actual character if typed
        } else {
          return char === ' ' ? ' ' : 'X';  // Show X for untyped, preserve spaces
        }
      }).join('');

      inputElement.value = display;

      // Also update the wrong letters and count columns
      const row = inputElement.closest('tr');
      if (row) {
        const wrongLettersCell = row.cells[row.cells.length - 2];  // Second to last column
        const wrongCountCell = row.cells[row.cells.length - 1];     // Last column

        if (wrongLettersCell) {
          // Display wrong letters with strikethrough
          wrongLettersCell.innerHTML = typingState.wrongLetters
            .map(letter => `<del>${letter}</del>`)
            .join(' ');
        }

        if (wrongCountCell) {
          wrongCountCell.textContent = typingState.wrongCount;
        }
      }
    }

    // ============================================================
    // DISPLAY VOCABULARY: Show 2-Column or Multi-Column Table
    // ============================================================

    /*
      Displays vocabulary for the selected wordpack.

      TABLE MODES:

      BASIC MODE (multipleChoiceMode = false, typingMode = false):
      - 2 columns: Target language (column 0) and Native language (selected)

      MULTIPLE CHOICE MODE (multipleChoiceMode = true):
      - 6 columns: Target language, Native language, + 4 wrong answers
      - Wrong answers are randomly selected from ALL packs in current act
      - Duplicate filtering applied (normalized string comparison)

      TYPING MODE (typingMode = true):
      - 5 columns: Target language, Native language, Typing input, Wrong letters, Wrong count
      - Interactive typing practice with instant feedback

      PROCESS:
      1. Get selected wordpack from state.loadedData
      2. Check which modes are enabled
      3. Update table headers accordingly
      4. Loop through words array
      5. For each word:
         - Display word[0] in column 1 (target language - correct answer)
         - Display word[nativeLanguageIndex] in column 2 (translation)
         - If multiple choice mode: Generate and display 4 wrong answers
         - If typing mode: Add typing input box and tracking columns
    */
    function displayVocabulary() {
      const tableBody = document.getElementById('vocabularyTable');
      const packTitleEl = document.getElementById('packTitle');
      const tableHeaderRow = document.getElementById('tableHeaderRow');

      // Clear table
      tableBody.innerHTML = '';

      // Calculate colspan based on active modes
      let totalColumns = 2;  // Base: target language + native language
      if (state.multipleChoiceMode) totalColumns += 4;  // Add 4 wrong answer columns
      if (state.typingMode) totalColumns += 3;  // Add typing input + wrong letters + wrong count

      // Validate selection
      if (!state.currentAct || !state.currentPack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Please select an act and wordpack</td></tr>`;
        packTitleEl.textContent = 'No pack selected';
        return;
      }

      // Get wordpack data
      const actData = state.loadedData[state.currentAct];
      if (!actData) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Act data not loaded</td></tr>`;
        return;
      }

      const pack = actData[state.currentPack];
      if (!pack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Pack not found</td></tr>`;
        return;
      }

      // Update pack title
      packTitleEl.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;

      // Get language names
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const targetLanguage = config.columns[0];  // Column 0 is always target language
      const nativeLanguage = config.columns[state.currentNativeLanguage];

      // ============================================================
      // UPDATE TABLE HEADERS: Based on Mode
      // ============================================================
      /*
        Build headers dynamically based on enabled modes:
        - Base: Target language + Native language (2 columns)
        - Multiple Choice: + 4 wrong answer columns
        - Typing: + Typing input + Wrong letters + Wrong count (3 columns)
      */
      let headers = [];

      // Base columns (always present)
      if (state.multipleChoiceMode) {
        headers.push(`<th>Correct Answer (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.typingMode) {
        headers.push(`<th>Target Word (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else {
        headers.push(`<th>I am learning (${targetLanguage})</th>`);
        headers.push(`<th>I speak (${nativeLanguage})</th>`);
      }

      // Multiple choice columns (if enabled)
      if (state.multipleChoiceMode) {
        headers.push('<th>Wrong Answer 1</th>');
        headers.push('<th>Wrong Answer 2</th>');
        headers.push('<th>Wrong Answer 3</th>');
        headers.push('<th>Wrong Answer 4</th>');
      }

      // Typing mode columns (if enabled)
      if (state.typingMode) {
        headers.push('<th>Type Here (X = letter)</th>');
        headers.push('<th>Wrong Letters</th>');
        headers.push('<th>Wrong Count</th>');
      }

      tableHeaderRow.innerHTML = headers.join('\n');

      // ============================================================
      // POPULATE TABLE ROWS: Generate vocabulary with optional wrong answers
      // ============================================================
      pack.words.forEach((word, index) => {
        const row = document.createElement('tr');

        // COLUMN 1: Target language (correct answer, column 0 from words array)
        const cell1 = document.createElement('td');
        cell1.textContent = word[0];
        row.appendChild(cell1);

        // COLUMN 2: Native language translation (selected column from words array)
        const cell2 = document.createElement('td');
        cell2.textContent = word[state.currentNativeLanguage];
        row.appendChild(cell2);

        // COLUMNS 3-6: Wrong answers (only in multiple choice mode)
        if (state.multipleChoiceMode) {
          /*
            Generate 4 random wrong answers from ALL wordpacks in the current act.
            - Current correct answer: word[0] (target language, column 0)
            - Pool: All words from all packs in the current act (~2,500 words)
            - Filtering: Exclude correct answer and normalized duplicates
            - Each wrong answer is from column 0 (target language)
          */
          const correctAnswer = word[0];
          const wrongAnswers = generateWrongAnswers(actData, correctAnswer, 4);

          // Add each wrong answer as a table cell
          wrongAnswers.forEach(wrongAnswer => {
            const wrongCell = document.createElement('td');
            wrongCell.textContent = wrongAnswer;
            row.appendChild(wrongCell);
          });

          // Handle edge case: If act has fewer than 5 words total,
          // we might have fewer than 4 wrong answers. Fill remaining cells.
          const wrongAnswerCount = wrongAnswers.length;
          for (let i = wrongAnswerCount; i < 4; i++) {
            const emptyCell = document.createElement('td');
            emptyCell.textContent = '(Not enough words in act)';
            row.appendChild(emptyCell);
          }
        }

        // TYPING MODE COLUMNS: Input box + Wrong letters + Wrong count
        if (state.typingMode) {
          /*
            Add typing practice columns for this word:
            1. Typing input box (initialized with "XXXX XXXXX" format)
            2. Wrong letters column (displays struck-through wrong attempts)
            3. Wrong count column (displays total wrong attempts)
          */
          const correctWord = word[0];

          // COLUMN: Typing input box
          const typingCell = document.createElement('td');
          const typingInput = document.createElement('input');
          typingInput.type = 'text';
          typingInput.readOnly = true;  // Prevent direct editing
          typingInput.style.width = '100%';
          typingInput.style.fontFamily = 'monospace';
          typingInput.style.fontSize = '1em';
          typingInput.style.padding = '4px';

          // Initialize display with X's for each letter (preserve spaces)
          const initialDisplay = correctWord.split('').map(char => char === ' ' ? ' ' : 'X').join('');
          typingInput.value = initialDisplay;

          // Add keypress listener to this specific input
          typingInput.addEventListener('keydown', (e) => {
            // Only handle single character keys (not arrow keys, backspace, etc.)
            if (e.key.length === 1) {
              e.preventDefault();  // Prevent default input behavior
              handleTypingInput(index, correctWord, e.key, typingInput);
            }
          });

          // Make input focusable by clicking
          typingInput.addEventListener('click', () => {
            typingInput.focus();
          });

          typingCell.appendChild(typingInput);
          row.appendChild(typingCell);

          // COLUMN: Wrong letters (initially empty)
          const wrongLettersCell = document.createElement('td');
          wrongLettersCell.style.fontFamily = 'monospace';
          row.appendChild(wrongLettersCell);

          // COLUMN: Wrong count (initially 0)
          const wrongCountCell = document.createElement('td');
          wrongCountCell.textContent = '0';
          wrongCountCell.style.textAlign = 'center';
          row.appendChild(wrongCountCell);
        }

        tableBody.appendChild(row);
      });

      // Update debug info with active modes
      let modeParts = [];
      if (state.multipleChoiceMode) modeParts.push('Multiple Choice (act-wide pool)');
      if (state.typingMode) modeParts.push('Typing Practice');
      const modeText = modeParts.length > 0 ? modeParts.join(' + ') : 'Basic (2 columns)';

      // Count total words in act for debug info
      let totalActWords = 0;
      Object.keys(actData).forEach(packKey => {
        totalActWords += actData[packKey].words.length;
      });

      updateDebugInfo(`Displaying Pack ${pack.meta.wordpack}: ${pack.meta.english}\n` +
                      `Words in this pack: ${pack.words.length}\n` +
                      `Total words in Act ${state.currentAct}: ${totalActWords}\n` +
                      `Mode: ${modeText}\n` +
                      `Total columns: ${totalColumns}\n` +
                      `Target language: ${targetLanguage} (column 0)\n` +
                      `Native language: ${nativeLanguage} (column ${state.currentNativeLanguage})`);
    }

    // ============================================================
    // UPDATE DEBUG INFO: Display Technical Details
    // ============================================================

    /*
      Updates the debug information section with current state and messages.
      Useful for developers/LLMs to understand what's happening.
    */
    function updateDebugInfo(message) {
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toLocaleTimeString();
      debugInfo.textContent = `[${timestamp}] ${message}\n\n` +
        `Current State:\n` +
        `- Language: ${state.currentLanguage}\n` +
        `- Act: ${state.currentAct || 'None'}\n` +
        `- Pack: ${state.currentPack || 'None'}\n` +
        `- Native Language Column: ${state.currentNativeLanguage}\n` +
        `- Multiple Choice Mode: ${state.multipleChoiceMode ? 'Enabled' : 'Disabled'}\n` +
        `- Typing Mode: ${state.typingMode ? 'Enabled' : 'Disabled'}\n` +
        `- Active Typing States: ${state.typingStates.size}\n` +
        `- Loaded Acts: ${Object.keys(state.loadedData).join(', ') || 'None'}`;
    }

    // ============================================================
    // AUTO-RUN ON PAGE LOAD
    // ============================================================

    /*
      Automatically initialize when DOM is ready.
      This removes the need for a "Run Test" button.
    */
    window.addEventListener('DOMContentLoaded', initialize);

  </script>

</body>
</html>
