Function Name,What the Function Does,How the Function Works,Reusability Score (1-10)
getAudioContext(),"Provides a singleton Web Audio API context for all game sounds. This is the foundational audio infrastructure that all sound functions depend on. By ensuring only one AudioContext exists throughout the application lifecycle, it prevents audio glitches, resource exhaustion, and memory leaks that would occur from creating multiple contexts. Every other sound function in this file calls getAudioContext() first, making this the critical foundation for all audio playback. The singleton pattern also ensures audio state (running, suspended) is consistent across the entire application.","Uses a lazy initialization pattern with a module-level variable 'audioContext' initialized to null. On the first call, checks if audioContext is null and if so, creates a new AudioContext using 'new (window.AudioContext || window.webkitAudioContext)()' - the logical OR handles browser compatibility since older Safari/iOS browsers use the webkit prefix. On subsequent calls, returns the existing instance immediately. This guarantees exactly one AudioContext exists regardless of how many times the function is called. The returned context provides access to all Web Audio API features: createOscillator(), createGain(), createBiquadFilter(), createBuffer(), currentTime, destination, sampleRate, etc. The context also manages audio thread lifecycle and handles browser autoplay policies (context starts suspended until user interaction).",10
playCardFlipSound(),"Plays a soft, muffled page-turn sound effect for flashcard flipping between front and back. This sound was carefully tuned through dozens of iterations to achieve an 'ultra-soft' quality described as 'floating on clouds' - pleasant and satisfying without being harsh or jarring. The sound provides essential tactile audio feedback that the card state has changed, enhancing the physical feel of the digital flashcard experience. At 0.23 seconds duration, it's brief but noticeable. Used in FlashcardTypingGame when cards flip, this is a core UX element that all flashcard-based learning games would need.","Generates sound procedurally using Web Audio API rather than loading audio files - this keeps the module self-contained with no external dependencies. Gets the audio context via getAudioContext(). Creates a 0.23-second audio buffer (bufferSize = sampleRate * 0.23). Fills the buffer with white noise (Math.random() * 2 - 1 generates values from -1 to +1) shaped by an amplitude envelope: Math.sin(t * Math.PI) creates a smooth fade-in-fade-out arc, multiplied by Math.sin(t * Math.PI * 0.38) which adds subtle amplitude modulation creating the 'soft' quality, then multiplied by 0.26 for volume control. This shaped noise is fed through two cascading lowpass filters: the first at 400Hz and second at 580Hz, which progressively remove high frequencies creating the characteristic muffled/soft quality (higher frequencies = harsher sound). A gain node at 2.5 (labeled 'page turn volume') boosts the heavily filtered signal to audible levels. Chain: source → lp (400Hz) → lp2 (580Hz) → gain (2.5) → destination. source.start() triggers immediate playback.",10
playDingSound(),"Plays a gentle, harmonious bell chord to indicate correct answers, achievements, or successful actions. The sound is a C major chord (C5-E5-G5 notes at 523.25Hz, 659.25Hz, 783.99Hz) which universally conveys positivity, success, and accomplishment in Western music. This is the primary positive reinforcement sound for language learning - rewarding learners with a pleasant musical confirmation when they answer correctly. Duration is 0.6 seconds with exponential decay, making it noticeable but not disruptive to the learning flow. Both FlashcardTypingGame and any future quiz/typing games would use this for correct answer feedback.","Creates three simultaneous sine wave oscillators representing C5 (523.25Hz), E5 (659.25Hz), and G5 (783.99Hz) - the C major triad. Uses forEach to iterate over the frequency array, creating for each note: an oscillator (osc.type = 'sine'), a lowpass filter at 1500Hz (softens the pure sine waves by removing any harmonics above 1500Hz), and a gain node for volume control. The volume decreases per note in the chord: 0.2 - i * 0.04 yields 0.2, 0.16, 0.12 - this creates natural harmonic balance where the root note (C5) is loudest. Each gain envelope uses setValueAtTime(0, now) to start silent, linearRampToValueAtTime(vol, now + 0.01) for 10ms attack, then exponentialRampToValueAtTime(0.001, now + 0.6) for exponential decay over 0.6 seconds creating the bell-like ring-out. Notes are staggered: osc.start(now + i * 0.03) starts each note 30ms apart, creating a subtle arpeggio/shimmer effect rather than a harsh simultaneous attack. Chain per note: osc → filter → gain → destination. All oscillators stop at now + 0.7 seconds.",10
playBuzzSound(),"Plays a two-tone descending 'nope' sound to indicate wrong answers, failed attempts, or invalid actions. The sound descends from D4 (293.66Hz) to A3 (220Hz), creating a gentle but clear rejection signal. Critically, this is designed to be informative without being harsh or punishing - the lowpass filtering and moderate volume ensure learners recognize their mistake without feeling discouraged or anxious. This supportive approach to negative feedback is essential for maintaining learner motivation. Total duration is ~0.27 seconds (0.15s per tone with 0.12s stagger), brief enough not to interrupt learning flow. Used in FlashcardTypingGame for wrong keypresses and incorrect answers.","Creates two sequential sine wave oscillators at D4 (293.66Hz) and A3 (220Hz) - the descending pitch psychologically signals 'no/wrong' across cultures. Uses forEach to iterate over the frequency array, creating for each note: an oscillator (sine wave), a lowpass filter at 800Hz (significantly lower than the ding sound's 1500Hz, creating a warmer/gentler rejection tone), and a gain node. The notes are staggered: startTime = now + i * 0.12 means the second note starts 120ms after the first. Each note's envelope: gain.setValueAtTime(0, startTime) starts silent, linearRampToValueAtTime(0.2, startTime + 0.01) provides 10ms attack to volume 0.2, exponentialRampToValueAtTime(0.001, startTime + 0.15) provides 150ms exponential decay. Each oscillator starts at its calculated startTime and stops at startTime + 0.15 seconds. The 800Hz lowpass filter is key - it removes higher frequencies that could make the sound feel harsh or punishing. Chain per note: osc → filter → gain → destination.",10
playButtonClickSound(),"Plays a crisp, satisfying click sound for UI interactions including button presses, menu selections, and any interactive element activation. Described in comments as 'PERFECT' and 'balanced and satisfying' with 'subtle low end', this sound provides immediate tactile feedback that a user action has been registered. The click is extremely short (0.03 seconds) for instant responsiveness. At gain 0.75, it's the loudest sound in the module - this ensures it's clearly audible even during other game audio. Used extensively in FlashcardTypingGame (6+ call sites) for navigation buttons, mode switches, menu interactions, and more. Essential for any game UI.","Generates a 0.03-second (30ms) burst of white noise in an audio buffer. The noise is shaped with envelope: Math.pow(1 - i/bufferSize, 4.5) which creates an extremely sharp exponential decay - starts at full volume and rapidly drops to near-zero, the quintessential 'click' profile. This noise passes through two cascading lowpass filters: first at 800Hz (Q=0.7), second at 1200Hz - these remove high-frequency harshness and create the characteristic muffled 'thock' quality. Additionally creates a sine wave oscillator sweeping from 120Hz to 60Hz over 0.025 seconds at low volume (oscGain.gain = 0.05) - this provides subtle low-end 'punch' making the click feel more substantial and tactile. The noise component gives the sharp attack, the sine sweep adds body/depth. Both components connect to destination: source → lp → lp2 → gain (0.75) → destination, and osc → oscGain → destination. Both start immediately, osc stops at now + 0.04s. The combined result is a satisfying, tactile click with both crisp attack and subtle warmth.",10
playKeyboardSound(),"A reference implementation of a mechanical keyboard sound that is currently UNUSED in the codebase. Comments explicitly state 'NOTE: This sound is kept for future reference but currently unused. Use playScribbleSound() for actual typing sounds.' It demonstrates an alternative typing sound approach with a brighter, more clicky character compared to playScribbleSound(). Kept in the module for documentation purposes and potential future use if a different typing sound aesthetic is desired. The sound has more high-frequency content and a sharper, more 'clacky' character than playScribbleSound().","Creates a 0.04-second (40ms) white noise burst shaped with Math.pow(1 - i/bufferSize, 5) for sharp exponential decay. Unlike playScribbleSound which uses bandpass for mid-frequencies, this uses highpass at 2000Hz (removes everything below 2kHz, keeping only treble) followed by bandpass at 4500Hz with Q=2 (selects a narrow band around 4.5kHz). This filtering approach isolates the high-pitched 'click' frequencies characteristic of mechanical keyboard switches, creating a brighter, sharper sound than playScribbleSound(). Gain is 0.3 for moderate volume. Chain: source → highpass (2000Hz) → bandpass (4500Hz, Q=2) → gain (0.3) → destination. While functional, playScribbleSound() is preferred in actual games because it has more variation (randomized parameters) and warmer character better suited for extended typing sessions.",6
playScribbleSound(),"Generates a satisfying mechanical keyboard typing sound with randomization for natural variation. This is the PRIMARY typing feedback sound used on each keypress during typing practice modes. The sound has a clicky, tactile mechanical character that makes typing feel responsive and enhances the typing experience. Key feature: randomization. Duration varies (0.015-0.025s), filter frequencies vary - this simulates real mechanical keyboards where each key sounds slightly different, preventing the fatigue that comes from hearing an identical sound repeatedly. Used in typing modes across games. Volume of 0.8 ensures prominence during rapid typing.","Uses procedural synthesis for organic variation on every call. Duration is randomized: 0.015 + Math.random() * 0.01 yields 15-25ms. Creates white noise buffer, shaped with very sharp decay: Math.pow(1 - i/bufferSize, 8) - power of 8 is sharper than other sounds, creating maximum crispness. The noise passes through three filters: (1) highpass at 400Hz removes low-frequency 'mud' without eliminating body, (2) bandpass at 2000 + Math.random() * 1500 (2000-3500Hz, Q=4.0) provides the sharp 'click' component in the high-frequency range, (3) second bandpass at 1000 + Math.random() * 500 (1000-1500Hz, Q=2.5) provides the 'body/thock' component in mid-frequencies. The randomized filter frequencies are KEY - each keystroke sounds subtly different, mimicking real mechanical keyboard variation. Final gain of 0.8 makes it prominent. Chain: source → highpass (400Hz) → bp1 (random 2-3.5kHz) → bp2 (random 1-1.5kHz) → gain (0.8) → destination. The combination of randomized duration AND randomized frequencies creates rich, organic typing sound variation that doesn't fatigue the ear during extended practice.",10
