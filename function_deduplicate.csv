Better_Function_Name,Similar_Duplicate_Functions,Consolidation_Strategy
navigateToPrevious,"goToPrevious() (FlashcardTypingGame.html:3771), navigateToPrevious() (wordpack-logic.js:2159)","Keep navigateToPrevious() in wordpack-logic.js as-is. Refactor goToPrevious() to use it: Replace entire function body with: const newIndex = navigateToPrevious({deck: currentDeck, currentIndex}, {onNavigate: (idx) => { speechSynthesis.cancel(); playCardFlipSound(); currentIndex = idx; if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); }, onAutoSpeak: currentMode === 'spelling' ? speakSpanish : null}); This eliminates 15 lines of duplicate navigation logic."
navigateToNext,"goToNext() (FlashcardTypingGame.html:3789), navigateToNext() (wordpack-logic.js:2186)","Keep navigateToNext() in wordpack-logic.js as-is. Refactor goToNext() to use it: Replace entire function body with: const newIndex = navigateToNext({deck: currentDeck, currentIndex}, {onNavigate: (idx) => { speechSynthesis.cancel(); playCardFlipSound(); currentIndex = idx; if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); }, onAutoSpeak: currentMode === 'spelling' ? speakSpanish : null}); Eliminates 15 lines of duplicate code."
moveToNextCard,"moveToNextCard() (FlashcardTypingGame.html:3807), navigateToNext() (wordpack-logic.js:2186)","Replace moveToNextCard() entirely with a call to navigateToNext(): const newIndex = navigateToNext({deck: currentDeck, currentIndex}, {onNavigate: (idx) => { playCardFlipSound(); currentIndex = idx; if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); }, onAutoSpeak: currentMode === 'spelling' ? speakSpanish : null}); This is just navigateToNext with slightly different callbacks - can be unified."
resetDeckToOriginal,"resetDeck() (FlashcardTypingGame.html:3926), resetDeckToOriginal() (wordpack-logic.js:2210)","Keep resetDeckToOriginal() in wordpack-logic.js. Refactor resetDeck() to use it: const result = resetDeckToOriginal(originalDeck, {onReset: (newDeck) => { currentDeck = newDeck; currentIndex = 0; if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); if (isFlipped) { flashcard.classList.remove('flipped'); isFlipped = false; } pendingDeckChange = 0; updateDisplay(); if (currentMode === 'spelling' && currentDeck.length > 0) setTimeout(() => speakSpanish(), 300); saveState(); }}); currentDeck = result.deck; currentIndex = result.currentIndex; Eliminates 20+ lines of duplicate reset logic."
navigateToNextPack,"goToNextPack() (FlashcardTypingGame.html:3452), navigateToNextPack() (wordpack-logic.js:2235)","Keep navigateToNextPack() in wordpack-logic.js. Refactor goToNextPack() to use it: playButtonClickSound(); const nextPackKey = navigateToNextPack(wordpacks, currentWordpackKey); currentWordpackKey = nextPackKey; const menuWordpack = document.getElementById('menu-wordpack'); if (menuWordpack) menuWordpack.value = nextPackKey; initializeDeck(nextPackKey); updateWordpackTitle(); saveState(); This separates pure calculation (navigateToNextPack) from side effects (UI updates). Eliminates duplicate pack key calculation logic."
setTTSSpeed,"setSpeed() (FlashcardTypingGame.html:3977), setTTSSpeed() (wordpack-logic.js:2253)","REMOVE setSpeed() from FlashcardTypingGame.html entirely. Replace all calls with: currentSpeed = setTTSSpeed(speed, speedBtns); saveState(); The wordpack-logic.js version already handles button state updates. Game just needs to save state after calling it. Eliminates 6 lines of duplicate button-toggling logic."
updateWordpackTitleDisplay,"updateWordpackTitle() (FlashcardTypingGame.html:4139), updateWordpackTitleDisplay() (wordpack-logic.js:2381)","REMOVE updateWordpackTitle() from FlashcardTypingGame.html entirely. Replace all calls with: updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks); The shared version is more generic and reusable. Game provides element reference. Eliminates 8 lines of duplicate title formatting logic."
removeCard,"removeCurrentCard() (FlashcardTypingGame.html:3845), removeCard() (wordpack-logic.js:1769)","Keep removeCard() in wordpack-logic.js as pure function. Refactor removeCurrentCard() to use it: pendingDeckChange = -1; updateDisplay(); showSuccessStamp(() => { const result = removeCard(currentDeck, currentIndex); currentDeck = result.deck; currentIndex = result.newIndex; pendingDeckChange = 0; playCardFlipSound(); updateDisplay(); saveState(); if (typeof updateDebugTable === 'function') updateDebugTable(); }); This separates deck manipulation (pure) from visual effects (stamps, sounds). Eliminates duplicate deck splicing logic."
addDuplicateCards,"addDuplicateCards() (FlashcardTypingGame.html:2752), addConfusedCards() (FlashcardTypingGame.html:3890), addDuplicateCards() (wordpack-logic.js:1805)","Keep addDuplicateCards() in wordpack-logic.js as pure function. REMOVE addDuplicateCards(count) from FlashcardTypingGame.html (it's a thin wrapper calling shared version). Refactor addConfusedCards() to use shared version: pendingDeckChange += 2; updateDisplay(); showFailureStamp(() => { const result = addDuplicateCards(currentDeck, currentDeck[currentIndex], 2); currentDeck = result.deck; currentIndex = result.newIndex; pendingDeckChange = 0; playCardFlipSound(); updateDisplay(); saveState(); }); Consolidates all duplicate-adding logic into one shared function."
initializeDeck,"initializeDeck() (FlashcardTypingGame.html:3328), createDeckFromPack() (wordpack-logic.js:1848)","These serve different purposes but overlap significantly. Refactor initializeDeck() to use createDeckFromPack() for core deck creation: if (!packKey || !wordpacks[packKey]) { currentDeck = []; originalDeck = []; updateDisplay(); return; } const pack = wordpacks[packKey]; const translations = getTranslationsConfig(); const nativeIndex = translations[nativeLanguage]?.index || translations[getDefaultTranslation()].index; const result = createDeckFromPack(pack, { difficulty: currentDifficulty, nativeIndex: nativeIndex, targetIsChinese: isChineseMode(), wordColumns: getWordColumns() }); originalDeck = result.deck; currentDeck = [...originalDeck]; currentIndex = 0; updateDisplay(); if (typeof updateDebugTable === 'function') updateDebugTable(); This eliminates 60+ lines of duplicate deck creation logic while preserving game-specific state management."
loadAct,"loadAct() (FlashcardTypingGame.html:2949), loadAct() (wordpack-logic.js:398)","These are fundamentally different - FlashcardTypingGame version manages global state (loadedActs, loadedActMeta, wordpacks), while wordpack-logic.js version is stateless and returns data. KEEP BOTH but rename FlashcardTypingGame version to loadAndStoreAct() to clarify difference. The game version should internally call the shared loadAct(): async function loadAndStoreAct(actNumber) { if (loadedActs[actNumber]) return loadedActs[actNumber]; const url = MODULE_URLS[actNumber - 1]; if (!url) throw new Error(`Act ${actNumber} URL not found`); const { actMeta, packs } = await window.loadAct(url); if (actMeta) { loadedActMeta[actNumber] = actMeta; console.log(`Act ${actNumber} metadata:`, actMeta.actName); } loadedActs[actNumber] = packs; Object.assign(wordpacks, packs); console.log(`Act ${actNumber} loaded:`, Object.keys(packs).length, 'packs'); return packs; } This separates concerns - shared version decodes, game version stores."
hideFeedback,"hideFeedback() (FlashcardTypingGame.html:4053), (potential shared version)","Create hideFeedback() in wordpack-logic.js: function hideFeedback(feedbackElements) { feedbackElements.forEach(el => { if (el) el.classList.remove('visible'); }); } Then in FlashcardTypingGame.html: hideFeedback([feedbackFront, feedbackBack]); This makes feedback hiding reusable across all games with pronunciation modes. Only 4 lines but promotes consistency."
startListening,"startListening() (FlashcardTypingGame.html:4059), (potential shared version)","This is 77 lines of complex speech recognition logic that could be shared. Extract core logic to wordpack-logic.js as startSpeechRecognition(options): function startSpeechRecognition({ recognition, targetWord, targetLanguage, onResult, onError, onEnd }) { // Core speech recognition logic... } Then FlashcardTypingGame.html becomes: startListening(isFront) { if (!recognition || currentDeck.length === 0 || isListening) return; isListening = true; micBtnControl.classList.add('spelling'); const card = currentDeck[currentIndex]; const expected = card[getTargetLanguage()] || card.spanish || ''; startSpeechRecognition({ recognition, targetWord: expected, targetLanguage: getTargetLanguage(), onResult: (bestScore, bestMatch, normalizedData) => { updatePronunciationDebug({...normalizedData, threshold: getSimilarityThreshold(expected)}); showFeedback(bestScore, bestMatch, expected, isFront); }, onError: (error) => { console.error('Speech recognition error:', error); isListening = false; micBtnControl.classList.remove('spelling'); if (error.error === 'no-speech') showFeedback(0, '(no speech detected)', expected, isFront); else if (error.error === 'not-allowed') alert('Microphone access denied...'); }, onEnd: () => { isListening = false; micBtnControl.classList.remove('spelling'); } }); } This eliminates 50+ lines of duplicate speech recognition setup that every speaking game needs."
simulateCorrectAnswer,"simulateRight() (FlashcardTypingGame.html:4495), simulateCorrectAnswer() (wordpack-logic.js:2409)","REMOVE simulateRight() from FlashcardTypingGame.html entirely. Replace with call to shared version: window.simulateRight = function() { if (currentDeck.length === 0) return; playDingSound(); const result = simulateCorrectAnswer(currentDeck, currentIndex, () => { if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); updateDebugTable(); console.log('[Debug] Simulated RIGHT answer - card removed'); }); currentDeck = result.deck; currentIndex = result.currentIndex; }; This eliminates 15+ lines of duplicate simulation logic."
simulateWrongAnswer,"simulateWrong() (FlashcardTypingGame.html:4523), simulateWrongAnswer() (wordpack-logic.js:2442)","REMOVE simulateWrong() from FlashcardTypingGame.html entirely. Replace with call to shared version: window.simulateWrong = function() { if (currentDeck.length === 0) return; playBuzzSound(); const result = simulateWrongAnswer(currentDeck, currentIndex, 2, () => { if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); updateDebugTable(); console.log('[Debug] Simulated WRONG answer - added 2 duplicates'); }); currentDeck = result.deck; currentIndex = result.currentIndex; }; Eliminates 15+ lines of duplicate simulation logic."
simulateNearVictory,"simulateNearVictory() (FlashcardTypingGame.html:4549), simulateNearVictory() (wordpack-logic.js:2469)","REMOVE simulateNearVictory() from FlashcardTypingGame.html entirely. Replace with call to shared version: window.simulateNearVictory = function() { if (currentDeck.length === 0) return; playButtonClickSound(); const result = simulateNearVictory(currentDeck, () => { if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); updateDebugTable(); console.log('[Debug] Simulated NEAR VICTORY - only last card remains'); }); currentDeck = result.deck; currentIndex = result.currentIndex; }; Eliminates 12+ lines of duplicate simulation logic."
handleTypingInput,"handleTypingInput() (FlashcardTypingGame.html:2790), (uses shared helper functions)","This 110-line function can be significantly simplified by using shared helpers from wordpack-logic.js. Current code has inline logic for: findNextTypingPosition (lines 2799-2815) → Replace with: const nextPos = findNextTypingPosition(targetChars, typedPositions); checkTypingKey (lines 2822-2896) → Replace with: const isCorrect = checkTypingKey(key, targetChars[nextPos]); isWordComplete (line 2830) → Replace with: if (isWordComplete(targetChars, typedPositions)) {...} This would reduce handleTypingInput() from 110 lines to ~60 lines by eliminating inline character normalization, position finding, and completion checking. The game-specific parts (stamps, sounds, auto-advance) would remain, but core typing validation becomes one-liners calling shared functions."
restartCurrentPack,"restartCurrentPack() (FlashcardTypingGame.html:3432), resetDeckToOriginal() (wordpack-logic.js:2210)","These are nearly identical. REMOVE restartCurrentPack() and replace all calls with: playButtonClickSound(); const result = resetDeckToOriginal(originalDeck, {onReset: (newDeck) => { currentDeck = newDeck; currentIndex = 0; if (currentMode === 'spelling' || currentMode === 'translation') initializeTypingDisplay(); updateDisplay(); saveState(); if (typeof updateDebugTable === 'function') updateDebugTable(); }}); currentDeck = result.deck; currentIndex = result.currentIndex; Eliminates 18 lines of duplicate restart logic."
