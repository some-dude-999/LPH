<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=1024">
  <title>Flashcard Typing Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
  <!-- Chinese font - loaded but only applied when Chinese modules are used -->
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC:wght@700&display=swap" rel="stylesheet">
  <style>
    /* =================================================================
       DESIGN SYSTEM - Single source of truth for fonts, colors, textures
       ================================================================= */
    :root {
      /* ===========================================
         FONTS - Only 4 fonts used in entire project
         =========================================== */
      /* 1. Handwriting font - main card text (target words) */
      --font-card: 'IM Fell English', serif;

      /* 2. Monospace font - answer/back of card, tooltips */
      --font-answer: 'Courier New', monospace;

      /* 3. UI font - buttons, titles, labels, everything else */
      --font-ui: 'Cinzel', serif;

      /* 4. Chinese font - front card Chinese characters only */
      --font-chinese: 'LXGW WenKai TC', serif;

      /* ===========================================
         COLORS - Only 3 text colors used
         =========================================== */
      /* 1. Dark brown - main text on light backgrounds */
      --color-text-dark: #2C1810;

      /* 2. Off-white/cream - text on dark backgrounds (card counter, etc) */
      --color-text-light: #F5E6D3;

      /* 3. Gold - accent for titles and special elements */
      --color-text-gold: #E8D498;

      /* ===========================================
         TEXTURES - Paper and cardboard effects
         =========================================== */
      /* Paper texture (for cards) - 200x200 viewBox */
      --paper-texture: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.5' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)'/%3E%3C/svg%3E");
      --paper-texture-size: 200px 200px;

      /* Cardboard texture (for buttons) - Same 200x200 viewBox, 2x larger grain */
      --cardboard-texture: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.5' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)'/%3E%3C/svg%3E");
      --cardboard-texture-size: 400px 400px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background:
        radial-gradient(ellipse at center, #8B7355 0%, #5D4E37 50%, #3D2E1F 100%);
      font-family: var(--font-card);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      padding-top: 80px; /* Space for fixed header */
      color: var(--color-text-dark);
    }

    /* ============================================================
       KEY FEATURE: Fixed Page Header
       Core Objective: Keep mode buttons, title, and UI buttons
       always visible at the top of the page
       Key Behaviors:
         - Fixed position at top of viewport
         - Contains mode selector (left), title (center), UI buttons (right)
         - Always visible even when scrolling/fullscreen
       ============================================================ */
    .page-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
      background: linear-gradient(180deg, rgba(61, 46, 31, 0.85) 0%, rgba(61, 46, 31, 0) 100%);
    }

    .header-buttons {
      display: flex;
      gap: 10px;
    }

    /* Remove focus outline from all interactive elements */
    button:focus,
    button:active,
    select:focus,
    input:focus,
    .mode-btn:focus,
    .mode-btn:active,
    .action-btn:focus,
    .action-btn:active,
    .nav-btn:focus,
    .nav-btn:active {
      outline: none !important;
    }

    /* Wordpack Selector */
    .selector-container {
      background: rgba(60, 46, 31, 0.6);
      padding: 12px 20px;
      border-radius: 8px;
      margin-bottom: 30px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      border: 1px solid rgba(139, 115, 85, 0.3);
    }

    .selector-container label {
      font-family: var(--font-ui);
      font-size: 1rem;
      font-weight: bold;
      margin-right: 10px;
      color: var(--color-text-gold);
    }

    #wordpack-select {
      font-family: var(--font-ui);
      font-size: 1rem;
      font-weight: bold;
      padding: 8px 15px;
      border: 1px solid rgba(139, 115, 85, 0.4);
      border-radius: 5px;
      background: rgba(45, 35, 25, 0.8);
      color: var(--color-text-gold);
      cursor: pointer;
      min-width: 200px;
    }

    #wordpack-select:focus {
      outline: none;
      border-color: #8B7355;
      box-shadow: 0 0 5px rgba(139, 115, 85, 0.3);
    }

    #wordpack-select option {
      background: #3D2E1F;
      color: var(--color-text-gold);
    }

    /* Wordpack Title - Warm gold with subtle texture */
    /* ============================================================
       KEY FEATURE: Page Title in Header
       Core Objective: Show context while keeping card as focal point
       Key Behaviors:
         - Visible but not overpowering
         - Centered in header bar
       ============================================================ */
    .wordpack-title {
      /* Bright gold gradient */
      background-image:
        var(--cardboard-texture),
        linear-gradient(180deg,
          #E8C252 0%,      /* Bright gold */
          #D4AF37 30%,     /* Classic gold */
          #C9A227 60%,     /* Medium gold */
          #A67C38 100%     /* Bronze gold */
        );
      background-blend-mode: overlay;
      background-size: var(--cardboard-texture-size), 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-family: var(--font-ui);
      font-size: 1.4rem;
      font-weight: 600;
      text-shadow:
        0 1px 2px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: opacity 0.3s ease;
      letter-spacing: 1.5px;
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
      white-space: nowrap;
    }

    body.game-started .wordpack-title {
      opacity: 0.9;
    }

    /* Show wordpack title when menu is visible */
    body.showing-menu .wordpack-title {
      opacity: 0.9;
    }

    /* Card Counter Wrapper - fixed height prevents layout shift when stamp appears */
    .card-counter-wrapper {
      min-height: 2.5rem; /* Accommodate counter + stamp indicator */
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
    }

    /* Card Counter */
    .card-counter {
      color: var(--color-text-light);
      font-size: 1.2rem;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    body.game-started .card-counter {
      opacity: 1;
    }

    /* Show card counter when menu is visible */
    body.showing-menu .card-counter {
      opacity: 1;
    }

    /* Flashcard Container */
    .flashcard-container {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
    }

    /* Navigation Arrows - Flat Cardboard Style */
    .nav-btn {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      font-size: 2rem;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      text-align: center;
      opacity: 0;
      pointer-events: none;
    }

    body.game-started .nav-btn {
      opacity: 1;
      pointer-events: auto;
    }

    /* Show nav buttons when menu is visible (flashcard mode UI) */
    body.showing-menu .nav-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .nav-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .nav-btn:active {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    /* Flashcard */
    .flashcard {
      width: 650px;
      height: 420px;
      position: relative;
      cursor: pointer;
      user-select: none;
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden; /* Clip content to border-radius */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 30px;
      text-align: center;

      /* Old paper texture - using CSS variable for consistency */
      background:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%;

      /* Use box-shadow for border to avoid corner radius gaps */
      box-shadow:
        0 10px 30px rgba(0,0,0,0.4),
        0 0 0 3px #A08567,
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
    }

    .card-face::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 12px;
      pointer-events: none;
    }

    /* Torn edge effect - front card only */
    .card-front::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      border: 1px dashed rgba(139, 115, 85, 0.3);
      border-radius: 4px;
      pointer-events: none;
    }

    /* Subtle grid pattern - back card only */
    .card-back::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px),
        repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px);
      border-radius: 12px;
      pointer-events: none;
      opacity: 0.7;
    }

    /* Random weathering overlay */
    .card-weathering {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 12px;
      pointer-events: none;
      z-index: 4;
      opacity: 0.6;
    }

    .card-front {
      z-index: 2;
    }

    .card-back {
      z-index: 1;
      background:
        var(--paper-texture),
        /* Lighter, whiter back card for distinction */
        radial-gradient(ellipse 70% 60% at 30% 35%, rgba(255, 250, 245, 0.3) 0%, transparent 70%),
        radial-gradient(ellipse 60% 55% at 70% 65%, rgba(250, 245, 240, 0.2) 0%, transparent 65%),
        linear-gradient(135deg, #FFFEF9 0%, #F8F5F0 30%, #F0EDE8 60%, #EAE7E2 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%, 100%, 100%;
    }

    /* Reduce edge weathering on back card for distinction */
    .card-back::before {
      opacity: 0.3;
    }

    .flashcard.flipped .card-front {
      z-index: 1;
      opacity: 0;
    }

    .flashcard.flipped .card-back {
      z-index: 2;
      opacity: 1;
    }

    .card-back {
      opacity: 0;
    }

    .card-label {
      font-family: var(--font-ui);
      font-size: 1.1rem;
      color: #8B7355;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 5;
      white-space: nowrap;
    }

    .card-word {
      font-size: 4rem;
      color: var(--color-text-dark);
      line-height: 1.2;
      font-style: italic;
      position: relative;
      z-index: 5;
      text-align: center;
      max-width: 90%;
      word-break: normal;
      overflow-wrap: break-word;
      hyphens: none;
    }

    /* Chinese font for front card - LXGW WenKai TC Bold (only when in chinese-mode) */
    body.chinese-mode .card-front .card-word {
      font-family: var(--font-chinese);
      font-weight: 700;
      font-style: normal;
    }

    /* Sound Button (pronounce - bottom right) */
    .sound-btn {
      position: absolute;
      bottom: 25px;
      right: 25px;
      background: rgba(139, 115, 85, 0.2);
      border: 3px solid rgba(160, 133, 103, 0.5);
      color: var(--color-text-dark);
      width: 55px;
      height: 55px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      line-height: 1;
      text-align: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }

    .flashcard.game-started .sound-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .sound-btn:hover {
      background: rgba(139, 115, 85, 0.4);
    }

    /* Peek Button (flip/peek at back - top right) - HIDDEN, moved to bottom right */
    .peek-btn {
      display: none !important; /* Hidden - peek button moved to bottom right as action button */
    }

    .peek-btn:hover {
      background: rgba(139, 115, 85, 0.4);
    }

    .peek-btn:active {
      background: rgba(139, 115, 85, 0.6);
    }

    /* Mic Button - HIDDEN, moved to card-controls below card */
    .mic-btn {
      display: none !important; /* Hidden - mic button moved to control bar */
    }

    /* Mic button listening state - applied to control-btn when recording */
    .control-btn.listening {
      background: rgba(180, 60, 60, 0.4) !important;
      border-color: #B43C3C !important;
      animation: pulse-mic 1s infinite;
    }

    @keyframes pulse-mic {
      0%, 100% { box-shadow: 0 0 0 0 rgba(180, 60, 60, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(180, 60, 60, 0); }
    }

    /* Pronunciation Feedback Overlay */
    .pronunciation-feedback {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .pronunciation-feedback.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .feedback-score {
      font-family: var(--font-ui);
      font-size: 3.5rem;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .feedback-score.excellent {
      color: #4ADE80;
    }

    .feedback-score.good {
      color: #A3E635;
    }

    .feedback-score.okay {
      color: #FACC15;
    }

    .feedback-score.poor {
      color: #F87171;
    }

    .feedback-message {
      font-size: 1.3rem;
      color: var(--color-text-light);
      margin-bottom: 8px;
    }

    .feedback-heard {
      font-size: 0.95rem;
      color: var(--color-text-gold);
      font-style: italic;
      margin-bottom: 15px;
    }

    .feedback-close {
      background: rgba(139, 115, 85, 0.4);
      border: 1px solid #8B7355;
      color: var(--color-text-gold);
      padding: 8px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-family: var(--font-ui);
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }

    .feedback-close:hover {
      background: rgba(139, 115, 85, 0.6);
    }

    /* Unsupported browser message */
    .mic-unsupported {
      display: none;
    }

    /* Setup Card - Front (Settings) */
    .setup-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      z-index: 30;
      transition: opacity 0.4s ease;

      /* Match card styling */
      box-shadow:
        0 10px 30px rgba(0,0,0,0.4),
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
      border: 3px solid #A08567;
    }

    .setup-overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 10px;
      pointer-events: none;
    }

    .setup-overlay::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      border: 1px dashed rgba(139, 115, 85, 0.3);
      border-radius: 4px;
      pointer-events: none;
    }

    .setup-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* Setup Card - Back (How To) - Matches card-back styling */
    .setup-help {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        var(--paper-texture),
        /* Lighter, whiter back card for distinction - matches card-back */
        radial-gradient(ellipse 70% 60% at 30% 35%, rgba(255, 250, 245, 0.3) 0%, transparent 70%),
        radial-gradient(ellipse 60% 55% at 70% 65%, rgba(250, 245, 240, 0.2) 0%, transparent 65%),
        linear-gradient(135deg, #FFFEF9 0%, #F8F5F0 30%, #F0EDE8 60%, #EAE7E2 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%, 100%, 100%;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      padding: 30px;
      z-index: 29;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      overflow-y: auto;

      /* Match card styling */
      box-shadow:
        0 10px 30px rgba(0,0,0,0.4),
        0 0 0 3px #A08567,
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
    }

    /* Edge weathering - reduced opacity like card-back */
    .setup-help::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 12px;
      pointer-events: none;
      opacity: 0.3;
    }

    /* Subtle grid pattern - matches card-back */
    .setup-help::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px),
        repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px);
      border-radius: 12px;
      pointer-events: none;
      opacity: 0.7;
    }

    .flashcard.setup-flipped .setup-overlay {
      opacity: 0;
      pointer-events: none;
      z-index: 29;
    }

    .flashcard.setup-flipped .setup-help {
      opacity: 1;
      pointer-events: auto;
      z-index: 30;
    }

    .flashcard.game-started .setup-overlay,
    .flashcard.game-started .setup-help {
      opacity: 0;
      pointer-events: none;
      z-index: -1;
    }

    .setup-title {
      font-family: var(--font-ui);
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--color-text-dark);
      margin-bottom: 25px;
      letter-spacing: 2px;
      position: relative;
      z-index: 5;
    }

    .setup-row {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: flex-start;
      margin-bottom: 15px;
      width: 100%;
      position: relative;
      z-index: 5;
    }

    .setup-field {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 15px;
      width: 100%;
      max-width: 280px;
      position: relative;
      z-index: 5;
    }

    .setup-row .setup-field {
      margin-bottom: 0;
      flex: 1;
    }

    .setup-field label {
      font-family: var(--font-card);
      font-size: 0.95rem;
      color: var(--color-text-dark);
      margin-bottom: 6px;
    }

    .setup-field select {
      font-family: var(--font-card);
      font-size: 1rem;
      padding: 10px 15px;
      border-radius: 6px;
      /* Paper card styling - matches card-face */
      background:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%;
      color: var(--color-text-dark);
      cursor: pointer;
      width: 100%;
      text-align: left;
      text-align-last: left;
      /* Custom dropdown arrow */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%232C1810' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: repeat, no-repeat, no-repeat;
      background-position: 0 0, 0 0, calc(100% - 12px) center;
      background-size: var(--paper-texture-size), 100%, 12px;
      /* Box shadow for border and inner glow like card-face */
      box-shadow:
        0 2px 8px rgba(0,0,0,0.2),
        0 0 0 2px #A08567,
        inset 0 0 20px rgba(139, 115, 85, 0.1);
      border: none;
    }

    .setup-field select:focus {
      outline: none;
      box-shadow:
        0 2px 8px rgba(0,0,0,0.3),
        0 0 0 2px #8B7355,
        inset 0 0 20px rgba(139, 115, 85, 0.15);
    }

    .setup-field select option {
      background: #F5E6D3;
      color: var(--color-text-dark);
      text-align: left;
    }

    /* Setup flip button */
    .setup-flip-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      border: 2px solid rgba(139, 115, 85, 0.5);
      background: rgba(60, 46, 31, 0.6);
      color: var(--color-text-gold);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      z-index: 10;
    }

    .setup-flip-btn:hover {
      background: rgba(139, 115, 85, 0.8);
    }

    /* Help content styling - matches card-back with Courier font */
    .help-content {
      color: var(--color-text-dark);
      line-height: 1.7;
      position: relative;
      z-index: 5;
      font-size: 0.9rem;
      font-family: var(--font-answer);
    }

    .help-content h3 {
      font-family: var(--font-answer);
      font-size: 1rem;
      color: var(--color-text-dark);
      margin: 12px 0 6px;
      font-weight: bold;
    }

    .help-content p {
      margin-bottom: 8px;
    }

    .help-content ul {
      margin-left: 18px;
      margin-bottom: 12px;
    }

    .help-content li {
      margin-bottom: 4px;
    }

    .setup-start-btn {
      font-family: var(--font-ui);
      font-size: 1.1rem;
      font-weight: bold;
      padding: 12px 30px;
      margin-top: 15px;
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      border-radius: 8px;
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 1px;
      position: relative;
      z-index: 5;
    }

    .setup-start-btn:hover:not(:disabled) {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .setup-start-btn:disabled {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: #4A3828;
      color: var(--color-text-dark);
      cursor: not-allowed;
      opacity: 0.45;
    }

    /* Hide card buttons when setup is visible - handled by opacity rules above */

    /* Hide card content when setup is visible (but NOT when showing menu/starting card) */
    .flashcard:not(.game-started):not(.showing-menu) .card-word {
      opacity: 0;
    }

    .flashcard:not(.game-started):not(.showing-menu) .card-label {
      opacity: 0;
    }

    /* Ensure menu card content is always visible */
    .flashcard.showing-menu .card-word {
      opacity: 1 !important;
    }

    /* Speed Controls in Menu */
    .speed-controls-menu {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .speed-btn {
      flex: 1;
      padding: 10px 8px;
      border-radius: 6px;
      border: 3px solid rgba(74, 56, 40, 0.6);
      /* Cardboard texture - inactive state (darker, recessed) */
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: var(--font-ui);
      font-size: 1.2rem;
      text-align: center;
      opacity: 0.6;
    }

    .speed-btn:hover {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      opacity: 0.8;
    }

    .speed-btn.active {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: rgba(74, 56, 40, 0.8);
      opacity: 1;
    }

    /* Speed buttons on starting card (menu) - round like mode buttons */
    .speed-btn-start, .menu-speed-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      /* Inactive: darker, more recessed (like mode-btn) */
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: #4A3828;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.45; /* Very low opacity for inactive to blend into background */
    }

    .speed-btn-start:hover, .menu-speed-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      opacity: 0.7; /* Medium opacity on hover */
    }

    .speed-btn-start.active, .menu-speed-btn.active {
      /* Active: lighter, more prominent (like mode-btn.active) */
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: rgba(74, 56, 40, 0.6);
      box-shadow: none;
      opacity: 1;
    }

    /* ============================================
       CARD CONTROL BAR - Below the flashcard
       ============================================ */
    .card-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px; /* Increased spacing between buttons */
      margin-top: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    body.game-started .card-controls {
      opacity: 1;
      pointer-events: auto;
    }

    body.showing-menu .card-controls {
      opacity: 0;
      pointer-events: none;
    }

    /* Control buttons - cardboard style like nav buttons */
    .control-btn {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      width: 55px;
      height: 55px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      line-height: 1;
      text-align: center;
      position: relative;
    }

    .control-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .control-btn:active {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    /* Control button tooltips now use .btn-tooltip elements (see BUTTON TOOLTIPS section below) */
    /* This allows HTML content with styled buttons/keys */

    /* Separator between button groups */
    .control-separator {
      width: 2px;
      height: 35px;
      background: rgba(139, 115, 85, 0.4);
      border-radius: 1px;
      margin: 0 5px;
    }

    /* Top Corner Buttons - Flat Cardboard Style (in page header) */
    .top-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      line-height: 1;
      text-align: center;
      font-family: var(--font-ui);
      font-weight: 600;
    }

    .top-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .top-btn:active {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .reset-top-btn {
      opacity: 0;
      pointer-events: none;
    }

    body.game-started .reset-top-btn {
      opacity: 1;
      pointer-events: auto;
    }

    /* Show reset button when menu is visible */
    body.showing-menu .reset-top-btn {
      opacity: 1;
      pointer-events: auto;
    }

    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* Modal Card */
    .modal-card {
      width: 90%;
      max-width: 450px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 12px;
      padding: 30px;
      position: relative;
      background: 
        url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.5' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      box-shadow: 
        0 10px 30px rgba(0,0,0,0.5),
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
      border: 3px solid #A08567;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 10px;
      pointer-events: none;
    }

    .modal-card::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      border: 1px dashed rgba(139, 115, 85, 0.3);
      border-radius: 4px;
      pointer-events: none;
    }

    .modal-overlay.visible .modal-card {
      transform: scale(1);
    }

    .modal-title {
      font-family: var(--font-ui);
      font-size: 1.5rem;
      color: var(--color-text-dark);
      margin-bottom: 20px;
      text-align: center;
      letter-spacing: 2px;
      position: relative;
      z-index: 5;
    }

    .modal-content {
      color: var(--color-text-dark);
      line-height: 1.7;
      position: relative;
      z-index: 5;
    }

    .modal-content h3 {
      font-family: var(--font-ui);
      font-size: 1.1rem;
      color: var(--color-text-dark);
      margin: 15px 0 8px;
    }

    .modal-content p {
      margin-bottom: 10px;
    }

    .modal-content ul {
      margin-left: 20px;
      margin-bottom: 15px;
    }

    .modal-content li {
      margin-bottom: 5px;
    }

    .modal-close-btn {
      display: block;
      margin: 20px auto 0;
      padding: 10px 25px;
      font-family: var(--font-ui);
      font-size: 1rem;
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      border-radius: 6px;
      color: var(--color-text-light);
      cursor: pointer;
      transition: all 0.2s ease;
      text-shadow: 0 1px 2px rgba(0,0,0,0.4);
      position: relative;
      z-index: 5;
    }

    .modal-close-btn:hover {
      background-color: #8A7357;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #9B8365 0%, #8A7357 30%, #7B6550 60%, #6D5E47 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    /* Menu Modal Specific */
    .menu-field {
      margin-bottom: 18px;
    }

    .menu-field label {
      display: block;
      font-family: var(--font-card);
      font-size: 0.95rem;
      color: var(--color-text-dark);
      margin-bottom: 6px;
    }

    .menu-field select {
      font-family: var(--font-card);
      font-size: 1rem;
      padding: 10px 15px;
      border-radius: 6px;
      /* Cardstock ivory with dot texture and dark edge burn */
      background-color: #f8f6f1;
      color: #5d4e37;
      cursor: pointer;
      width: 100%;
      /* Custom dropdown arrow */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image:
        /* Dark edge burn/vignette */
        radial-gradient(ellipse at center, transparent 50%, rgba(139, 115, 85, 0.08) 80%, rgba(100, 75, 50, 0.15) 100%),
        /* Fine dot pattern */
        radial-gradient(circle, rgba(0,0,0,0.045) 0.5px, transparent 0.5px),
        /* Dropdown arrow */
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%235d4e37' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat, repeat, no-repeat;
      background-position: 0 0, 0 0, calc(100% - 12px) center;
      background-size: 100%, 4px 4px, 12px;
      /* Border matching card style with subtle inner shadow */
      box-shadow:
        0 2px 8px rgba(0,0,0,0.15),
        0 0 0 2px #A08567,
        inset 0 0 15px rgba(100, 75, 50, 0.08);
      border: none;
    }

    .menu-field select:hover {
      box-shadow:
        0 2px 8px rgba(0,0,0,0.2),
        0 0 0 2px #8B7355,
        inset 0 0 18px rgba(100, 75, 50, 0.1);
    }

    .menu-field select:focus {
      outline: none;
      box-shadow:
        0 2px 8px rgba(0,0,0,0.25),
        0 0 0 2px #8B7355,
        inset 0 0 20px rgba(100, 75, 50, 0.12);
    }

    .menu-field select option {
      background: #f8f6f1;
      color: #5d4e37;
      padding: 8px;
    }

    /* Empty State */
    .empty-state {
      color: var(--color-text-light);
      font-size: 1.3rem;
      text-align: center;
      padding: 50px;
    }

    /* Loading State */
    .loading {
      color: var(--color-text-light);
      font-size: 1.2rem;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Shared stamp styling - used by card stamps and deck change indicator */
    .stamp-base {
      font-family: 'Courier New', Courier, monospace; /* Typewriter/stamp font */
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
      border: 3px solid;
      border-radius: 8px; /* More rounded corners */
      mix-blend-mode: multiply; /* Blends ink into content beneath */
      text-align: center;
      line-height: 1.3;
    }

    /* Simple stamp overlays - realistic rubber stamp effect */
    .card-stamp {
      position: absolute;
      top: 28%; /* Higher on card - top half, shows off the effect */
      left: 50%;
      transform: translate(-50%, -50%) rotate(-12deg);
      font-size: 1.6rem; /* Bigger to show off the cool effect */
      padding: 14px 28px;
      opacity: 0;
      pointer-events: none;
      z-index: 100;
      transition: opacity 0.2s ease;
      /* Uneven border like a real rubber stamp */
      border-width: 3px 4px 3px 3px;
      border-style: solid;
    }

    .removed-stamp {
      color: transparent;
      border-color: rgba(56, 142, 60, 0.85);
      -webkit-text-stroke: 1.5px rgba(56, 142, 60, 0.85);
      text-stroke: 1.5px rgba(56, 142, 60, 0.85);
      /* No background - transparent like real stamp */
    }

    .added-stamp {
      color: transparent;
      border-color: rgba(211, 47, 47, 0.85);
      -webkit-text-stroke: 1.5px rgba(211, 47, 47, 0.85);
      text-stroke: 1.5px rgba(211, 47, 47, 0.85);
      /* No background - transparent like real stamp */
    }

    .card-stamp.visible {
      opacity: 1;
    }

    /* Mode Selector - in page header */
    .mode-selector {
      display: flex;
      gap: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    body.game-started .mode-selector {
      opacity: 1;
      pointer-events: auto;
    }

    /* Show mode selector when menu is visible */
    body.showing-menu .mode-selector {
      opacity: 1;
      pointer-events: auto;
    }

    .mode-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      /* Inactive: darker, more recessed (old active style) */
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: #4A3828;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      line-height: 1;
      opacity: 0.45; /* Very low opacity for inactive to blend into background */
    }

    .mode-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      /* No scale transform - buttons should not grow on hover */
      opacity: 0.7; /* Medium opacity on hover */
    }

    .mode-btn.active {
      /* Active: lighter, more prominent (old default style) */
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      box-shadow: none; /* No inset shadow - more prominent */
      opacity: 1; /* Full opacity for active */
    }

    /* Typing mode display (listening and writing) */
    .typing-display {
      font-size: 4rem;
      color: var(--color-text-dark);
      font-family: var(--font-card);
      font-style: italic;
      letter-spacing: 4px;
      position: relative;
      z-index: 5;
      text-align: center;
      word-spacing: 20px;
      word-break: keep-all;
      white-space: normal;
      overflow-wrap: break-word;
    }

    .typing-char {
      display: inline-block;
      min-width: 0.6em;
      text-align: center;
      transition: color 0.2s ease;
    }

    .typing-char.wrong {
      color: #D32F2F;
    }

    .typing-space {
      display: inline-block;
      width: 0.8em;
    }

    /* Translation text (native language) */
    .translation-text {
      font-size: 3rem;
      color: var(--color-text-dark);
      font-family: var(--font-answer);
      font-style: normal;
    }

    /* =============================================== */
    /* CUSTOM TOOLTIPS - Hover Explanations */
    /* =============================================== */

    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    .tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      z-index: 300;
      /* Fine fancy paper with subtle dot pattern */
      background-color: #f8f6f1;
      background-image:
        /* Subtle edge burn/vignette - reduced for smaller card */
        radial-gradient(ellipse at center, transparent 60%, rgba(139, 115, 85, 0.06) 90%, rgba(100, 75, 50, 0.1) 100%),
        /* Fine dot pattern for fancy paper texture - slightly sharper */
        radial-gradient(circle, rgba(0,0,0,0.045) 0.5px, transparent 0.5px);
      background-size: 100% 100%, 4px 4px;
      color: var(--color-text-dark);
      padding: 10px 14px;
      border-radius: 8px;
      overflow: hidden;
      /* Border and shadow matching card-face style */
      box-shadow:
        0 4px 16px rgba(0,0,0,0.3),
        0 0 0 3px #A08567,
        inset 0 0 12px rgba(139, 115, 85, 0.06),
        inset 0 0 25px rgba(100, 75, 50, 0.03);
      font-size: 1rem;
      line-height: 1.4;
      white-space: nowrap;
      pointer-events: none;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      font-family: var(--font-answer);
    }

    /* Position tooltip below mode buttons */
    .mode-btn .tooltip {
      top: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
    }

    /* Position tooltip above flashcard */
    .flashcard .tooltip {
      bottom: calc(100% + 15px);
      left: 50%;
      transform: translateX(-50%);
      max-width: 400px;
      white-space: normal;
      text-align: center;
    }

    /* Show tooltip on hover */
    .tooltip-container:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    /* Arrow removed - using simple div style instead of speech bubble */

    .tooltip strong {
      /* Mode title - centered, LARGER, bold */
      display: block;
      text-align: center;
      color: var(--color-text-dark);
      font-weight: bold;
      font-size: 1.3rem;
      margin-bottom: 2px;
      position: relative;
      z-index: 2;
      font-family: var(--font-answer);
    }

    /* Bold steps - numbered list in tooltips */
    .tooltip b {
      color: var(--color-text-dark);
      font-weight: bold;
      position: relative;
      z-index: 2;
      display: inline;
      font-size: 1rem;
      line-height: 1.8;
      font-family: var(--font-answer);
    }

    .tooltip em {
      /* Instructions text - SAME COLOR as everything else */
      color: var(--color-text-dark);
      font-style: normal;
      position: relative;
      z-index: 2;
      display: block;
      margin-top: 2px;
      font-size: 0.9rem;
      line-height: 1.5;
      font-family: var(--font-answer);
    }

    /* Bold action words within em (CLICK, PRESS, HOLD, TYPE) */
    .tooltip em b {
      color: var(--color-text-dark);
      font-weight: bold;
      text-transform: uppercase;
      font-family: var(--font-answer);
    }

    /* Make all tooltip content appear above grid */
    .tooltip > * {
      position: relative;
      z-index: 2;
    }

    /* Visual button representations in tooltips */
    .tooltip-btn {
      display: inline-block;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 2px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      font-size: 0.75rem;
      line-height: 20px;
      text-align: center;
      vertical-align: middle;
      margin: 0 2px;
    }

    .tooltip-key {
      display: inline-block;
      min-width: 28px;
      padding: 2px 6px;
      border-radius: 4px;
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 2px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      font-size: 0.7rem;
      font-weight: bold;
      line-height: 1.2;
      text-align: center;
      vertical-align: middle;
      margin: 0 2px;
      font-family: var(--font-ui);
    }

    /* Tooltip instructions container - minimal gap from title */
    .tooltip-instructions {
      margin-top: 4px;
      font-size: 0.9rem;
      line-height: 1.6;
      text-align: left;
    }

    /* =============================================== */
    /* BUTTON TOOLTIPS - HTML-enabled hover tooltips */
    /* =============================================== */
    /* These are actual DOM elements (not ::after pseudo) so they can render HTML */

    .btn-tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      /* Fancy paper with subtle fiber/dot pattern */
      background:
        /* Fine noise texture for paper feel */
        url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E"),
        /* Subtle vignette for depth */
        radial-gradient(ellipse at center, transparent 40%, rgba(139, 115, 85, 0.06) 100%),
        /* Soft cream parchment gradient */
        linear-gradient(145deg, #FDF8F0 0%, #F5EDE0 25%, #EDE4D3 50%, #E8DCC8 75%, #E0D4BE 100%);
      background-size: 150px 150px, 100% 100%, 100% 100%;
      color: var(--color-text-dark);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow:
        0 4px 16px rgba(0,0,0,0.25),
        0 0 0 1px rgba(139, 115, 85, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.5),
        inset 0 -1px 0 rgba(139, 115, 85, 0.1);
      font-size: 0.85rem;
      white-space: nowrap;
      pointer-events: none;
      /* 1 second delay before showing */
      transition: opacity 0.2s ease 0s, visibility 0.2s ease 0s;
      font-family: var(--font-answer);
      font-weight: normal;
      z-index: 100;
    }

    .control-btn:hover .btn-tooltip {
      visibility: visible;
      opacity: 1;
      /* 1 second delay - user must hold hover to see tooltip */
      transition-delay: 1s;
    }

    /* Arrow removed - using simple div style instead of speech bubble */

    /* =================================================================
       CHINESE DISPLAY OPTIONS - Character + Pinyin Coupling
       Design: Yellow/gold warning-style box to draw attention
       Shows only when native language is Chinese
       ================================================================= */
    .chinese-display-options {
      display: none;  /* Hidden by default, shown via JS when nativeLanguage is chinese */
      margin: 10px 0;
      padding: 10px 15px;
      background: rgba(255, 243, 205, 0.9);
      border: 1px solid #ffc107;
      border-radius: 5px;
      color: var(--color-text-dark);
      font-family: var(--font-ui);
      font-size: 0.9rem;
    }

    .chinese-display-options strong {
      color: var(--color-text-dark);
      margin-right: 10px;
    }

    .chinese-display-options label {
      margin-left: 15px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .chinese-display-options input[type="checkbox"] {
      cursor: pointer;
    }

    /* =================================================================
       CHINESE CHARACTER + PINYIN COUPLED DISPLAY
       Core Objective: Render each Chinese character with its pinyin directly below

       Structure:
         .chinese-coupled (flex container, horizontal)
            .char-group (flex column for each character)
                .chinese-char (the character)
                .pinyin (pinyin syllable)

       This ensures char/pinyin are NEVER separated during display
       ================================================================= */
    .chinese-coupled {
      display: inline-flex;
      gap: 4px;
      align-items: flex-end;
      justify-content: center;
      flex-wrap: wrap;
    }

    .char-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .chinese-char {
      font-size: 1em;
      line-height: 1.2;
    }

    .pinyin {
      font-size: 0.6em;
      color: #666;
      line-height: 1;
      font-family: var(--font-answer);
    }

    /* Adjust for card display - larger characters */
    .card-word .chinese-coupled .chinese-char {
      font-size: 1em;
    }

    .card-word .chinese-coupled .pinyin {
      font-size: 0.4em;
      color: #8B7355;
    }
  </style>
</head>
<body>
  <!-- Fixed Page Header: Mode selector (left) + Title (center) + UI buttons (right) -->
  <div class="page-header">
    <!-- Mode Selector -->
    <!-- Tooltips are populated dynamically via initializeTooltips() using TOOLTIP_MESSAGES -->
    <div class="mode-selector">
      <span class="tooltip-container">
        <button class="mode-btn active" id="mode-flashcard" data-mode="flashcard"></button>
        <span class="tooltip" id="tooltip-reading"></span>
      </span>
      <span class="tooltip-container">
        <button class="mode-btn" id="mode-spelling" data-mode="spelling"></button>
        <span class="tooltip" id="tooltip-listening"></span>
      </span>
      <span class="tooltip-container">
        <button class="mode-btn" id="mode-pronunciation" data-mode="pronunciation"></button>
        <span class="tooltip" id="tooltip-speaking"></span>
      </span>
      <span class="tooltip-container">
        <button class="mode-btn" id="mode-translation" data-mode="translation"></button>
        <span class="tooltip" id="tooltip-writing"></span>
      </span>
    </div>

    <!-- Title - centered, subtle -->
    <div class="wordpack-title" id="wordpack-title">Flashcard Typing Game</div>

    <!-- Top Buttons -->
    <div class="header-buttons">
      <button class="top-btn reset-top-btn" id="reset-btn" aria-label="Reset deck"></button>
      <button class="top-btn fullscreen-btn" id="fullscreen-btn" aria-label="Toggle fullscreen"></button>
      <button class="top-btn menu-btn" id="menu-btn" aria-label="Menu"></button>
    </div>
  </div>

  <!-- Fixed-height wrapper prevents card from shifting when stamp indicator appears -->
  <div class="card-counter-wrapper">
    <div class="card-counter" id="card-counter">Choose Wordpack to Begin Studying</div>
  </div>

  <!-- =================================================================
       CHINESE DISPLAY OPTIONS
       Shows only when nativeLanguage is 'chinese'
       Controls whether to show characters, pinyin, or both
       ================================================================= -->
  <div class="chinese-display-options" id="chineseDisplayOptions">
    <strong>Chinese Display:</strong>
    <label>
      <input type="checkbox" id="showChineseChars" checked>
      Show Characters ()
    </label>
    <label>
      <input type="checkbox" id="showPinyin" checked>
      Show Pinyin (pnyn)
    </label>
  </div>

  <div class="flashcard-container">
    <button class="nav-btn" id="prev-btn" aria-label="Previous card"></button>

    <div class="flashcard" id="flashcard">
      <div class="card-face card-front">
        <div class="card-weathering" id="weathering-front"></div>
        <!-- Wrong answer indicators (positioned at card corners) -->
        <div id="wrong-letters-front" style="position: absolute; top: 12px; left: 12px; font-size: 2em; font-family: var(--font-card); font-style: italic; font-weight: bold; color: #D32F2F; z-index: 20; max-width: 550px; line-height: 0.9; text-align: left;"></div>
        <div id="wrong-count-front" style="position: absolute; top: 12px; right: 12px; font-size: 2em; font-family: var(--font-card); font-style: italic; font-weight: bold; color: #D32F2F; z-index: 20;"></div>
        <span class="card-word" id="spanish-word"></span>
        <button class="mic-btn" id="mic-btn-front" aria-label="Practice pronunciation" data-tooltip="Record Pronunciation"></button>
        <button class="peek-btn" id="peek-btn-front" aria-label="Peek at back"></button>
        <div class="pronunciation-feedback" id="feedback-front">
          <div class="feedback-score" id="score-front">0%</div>
          <div class="feedback-message" id="message-front">Try again!</div>
          <div class="feedback-heard" id="heard-front">Heard: ""</div>
          <button class="feedback-close" id="close-front">Got it</button>
        </div>
      </div>
      <div class="card-face card-back">
        <div class="card-weathering" id="weathering-back"></div>
        <span class="card-word" id="english-word"></span>
        <button class="mic-btn" id="mic-btn-back" aria-label="Practice pronunciation" data-tooltip="Record Pronunciation"></button>
        <div class="pronunciation-feedback" id="feedback-back">
          <div class="feedback-score" id="score-back">0%</div>
          <div class="feedback-message" id="message-back">Try again!</div>
          <div class="feedback-heard" id="heard-back">Heard: ""</div>
          <button class="feedback-close" id="close-back">Got it</button>
        </div>
      </div>

      <!-- Stamp overlays for visual feedback -->
      <div class="stamp-base card-stamp removed-stamp" id="removed-stamp">Great Job!<br>Card Removed</div>
      <div class="stamp-base card-stamp added-stamp" id="added-stamp">Keep Learning!<br>Practice Added</div>
    </div>

    <button class="nav-btn" id="next-btn" aria-label="Next card"></button>
  </div>

  <!-- Card Controls - Below the flashcard -->
  <div class="card-controls" id="card-controls">
    <!-- Left group: Got It / Don't Got It (flashcard mode only) -->
    <button class="control-btn" id="got-it-btn" data-tooltip=""></button>
    <button class="control-btn" id="confused-btn" data-tooltip=""></button>
    <!-- Mic button (pronunciation mode only) - before separator so divider shows in pronunciation mode -->
    <button class="control-btn" id="mic-btn-control" data-tooltip="" style="display: none;"></button>
    <div class="control-separator" id="control-separator"></div>
    <!-- Right group: Pronounce / Peek (all modes) -->
    <button class="control-btn" id="pronounce-btn" data-tooltip=""></button>
    <button class="control-btn" id="peek-btn" data-tooltip=""></button>
  </div>

  <script type="module">
    // ============================================================
    // KEY FEATURE: Multi-language obfuscated module support
    // Core Objective: Load compressed word data efficiently with act-based organization
    // Key Behaviors:
    //   - Decoder function handles 3-layer deobfuscation (base64 + zlib + reversal)
    //   - Module configuration supports all languages (Chinese, Spanish, English)
    //   - Currently only Spanish acts are loaded
    //   - Future: Can easily add other languages by uncommenting module URLs
    // ============================================================

    // Decoder function for obfuscated modules (same as DecoderTest.html)
    async function decodeObfuscatedModule(url) {
      try {
        // 1. Import the obfuscated module (contains base64 string in 'w' export)
        const module = await import(url);
        const compressedB64 = module.w;

        // 2. Decode base64 to binary
        const compressedBinary = Uint8Array.from(atob(compressedB64), c => c.charCodeAt(0));

        // 3. Decompress with pako (zlib)
        const decompressedBinary = pako.inflate(compressedBinary);

        // 4. Convert binary to string
        const reversedJson = new TextDecoder('utf-8').decode(decompressedBinary);

        // 5. Reverse the string (undo the salt)
        const jsonStr = reversedJson.split('').reverse().join('');

        // 6. Parse JSON to get the original data
        const data = JSON.parse(jsonStr);

        return data;  // Returns object with all packs: { p1_1_name: {meta, words}, ... }
      } catch (error) {
        console.error('Failed to decode module:', error);
        throw error;
      }
    }

    // ============================================================
    // MODULE URLS - Configure these for the language you want to learn
    // ============================================================
    // IMPORTANT: ALL modules MUST have the SAME wordColumns[0] value!
    // The game detects the target language from wordColumns[0] in __actMeta.
    // If modules don't agree on the target language, the game won't load.
    //
    // Examples:
    // - Spanish: '../SpanishWords/Jsmodules-js/act1-foundation-js.js' (wordColumns[0] = "spanish")
    // - Chinese: '../ChineseWords/Jsmodules-js/act1-foundation-js.js' (wordColumns[0] = "chinese")
    // - English: '../EnglishWords/Jsmodules-js/act1-foundation-js.js' (wordColumns[0] = "english")
    // ============================================================
    const MODULE_URLS = [
      // CONFIGURE YOUR MODULES HERE - all must have matching wordColumns[0]
      // Spanish modules:
      '../SpanishWords/Jsmodules-js/act1-foundation-js.js',
      '../SpanishWords/Jsmodules-js/act2-building-blocks-js.js',
      '../SpanishWords/Jsmodules-js/act3-daily-life-js.js',
      '../SpanishWords/Jsmodules-js/act4-expanding-expression-js.js',
      '../SpanishWords/Jsmodules-js/act5-intermediate-mastery-js.js',
      '../SpanishWords/Jsmodules-js/act6-advanced-constructs-js.js',
      '../SpanishWords/Jsmodules-js/act7-mastery-fluency-js.js'
      // Chinese modules (uncomment to use):
      // '../ChineseWords/Jsmodules-js/act1-foundation-js.js',
      // '../ChineseWords/Jsmodules-js/act2-development-js.js',
      // '../ChineseWords/Jsmodules-js/act3-expansion-js.js',
      // '../ChineseWords/Jsmodules-js/act4-mastery-js.js',
      // '../ChineseWords/Jsmodules-js/act5-refinement-js.js'
      // English modules (uncomment to use):
      // '../EnglishWords/Jsmodules-js/act1-foundation-js.js',
      // '../EnglishWords/Jsmodules-js/act2-building-blocks-js.js',
      // '../EnglishWords/Jsmodules-js/act3-everyday-life-js.js',
      // '../EnglishWords/Jsmodules-js/act4-expanding-horizons-js.js',
      // '../EnglishWords/Jsmodules-js/act5-advanced-mastery-js.js'
    ];

    let wordpacks = {}; // All loaded wordpacks
    let loadedActs = {}; // Track which acts have been loaded
    let loadedActMeta = {}; // Store __actMeta from each loaded act

    // ============================================================
    // TARGET LANGUAGE - Detected from loaded modules' wordColumns[0]
    // ============================================================
    let targetLanguage = null; // Will be set to 'spanish', 'chinese', 'english', etc.
    let targetLanguageDisplay = null; // Title case version for UI: 'Spanish', 'Chinese', 'English'

    // Helper to get the target language from loaded modules
    function getTargetLanguage() {
      for (const actNum of Object.keys(loadedActMeta)) {
        const meta = loadedActMeta[actNum];
        if (meta && meta.wordColumns && meta.wordColumns[0]) {
          return meta.wordColumns[0].toLowerCase();
        }
      }
      return null;
    }

    // Helper to get title case version of target language
    function toTitleCase(str) {
      if (!str) return '';
      return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }

    // Validate that all loaded modules have the same target language
    function validateTargetLanguageConsistency() {
      const languages = new Set();
      for (const actNum of Object.keys(loadedActMeta)) {
        const meta = loadedActMeta[actNum];
        if (meta && meta.wordColumns && meta.wordColumns[0]) {
          languages.add(meta.wordColumns[0].toLowerCase());
        }
      }
      if (languages.size > 1) {
        const langList = Array.from(languages).join(', ');
        console.error(`[FATAL] Modules have inconsistent target languages: ${langList}`);
        console.error('All modules must have the same wordColumns[0] value!');
        return false;
      }
      return true;
    }

    // Check if the target language is Chinese (requires special handling)
    function isChineseMode() {
      return targetLanguage === 'chinese';
    }

    // Apply or remove Chinese mode CSS class
    function updateChineseModeClass() {
      if (isChineseMode()) {
        document.body.classList.add('chinese-mode');
      } else {
        document.body.classList.remove('chinese-mode');
      }
    }

    // Helper to get translations config from first loaded act's __actMeta
    function getTranslationsConfig() {
      // Find first loaded act that has __actMeta
      for (const actNum of Object.keys(loadedActMeta)) {
        const meta = loadedActMeta[actNum];
        if (meta && meta.translations) {
          return meta.translations;
        }
      }
      return null; // No modules loaded yet
    }

    // Helper to get default translation from loaded metadata
    function getDefaultTranslation() {
      for (const actNum of Object.keys(loadedActMeta)) {
        const meta = loadedActMeta[actNum];
        if (meta && meta.defaultTranslation) {
          return meta.defaultTranslation;
        }
      }
      return 'english'; // Fallback
    }

    // Helper to get word columns from loaded metadata
    function getWordColumns() {
      for (const actNum of Object.keys(loadedActMeta)) {
        const meta = loadedActMeta[actNum];
        if (meta && meta.wordColumns) {
          return meta.wordColumns;
        }
      }
      return null;
    }

    let currentDeck = [];
    let originalDeck = [];
    let currentIndex = 0;
    let isFlipped = false;
    let holdTimeout = null;
    let currentSpeed = 0.6; // Default to normal speed
    const VALID_SPEEDS = [0.3, 0.6, 0.9]; // Valid speed options (must match data-speed values in HTML)

    // ============================================================
    // DEBUG MODE: Show word type (Base Word / Example Word)
    // ============================================================
    const DEBUG_SHOW_WORD_TYPE = true; // Set to true to display word type on cards

    // Helper to get valid languages from loaded metadata (for validation)
    function getValidLanguages() {
      const translations = getTranslationsConfig();
      return translations ? Object.keys(translations) : [];
    }

    // Helper to get TTS language code from loaded module metadata
    // Derives from wordColumns[0] - the primary language of the deck
    function getTtsLanguageCode() {
      for (const actNum of Object.keys(loadedActMeta)) {
        const meta = loadedActMeta[actNum];
        if (meta && meta.wordColumns && meta.wordColumns[0]) {
          const primaryLang = meta.wordColumns[0].toLowerCase();
          // Map language names to TTS language codes (full locale for better voice matching)
          const langMap = {
            'spanish': 'es-ES',
            'chinese': 'zh-CN',
            'english': 'en-US',
            'portuguese': 'pt-BR',
            'french': 'fr-FR',
            'vietnamese': 'vi-VN',
            'thai': 'th-TH',
            'indonesian': 'id-ID',
            'malay': 'ms-MY',
            'filipino': 'fil-PH'
          };
          return langMap[primaryLang] || null;
        }
      }
      return null; // No modules loaded yet
    }

    // ===================================================================================
    // CHINESE CHARACTER + PINYIN COUPLING SYSTEM
    // Core Objective: Keep Chinese characters and their pinyin syllables coupled
    //
    // Anti-Decoupling Principle: Chinese characters and pinyin MUST stay together
    // Example: "" (xio mo)  [{char:"", pinyin:"xio"}, {char:"", pinyin:"mo"}]
    //
    // This ensures when rendering Chinese, we can ALWAYS show:
    //             (characters on top)
    //  xio  mo     (pinyin below each character)
    //
    // Functions:
    //   - coupleChineseWithPinyin(chinese, pinyin)  array of {char, pinyin}
    //   - renderChineseWithPinyin(coupledArray)  HTML element with coupled display
    //   - renderChineseText(chinese, pinyin)  convenience function combining both
    // ===================================================================================

    /**
     * Couples each Chinese character with its corresponding pinyin syllable
     * @param {string} chineseStr - Chinese characters (e.g., "")
     * @param {string} pinyinStr - Space-separated pinyin syllables (e.g., "xio mo")
     * @returns {Array<{char: string, pinyin: string}>} - Array of coupled char/pinyin objects
     *
     * Example: coupleChineseWithPinyin("", "xio mo")
     *    [{char: "", pinyin: "xio"}, {char: "", pinyin: "mo"}]
     */
    function coupleChineseWithPinyin(chineseStr, pinyinStr) {
      // Handle empty/null inputs gracefully
      if (!chineseStr) return [];
      if (!pinyinStr) {
        // No pinyin available - return chars with empty pinyin
        return [...chineseStr].map(char => ({ char, pinyin: '' }));
      }

      // 
      // CHARACTER-BY-CHARACTER MAPPING (Simplified)
      // 
      // Example: ""  "zo shng ho xin shng"
      //     zo
      //     shng
      //     ho
      //     
      //     xin
      //     shng
      //
      // Edge cases (Latin in Chinese): "ATM"  "ATM j"
      //   A  A
      //   T  T
      //   M  M
      //     j
      // 

      // Split pinyin by spaces
      const pinyinTokens = pinyinStr.trim().split(/\s+/);
      const result = [];
      let tokenIndex = 0;
      let latinLetterIndex = 0; // For consuming Latin tokens letter-by-letter

      for (const char of chineseStr) {
        if (tokenIndex >= pinyinTokens.length) {
          // Ran out of pinyin tokens - mark as mismatch
          result.push({ char, pinyin: '?' });
          continue;
        }

        const currentToken = pinyinTokens[tokenIndex];
        // Strip Chinese punctuation to get clean syllable/word
        const cleanToken = currentToken.replace(/[""'']/g, '');

        if (/[\u4e00-\u9fff]/.test(char)) {
          // 
          // CHINESE CHARACTER  consume one token
          // 
          result.push({ char, pinyin: cleanToken || '?' });
          tokenIndex++;
          latinLetterIndex = 0;
        } else if (/[A-Za-z]/.test(char)) {
          // 
          // LATIN LETTER  handle edge cases (ATM, DNA, WhatsApp, etc.)
          // 
          if (/^[A-Za-z]+$/.test(cleanToken)) {
            // Current token is all-Latin (like "ATM", "DNA", "WhatsApp")
            // Consume letter-by-letter: AA, TT, MM
            const letter = cleanToken[latinLetterIndex] || char;
            result.push({ char, pinyin: letter });
            latinLetterIndex++;

            if (latinLetterIndex >= cleanToken.length) {
              // Finished consuming this Latin token
              tokenIndex++;
              latinLetterIndex = 0;
            }
          } else {
            // Token is not pure Latin  just map letter to itself
            result.push({ char, pinyin: char });
          }
        } else {
          // 
          // PUNCTUATION  maps to itself
          // 
          result.push({ char, pinyin: char });
        }
      }

      return result;
    }

    /**
     * Renders a coupled Chinese array as an HTML element with char on top, pinyin below
     * Respects showChineseChars and showPinyin global settings
     * @param {Array<{char: string, pinyin: string}>} coupledArray - From coupleChineseWithPinyin()
     * @returns {HTMLElement} - Span element with flex-column groups for each character
     */
    function renderChineseWithPinyin(coupledArray) {
      // If neither chars nor pinyin should be shown, return empty span
      if (!showChineseChars && !showPinyin) {
        const empty = document.createElement('span');
        empty.textContent = '(hidden)';
        empty.style.cssText = 'color: #999; font-style: italic;';
        return empty;
      }

      const container = document.createElement('span');
      container.className = 'chinese-coupled';

      coupledArray.forEach(({ char, pinyin }) => {
        const charGroup = document.createElement('span');
        charGroup.className = 'char-group';

        // Chinese character (on top)
        if (showChineseChars) {
          const charSpan = document.createElement('span');
          charSpan.className = 'chinese-char';
          charSpan.textContent = char;
          charGroup.appendChild(charSpan);
        }

        // Pinyin (below)
        if (showPinyin) {
          const pinyinSpan = document.createElement('span');
          pinyinSpan.className = 'pinyin';
          pinyinSpan.textContent = pinyin;
          charGroup.appendChild(pinyinSpan);
        }

        container.appendChild(charGroup);
      });

      return container;
    }

    /**
     * Convenience function: Couples and renders Chinese text in one call
     * @param {string} chinese - Chinese characters
     * @param {string} pinyin - Space-separated pinyin
     * @returns {HTMLElement} - Ready-to-append HTML element
     */
    function renderChineseText(chinese, pinyin) {
      const coupled = coupleChineseWithPinyin(chinese, pinyin);
      return renderChineseWithPinyin(coupled);
    }

    /**
     * Returns HTML string for Chinese text (useful for innerHTML assignments)
     * @param {string} chinese - Chinese characters
     * @param {string} pinyin - Space-separated pinyin
     * @returns {string} - HTML string
     */
    function getChineseHtml(chinese, pinyin) {
      const element = renderChineseText(chinese, pinyin);
      return element.outerHTML;
    }

    /**
     * Updates visibility of Chinese display options based on current language
     * Called when language changes or on page load
     */
    function updateChineseOptionsVisibility() {
      const optionsDiv = document.getElementById('chineseDisplayOptions');
      if (optionsDiv) {
        // Show only when learning with Chinese translations
        optionsDiv.style.display = (nativeLanguage === 'chinese') ? 'block' : 'none';
      }
    }

    /**
     * Sets up event listeners for Chinese display option checkboxes
     */
    function setupChineseDisplayOptions() {
      const showCharsCheckbox = document.getElementById('showChineseChars');
      const showPinyinCheckbox = document.getElementById('showPinyin');

      if (showCharsCheckbox) {
        showCharsCheckbox.addEventListener('change', () => {
          showChineseChars = showCharsCheckbox.checked;
          saveState();
          updateDisplay();
        });
      }

      if (showPinyinCheckbox) {
        showPinyinCheckbox.addEventListener('change', () => {
          showPinyin = showPinyinCheckbox.checked;
          saveState();
          updateDisplay();
        });
      }
    }

    let nativeLanguage = 'english'; // Default, will be updated from loaded module metadata
    let gameStarted = false;
    let currentWordpackKey = '';
    let currentVoice = null;
    let savedVoiceURI = null; // Store saved voice URI until voices are loaded
    let spanishVoices = [];
    let currentAct = 1; // Track currently selected act

    // Learning modes
    let currentMode = 'flashcard'; // 'flashcard', 'spelling', 'pronunciation', 'translation'
    let typingInput = ''; // User's current typing input for typing modes
    let typingDisplay = []; // Array of actual characters (always contains real word, not underscores)
    let typedPositions = new Set(); // Track which positions have been successfully typed
    let wrongAttempts = 0; // Track wrong keypresses in typing modes
    let wrongPositions = []; // Track which positions had wrong attempts (for red underlines)
    let wrongLetters = []; // Track actual letters that were typed wrong (for crossed-out display)

    // Deck change tracking (for visual indicator next to counter)
    let pendingDeckChange = 0; // +N for added cards, -N for removed cards

    // Starting card state (menu/help card)
    let isOnStartingCard = false;
    let savedIndex = 0; // Save current index when navigating to starting card

    // Track key states to prevent repeated actions when holding keys
    let keysPressed = {};

    // ===================================================================================
    // CHINESE DISPLAY OPTIONS (Global state)
    // Controls how Chinese translations are rendered (character + pinyin coupling)
    // These settings affect ALL Chinese text display across the app
    // ===================================================================================
    let showChineseChars = true;  // Show Chinese characters () - default ON
    let showPinyin = true;        // Show pinyin under each character - default ON

    // ===================================================================================
    // LOCAL STORAGE - Save and restore user progress
    // ===================================================================================
    const STORAGE_KEY = 'spanishFlashcardState';

    function saveState() {
      try {
        // Save user settings and last selected pack/act (NOT deck progress)
        const state = {
          voiceURI: currentVoice ? currentVoice.voiceURI : null,
          speed: currentSpeed,
          wordpackKey: currentWordpackKey,
          act: currentAct,
          language: nativeLanguage,
          // Chinese display options
          showChineseChars: showChineseChars,
          showPinyin: showPinyin
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Could not save state:', e);
      }
    }

    function loadState() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          return JSON.parse(stored);
        }
      } catch (e) {
        console.warn('Could not load state:', e);
      }
      return null;
    }

    // ============================================================
    // TOOLTIP MESSAGES - Single source of truth for ALL tooltip text
    // ============================================================
    // Convention: CLICK (round cardboard button) or PRESS [rectangular key] to simple_action
    //
    // These SAME messages are displayed in TWO places:
    //   1. Mode tooltips (hover over  Flashcard Mode) - shows list of all actions
    //   2. Button hover tooltips (hover over  button) - shows that single action
    //
    // HTML classes used:
    //   .tooltip-btn  = round cardboard circle for clickable buttons
    //   .tooltip-key  = rectangular cardboard key for keyboard keys
    // ============================================================
    const TOOLTIP_MESSAGES = {
      // Reading mode actions - action words (CLICK, PRESS, TYPE) are bolded
      gotIt: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>PRESS</b> <span class="tooltip-key">1</span> to Remove Card',
      confused: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>PRESS</b> <span class="tooltip-key">2</span> to Add Extra Practice',
      prevCard: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>PRESS</b> <span class="tooltip-key"></span> to Previous Card',
      nextCard: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>PRESS</b> <span class="tooltip-key"></span> to Next Card',

      // All modes actions
      pronounce: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>PRESS</b> <span class="tooltip-key"></span> to Hear Pronunciation',
      peek: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>HOLD</b> <span class="tooltip-key"></span> to See Translation',

      // Speaking mode
      record: '<b>CLICK</b> <span class="tooltip-btn"></span> or <b>PRESS</b> <span class="tooltip-key">Space</span> to Record',

      // Typing modes (listening/writing)
      typeLetters: '<b>TYPE</b> <span class="tooltip-key">Letters</span> to Spell Word'
    };

    // DOM Elements - menu elements are created dynamically in renderMenuCard()
    // and accessed via document.getElementById('menu-act'), etc.
    const backLabel = document.getElementById('back-label');
    const flashcard = document.getElementById('flashcard');
    const spanishWord = document.getElementById('spanish-word');
    const englishWord = document.getElementById('english-word');
    const wordpackTitle = document.getElementById('wordpack-title');
    const cardCounter = document.getElementById('card-counter');
    const weatheringFront = document.getElementById('weathering-front');
    const weatheringBack = document.getElementById('weathering-back');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const gotItBtn = document.getElementById('got-it-btn');
    const confusedBtn = document.getElementById('confused-btn');
    const peekBtn = document.getElementById('peek-btn');
    const pronounceBtn = document.getElementById('pronounce-btn');
    const resetBtn = document.getElementById('reset-btn');
    const peekBtnFront = document.getElementById('peek-btn-front');
    const controlSeparator = document.getElementById('control-separator');
    const speedBtns = document.querySelectorAll('.speed-btn'); // Includes both setup and menu buttons
    const removedStamp = document.getElementById('removed-stamp');
    const addedStamp = document.getElementById('added-stamp');

    // Mode selector elements
    const modeBtns = document.querySelectorAll('.mode-btn');
    const modeFlashcard = document.getElementById('mode-flashcard');
    const modeSpelling = document.getElementById('mode-spelling');
    const modePronunciation = document.getElementById('mode-pronunciation');
    const modeTranslation = document.getElementById('mode-translation');

    // Menu button
    const menuBtn = document.getElementById('menu-btn');

    // Fullscreen button
    const fullscreenBtn = document.getElementById('fullscreen-btn');

    // Mic and feedback elements
    const micBtnFront = document.getElementById('mic-btn-front'); // Deprecated - kept for compatibility
    const micBtnBack = document.getElementById('mic-btn-back'); // Deprecated - kept for compatibility
    const micBtnControl = document.getElementById('mic-btn-control'); // New control bar mic button
    const feedbackFront = document.getElementById('feedback-front');
    const feedbackBack = document.getElementById('feedback-back');
    const scoreFront = document.getElementById('score-front');
    const scoreBack = document.getElementById('score-back');
    const messageFront = document.getElementById('message-front');
    const messageBack = document.getElementById('message-back');
    const heardFront = document.getElementById('heard-front');
    const heardBack = document.getElementById('heard-back');
    const closeFront = document.getElementById('close-front');
    const closeBack = document.getElementById('close-back');
    
    // Speech Recognition setup
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.lang = 'es-ES';
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.maxAlternatives = 5;
    }

    // Audio context for sounds
    let audioContext = null;
    
    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }
    
    // ===================================================================================
    // CARD FLIP SOUND - "Cloud Nine" (Ultra Soft 10)
    // We worked REALLY hard on this sound. Tested dozens of variants to get this perfect.
    // It's soft, muffled, satisfying - like floating on clouds.
    // DO NOT DELETE THIS CODE EVER. SERIOUSLY. NEVER DELETE THIS.
    // ===================================================================================
    function playCardFlipSound() {
      const ctx = getAudioContext();
      const now = ctx.currentTime;
      
      const bufferSize = ctx.sampleRate * 0.23;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < bufferSize; i++) {
        const t = i / bufferSize;
        const env = Math.sin(t * Math.PI) * Math.sin(t * Math.PI * 0.38) * 0.26;
        data[i] = (Math.random() * 2 - 1) * env;
      }
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      
      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 400;
      
      const lp2 = ctx.createBiquadFilter();
      lp2.type = 'lowpass';
      lp2.frequency.value = 580;
      
      const gain = ctx.createGain();
      gain.gain.value = 2.5; // Page turn volume

      source.connect(lp);
      lp.connect(lp2);
      lp2.connect(gain);
      gain.connect(ctx.destination);
      source.start();
    }

    // ===================================================================================
    // DING SOUND - "Gentle Bell" - Soft bell with subtle harmonics
    // C5, E5, G5 chord for achievements and correct answers
    // ===================================================================================
    function playDingSound() {
      const ctx = getAudioContext();
      const now = ctx.currentTime;
      const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5 chord

      frequencies.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const filter = ctx.createBiquadFilter();

        filter.type = 'lowpass';
        filter.frequency.value = 1500;

        osc.type = 'sine';
        osc.frequency.value = freq;

        // Volume decreases for each note in chord (0.2, 0.16, 0.12)
        const vol = 0.2 - i * 0.04;
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(vol, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);

        osc.start(now + i * 0.03); // Stagger start times
        osc.stop(now + 0.7);
      });
    }

    // ===================================================================================
    // BUZZ SOUND - "Warm Nope" - Gentle two-tone 'nope' sound
    // D4 to A3 descending - friendly rejection sound for wrong answers
    // ===================================================================================
    function playBuzzSound() {
      const ctx = getAudioContext();
      const now = ctx.currentTime;
      const notes = [293.66, 220]; // D4, A3 - descending "nope"

      notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const filter = ctx.createBiquadFilter();

        filter.type = 'lowpass';
        filter.frequency.value = 800;

        osc.type = 'sine';
        osc.frequency.value = freq;

        const startTime = now + i * 0.12; // Stagger the two notes
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.2, startTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.15);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);

        osc.start(startTime);
        osc.stop(startTime + 0.15);
      });
    }

    // ===================================================================================
    // BUTTON CLICK SOUND - "Click Snap J - Satisfying"
    // This is the perfect UI click sound. Balanced, satisfying snap with subtle low end.
    // DO NOT DELETE THIS SOUND ASSET. NEVER. WE MEAN IT.
    // ===================================================================================
    function playButtonClickSound() {
      const ctx = getAudioContext();
      const now = ctx.currentTime;
      
      const bufferSize = ctx.sampleRate * 0.03;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/bufferSize, 4.5);
      }
      
      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // More muffled - lower frequency lowpass filter instead of bandpass
      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 800; // Much lower for muffled sound (was 2800 bandpass)
      lp.Q.value = 0.7;

      // Add second lowpass for extra muffling
      const lp2 = ctx.createBiquadFilter();
      lp2.type = 'lowpass';
      lp2.frequency.value = 1200;

      // Subtle low end
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(120, now); // Lower frequency
      osc.frequency.exponentialRampToValueAtTime(60, now + 0.025);

      const oscGain = ctx.createGain();
      oscGain.gain.setValueAtTime(0.05, now); // Quieter (was 0.1)
      oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);

      const gain = ctx.createGain();
      gain.gain.value = 0.75; // Much louder - increased from 0.45

      source.connect(lp);
      lp.connect(lp2);
      lp2.connect(gain);
      gain.connect(ctx.destination);
      osc.connect(oscGain);
      oscGain.connect(ctx.destination);

      source.start();
      osc.start();
      osc.stop(now + 0.04);
    }

    // ===================================================================================
    // MECHANICAL KEYBOARD SOUND - Satisfying tactile click (kept for future reference)
    // ===================================================================================
    function playKeyboardSound() {
      const ctx = getAudioContext();
      const now = ctx.currentTime;

      const bufferSize = ctx.sampleRate * 0.04;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/bufferSize, 5);
      }

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 2000;

      const bp = ctx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 4500;
      bp.Q.value = 2;

      const gain = ctx.createGain();
      gain.gain.value = 0.3;

      source.connect(hp);
      hp.connect(bp);
      bp.connect(gain);
      gain.connect(ctx.destination);
      source.start();
    }

    // ===================================================================================
    // MECHANICAL KEYBOARD TYPING SOUND - Satisfying clicky mechanical keyboard
    // ===================================================================================
    function playScribbleSound() {
      const ctx = getAudioContext();
      const now = ctx.currentTime;

      // Very short duration for crisp mechanical click (0.015-0.025 seconds)
      const duration = 0.015 + Math.random() * 0.01;
      const bufferSize = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      // Generate sharp click noise
      for (let i = 0; i < bufferSize; i++) {
        const envelope = Math.pow(1 - i/bufferSize, 8); // Very sharp decay for crisp click
        const noise = (Math.random() * 2 - 1);
        data[i] = noise * envelope;
      }

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // High frequency for mechanical click (2000-3500 Hz)
      const bp1 = ctx.createBiquadFilter();
      bp1.type = 'bandpass';
      bp1.frequency.value = 2000 + Math.random() * 1500; // 2000-3500 Hz - clicky range
      bp1.Q.value = 4.0; // Very high Q for sharp, defined click

      // Mid frequency for body (1000-1500 Hz)
      const bp2 = ctx.createBiquadFilter();
      bp2.type = 'bandpass';
      bp2.frequency.value = 1000 + Math.random() * 500; // 1000-1500 Hz - body
      bp2.Q.value = 2.5;

      // Remove low mud
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 400;

      // Moderate volume for satisfying click
      const gain = ctx.createGain();
      gain.gain.value = 0.8; // Keyboard click volume

      source.connect(hp);
      hp.connect(bp1);
      bp1.connect(bp2);
      bp2.connect(gain);
      gain.connect(ctx.destination);
      source.start();
    }

    // ===================================================================================
    // KEY FEATURE: Stamp Display Functions (Encapsulated)
    // Core Objective: Visual feedback for correct/wrong answers - define ONCE, use everywhere
    // Key Behaviors:
    //   - showSuccessStamp: green "Card Removed" stamp + ding sound
    //   - showFailureStamp: red "Extra Practice" stamp + buzz sound
    //   - Both hide after 1.5 seconds and execute callback
    // ===================================================================================
    function showSuccessStamp(onComplete) {
      removedStamp.classList.add('visible');
      playDingSound();
      setTimeout(() => {
        removedStamp.classList.remove('visible');
        if (onComplete) onComplete();
      }, 1500);
    }

    function showFailureStamp(onComplete) {
      addedStamp.classList.add('visible');
      playBuzzSound();
      setTimeout(() => {
        addedStamp.classList.remove('visible');
        if (onComplete) onComplete();
      }, 1500);
    }

    // ===================================================================================
    // MODE SWITCHING AND DISPLAY FUNCTIONS
    // ===================================================================================

    // Normalize character for comparison (remove accents, lowercase)
    function normalizeChar(char) {
      return char.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
    }

    // Navigate to starting card (menu/help card)
    function showStartingCard(showBack = false) {
      if (!isOnStartingCard && currentDeck.length > 0) {
        savedIndex = currentIndex;
      }
      isOnStartingCard = true;

      // Add showing-menu class so menu content and UI elements are visible
      flashcard.classList.add('showing-menu');
      document.body.classList.add('showing-menu');

      // Update titles (use detected target language)
      const gameTitle = targetLanguageDisplay
        ? `${targetLanguageDisplay} Flashcard Typing Game`
        : 'Flashcard Typing Game';
      wordpackTitle.textContent = gameTitle;
      cardCounter.textContent = 'Choose Lesson to Begin Studying';

      // Render menu card (looks identical to a flashcard)
      renderMenuCard();

      // Unflip card face if currently flipped
      if (isFlipped) {
        flashcard.classList.remove('flipped');
        isFlipped = false;
      }

      // Flip to back if help was requested
      if (showBack) {
        setTimeout(() => flipCard(), 100);
      }
    }

    // Return from starting card to saved position
    function exitStartingCard() {
      if (!isOnStartingCard) return;
      isOnStartingCard = false;

      // Remove showing-menu class
      flashcard.classList.remove('showing-menu');
      document.body.classList.remove('showing-menu');

      currentIndex = savedIndex;
      updateWordpackTitle(); // Restore wordpack title
      updateDisplay();
    }

    // Render the menu card (looks like a regular flashcard)
    function renderMenuCard() {
      // Get language name for UI text (use detected or fallback to generic)
      const langName = targetLanguageDisplay || 'Target';
      const voiceLabel = targetLanguageDisplay ? `${targetLanguageDisplay} Voice` : 'Voice';
      // For Chinese, typing is pinyin-based
      const typingDesc = isChineseMode() ? 'type pinyin' : 'type what you heard';
      const translationTypingDesc = isChineseMode() ? 'type pinyin' : `type ${langName} translation`;

      // Front: Menu/Settings (styled like target language side)
      spanishWord.innerHTML = `
        <div style="font-size: 1.1rem; text-align: left; max-width: 550px; margin: 0 auto; line-height: 1.8;">
          <!-- Row 1: Act and Wordpack -->
          <div style="display: flex; gap: 15px; margin-bottom: 20px;">
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>Choose Act</label>
              <select id="menu-act">
              </select>
            </div>
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>Choose Wordpack</label>
              <select id="menu-wordpack">
              </select>
            </div>
          </div>

          <!-- Row 2: Language and Speed -->
          <div style="display: flex; gap: 15px; margin-bottom: 20px;">
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>I speak</label>
              <select id="menu-language">
              </select>
            </div>
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>Pronunciation Speed</label>
              <div style="display: flex; gap: 8px; justify-content: center;">
                <button class="menu-speed-btn" data-speed="0.3"></button>
                <button class="menu-speed-btn" data-speed="0.6"></button>
                <button class="menu-speed-btn" data-speed="0.9"></button>
              </div>
            </div>
          </div>

          <!-- Row 3: Voice -->
          <div class="menu-field" style="margin-bottom: 25px;">
            <label>${voiceLabel}</label>
            <select id="menu-voice">
              <option value="">Loading voices...</option>
            </select>
          </div>

          <button id="start-practice-btn" class="setup-start-btn" style="width: 100%;">
             Start Game
          </button>
        </div>
      `;
      spanishWord.className = 'card-word';

      // Back: Help/Instructions (styled like translation side)
      englishWord.innerHTML = `
        <div style="font-size: 2rem; font-weight: bold; margin-bottom: 20px;"> How to Use</div>

        <div style="font-size: 1.1rem; text-align: left; max-width: 500px; margin: 0 auto; line-height: 1.8;">
          <div style="margin-bottom: 15px;">
            <strong> Flashcard Mode:</strong> ${langName} word  flip to see translation
          </div>

          <div style="margin-bottom: 15px;">
            <strong> Spelling Mode:</strong> Hear ${langName}  ${typingDesc}
          </div>

          <div style="margin-bottom: 15px;">
            <strong> Pronunciation Mode:</strong> See ${langName}  say it out loud (Space to record)
          </div>

          <div style="margin-bottom: 15px;">
            <strong> Translation Mode:</strong> See translation  ${translationTypingDesc}
          </div>

          <div style="margin-bottom: 15px;">
            <strong>Controls:</strong><br>
             Click card or  to flip<br>
               to navigate<br>
             Space: Hear pronunciation (reading) / Record speech (speaking) / Type practice (listening/writing)<br>
             Type letters in listening/translation modes
          </div>

          <div style="margin-bottom: 15px;">
            <strong>Buttons:</strong><br>
              Remove mastered card<br>
              Add 2 practice copies<br>
              Reset all cards
          </div>
        </div>
      `;
      englishWord.className = 'card-word';

      // Populate selectors after render
      setTimeout(() => {
        const menuAct = document.getElementById('menu-act');
        const menuWordpack = document.getElementById('menu-wordpack');
        const menuLanguage = document.getElementById('menu-language');
        const menuVoice = document.getElementById('menu-voice');
        const startPracticeBtn = document.getElementById('start-practice-btn');

        // Populate act selector
        if (menuAct) {
          populateActSelector(menuAct);
          if (currentAct) {
            menuAct.value = currentAct;
          }

          menuAct.addEventListener('change', async (e) => {
            playButtonClickSound();
            const selectedAct = parseInt(e.target.value);
            currentAct = selectedAct;
            menuWordpack.innerHTML = '';
            menuWordpack.disabled = true;

            try {
              await loadAct(selectedAct);
              populateWordpackSelectorOnCard(selectedAct);
              menuWordpack.disabled = false;
            } catch (error) {
              console.error('Failed to load act:', error);
              menuWordpack.innerHTML = '<option value="">Failed to load act</option>';
            }
          });
        }

        // Populate wordpack selector
        if (menuWordpack) {
          populateWordpackSelectorOnCard(currentAct);
          // Restore saved wordpack selection if available
          if (currentWordpackKey && loadedActs[currentAct] && loadedActs[currentAct][currentWordpackKey]) {
            menuWordpack.value = currentWordpackKey;
          }

          menuWordpack.addEventListener('change', (e) => {
            playButtonClickSound();
            currentWordpackKey = e.target.value;
            saveState();
          });
        }

        // Language selector - populated from config, not hardcoded HTML
        if (menuLanguage) {
          populateLanguageSelector(menuLanguage);

          menuLanguage.addEventListener('change', (e) => {
            playButtonClickSound();
            nativeLanguage = e.target.value;
            updateBackLabel();
            // Update Chinese display options visibility
            updateChineseOptionsVisibility();
            // Reinitialize deck to include/exclude pinyin based on new language
            if (currentWordpackKey) {
              initializeDeck(currentWordpackKey);
            }
            saveState();
          });
        }

        // Voice selector - use saved state (currentVoice or savedVoiceURI)
        // No "Default" placeholder - always show actual voice name
        if (menuVoice && spanishVoices.length > 0) {
          menuVoice.innerHTML = ''; // Clear - no placeholder
          spanishVoices.forEach((voice) => {
            const option = document.createElement('option');
            option.value = voice.voiceURI;
            option.textContent = `${voice.name} (${voice.lang})`;
            menuVoice.appendChild(option);
          });

          // Use currentVoice if set, otherwise use savedVoiceURI from state, otherwise first voice
          const voiceURIToRestore = currentVoice ? currentVoice.voiceURI : savedVoiceURI;
          if (voiceURIToRestore && spanishVoices.find(v => v.voiceURI === voiceURIToRestore)) {
            menuVoice.value = voiceURIToRestore;
            // Also set currentVoice if we have the URI but not the voice object
            if (!currentVoice && savedVoiceURI) {
              currentVoice = spanishVoices.find(v => v.voiceURI === savedVoiceURI) || null;
            }
          } else {
            // No saved voice or saved voice not found - default to first voice
            const firstVoice = spanishVoices[0];
            menuVoice.value = firstVoice.voiceURI;
            currentVoice = firstVoice;
            savedVoiceURI = firstVoice.voiceURI;
          }

          menuVoice.addEventListener('change', (e) => {
            playButtonClickSound();
            const newVoiceURI = e.target.value;
            currentVoice = spanishVoices.find(v => v.voiceURI === newVoiceURI) || null;
            savedVoiceURI = newVoiceURI; // Also update savedVoiceURI
            saveState();
            // Preview the new voice by speaking the current word
            if (currentDeck.length > 0) {
              setTimeout(() => speakSpanish(), 100);
            }
          });
        }

        // Speed buttons - use CSS classes for cardboard styling
        const speedBtns = document.querySelectorAll('.menu-speed-btn');
        // First reset ALL buttons to default state (remove active class)
        speedBtns.forEach(b => {
          b.classList.remove('active');
        });
        // Then highlight the one matching saved currentSpeed
        speedBtns.forEach(btn => {
          if (parseFloat(btn.dataset.speed) === currentSpeed) {
            btn.classList.add('active');
          }
          btn.addEventListener('click', () => {
            playButtonClickSound();
            currentSpeed = parseFloat(btn.dataset.speed);
            speedBtns.forEach(b => {
              b.classList.remove('active');
            });
            btn.classList.add('active');
            saveState();
            // Preview the new speed by speaking the current word
            if (currentDeck.length > 0) {
              setTimeout(() => speakSpanish(), 100);
            }
          });
        });

        // Start Practice button
        if (startPracticeBtn) {
          startPracticeBtn.addEventListener('click', () => {
            playButtonClickSound(); // Always play sound for feedback
            if (currentWordpackKey && nativeLanguage) {
              startGame();
            }
          });
        }
      }, 0);
    }

    // Helper function to populate wordpack selector on card
    // KEY FEATURE: Uses saved state first, only defaults to first pack if no saved state
    function populateWordpackSelectorOnCard(actNumber) {
      const menuWordpack = document.getElementById('menu-wordpack');
      if (!menuWordpack || !actNumber) return;

      menuWordpack.innerHTML = ''; // Clear existing options - no placeholder

      const actData = loadedActs[actNumber];
      if (!actData) return;

      // Filter out __actMeta - only get actual pack keys
      const packKeys = Object.keys(actData).filter(key => key !== '__actMeta');
      packKeys.sort((a, b) => {
        const numA = actData[a].meta.wordpack;
        const numB = actData[b].meta.wordpack;
        return numA - numB;
      });

      packKeys.forEach(packKey => {
        const pack = actData[packKey];
        const option = document.createElement('option');
        option.value = packKey;
        option.textContent = `${pack.meta.wordpack}. ${pack.meta.english}`;
        menuWordpack.appendChild(option);
      });

      // Use saved wordpack if valid for this act, otherwise default to first pack
      if (currentWordpackKey && actData[currentWordpackKey]) {
        // Saved wordpack exists in this act - use it
        menuWordpack.value = currentWordpackKey;
      } else if (packKeys.length > 0) {
        // No saved wordpack or not valid for this act - default to first
        menuWordpack.value = packKeys[0];
        currentWordpackKey = packKeys[0];
        saveState(); // Save the default
      }
    }

    // Switch to a different learning mode
    function switchMode(newMode) {
      if (currentMode === newMode) return;

      // Stop all speech sounds - mode change is like a reset
      speechSynthesis.cancel();

      currentMode = newMode;

      // Update active button
      modeBtns.forEach(btn => btn.classList.remove('active'));
      if (newMode === 'flashcard') modeFlashcard.classList.add('active');
      if (newMode === 'spelling') modeSpelling.classList.add('active');
      if (newMode === 'pronunciation') modePronunciation.classList.add('active');
      if (newMode === 'translation') modeTranslation.classList.add('active');

      // Completely reset pack as if starting new game in this mode
      // (Reset from original deck, not modified current deck)
      // CRITICAL: Keep pedagogical ordering (base words first, then examples)
      if (originalDeck.length > 0) {
        currentDeck = [...originalDeck]; // Copy without shuffling - preserve baseexample order
        currentIndex = 0;
      }

      // Reset flip state
      if (isFlipped) {
        flashcard.classList.remove('flipped');
        isFlipped = false;
      }

      // Reset deck change indicator
      pendingDeckChange = 0;

      // Initialize typing display for listening and translation modes
      if ((newMode === 'spelling' || newMode === 'translation') && currentDeck.length > 0) {
        initializeTypingDisplay();
      }

      updateDisplay();

      // Auto-pronounce target word in spelling mode only (not writing - user needs to translate)
      if (newMode === 'spelling' && currentDeck.length > 0) {
        setTimeout(() => speakSpanish(), 300);
      }

      // Save state (only saves speech rate and pack selection, not deck progress)
      saveState();
    }

    // Initialize typing display for spelling and translation modes
    function initializeTypingDisplay() {
      const word = currentDeck[currentIndex].typingTarget;
      typingInput = '';
      typingDisplay = word.split('');
      typedPositions = new Set();
      wrongAttempts = 0;
      wrongPositions = [];
      wrongLetters = [];
    }

    // Add duplicate cards to current deck for extra practice
    function addDuplicateCards(count) {
      if (currentDeck.length === 0 || count === 0) return;

      const currentCard = currentDeck[currentIndex];

      // Insert cards randomly in the remaining deck, skipping next 2 cards if possible
      for (let i = 0; i < count; i++) {
        const duplicate = { ...currentCard };

        // Calculate remaining cards after current card
        const remainingCards = currentDeck.length - (currentIndex + 1);

        if (remainingCards > 2) {
          // If more than 2 cards remaining, insert randomly after the next 2 cards
          const randomOffset = Math.floor(Math.random() * (remainingCards - 2)) + 3;
          currentDeck.splice(currentIndex + randomOffset, 0, duplicate);
        } else if (remainingCards > 0) {
          // If 1-2 cards remaining, insert right after current card
          currentDeck.splice(currentIndex + 1, 0, duplicate);
        } else {
          // If no cards remaining, add to end
          currentDeck.push(duplicate);
        }
      }

      // Track deck change for visual indicator
      pendingDeckChange += count;

      // Update display to show indicator while stamp is visible
      updateDisplay();

      // Show "Extra Practice" stamp with buzz sound (encapsulated)
      showFailureStamp(() => {
        pendingDeckChange = 0; // Clear indicator after stamp
      });
    }

    // Handle typing input for listening and translation modes
    function handleTypingInput(key) {
      if ((currentMode !== 'spelling' && currentMode !== 'translation') || currentDeck.length === 0) return;

      const word = currentDeck[currentIndex].spanish;
      const targetChars = word.split('');

      // Find next unfilled position (first position not in typedPositions)
      let nextPos = 0;
      for (let i = 0; i < typingDisplay.length; i++) {
        if (!typedPositions.has(i) && typingDisplay[i] !== ' ') {
          nextPos = i;
          break;
        }
        if (i === typingDisplay.length - 1) {
          // Already completed
          return;
        }
      }

      // Skip spaces and mark them as typed
      while (nextPos < targetChars.length && targetChars[nextPos] === ' ') {
        typedPositions.add(nextPos);
        nextPos++;
      }

      if (nextPos >= targetChars.length) return;

      // Check if key matches (case and accent insensitive)
      const normalizedKey = normalizeChar(key);
      const normalizedTarget = normalizeChar(targetChars[nextPos]);

      if (normalizedKey === normalizedTarget) {
        // Correct! Mark position as typed
        typedPositions.add(nextPos);
        playScribbleSound(); // Felt pen writing sound
        updateDisplay();

        // Check if word is complete (all non-space positions typed)
        const totalNonSpaceChars = targetChars.filter(c => c !== ' ').length;
        if (typedPositions.size >= totalNonSpaceChars) {
          // Word completed!
          // 0-1 wrong = correct (show green stamp and remove card)
          // 2+ wrong = always +2 penalty cards

          if (wrongAttempts <= 1) {
            // Correct! Show green stamp and remove card automatically
            pendingDeckChange = -1; // Track deck change for visual indicator
            updateDisplay(); // Show indicator while stamp is visible

            // Show success stamp with ding sound (encapsulated)
            showSuccessStamp(() => {
              // Remove card from deck
              if (currentDeck.length <= 1) {
                currentDeck = [];
              } else {
                currentDeck.splice(currentIndex, 1);
                if (currentIndex >= currentDeck.length) {
                  currentIndex = 0;
                }
              }

              // Clear pending change
              pendingDeckChange = 0;

              // Play sound on page change (consistent timing)
              playCardFlipSound();

              // Re-initialize typing for next card
              if (currentMode === 'spelling' || currentMode === 'translation') {
                initializeTypingDisplay();
              }
              updateDisplay();
              saveState();

              // Auto-pronounce in spelling mode
              if (currentMode === 'spelling' && currentDeck.length > 0) {
                setTimeout(() => speakSpanish(), 300);
              }
            });
          } else {
            // Wrong - always add 2 penalty cards
            addDuplicateCards(2);

            // Auto-advance after stamp duration (1600ms > 1500ms stamp)
            setTimeout(() => {
              if (currentMode === 'spelling' || currentMode === 'translation') {
                moveToNextCard();
              }
            }, 1600);
          }
        }
      } else {
        // Wrong key pressed - mark position as wrong, increment counter, and track wrong letter
        playScribbleSound(); // Play scribble sound for any key press
        if (!wrongPositions.includes(nextPos)) {
          wrongPositions.push(nextPos);
        }
        wrongAttempts++;
        // Store wrong letter with its style (lowercase, random rotation/scale - set once, never changes)
        wrongLetters.push({
          letter: key.toLowerCase(), // Case-insensitive
          rotation: -8 + Math.random() * 16, // -8deg to +8deg
          scale: 0.95 + Math.random() * 0.1, // 0.95 to 1.05
          xRotation: -5 + Math.random() * 10 // -5deg to +5deg for X mark
        });
        updateDisplay(); // Update to show red color and wrong indicators
      }
    }

    // Check if current word is complete in translation mode
    function isWritingComplete() {
      return !typingDisplay.includes('_');
    }

    // Load voices based on TTS language code from loaded modules
    // KEY FEATURE: Voices only load if modules are loaded - no module = no voices
    function loadVoices() {
      const ttsLangCode = getTtsLanguageCode();

      // Only filter voices if we have a language code from loaded modules
      if (!ttsLangCode) {
        spanishVoices = []; // No modules loaded = no voices
        return;
      }

      spanishVoices = speechSynthesis.getVoices().filter(v => v.lang.startsWith(ttsLangCode));

      // Restore saved voice if we have a saved URI and voices are now available
      if (savedVoiceURI && spanishVoices.length > 0 && !currentVoice) {
        currentVoice = spanishVoices.find(v => v.voiceURI === savedVoiceURI) || null;
      }
      // Voice selector is now populated in renderMenuCard() when menu is created
    }

    function populateVoiceSelector() {
      // DEPRECATED: Voice selector is now populated inside renderMenuCard()
      // This function kept for compatibility but does nothing
    }

    // Load voices when available
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = loadVoices;
    }
    loadVoices();

    // ============================================================
    // KEY FEATURE: Load acts on demand with obfuscated modules
    // Core Objective: Efficiently load only needed acts, decode them
    // Key Behaviors:
    //   - Populate act selector on page load
    //   - Load and decode act data when user selects an act
    //   - Cache loaded acts to avoid re-loading
    //   - Populate wordpack selector with packs from selected act
    // ============================================================

    // Load a specific act's data
    async function loadAct(actNumber) {
      // Check if already loaded
      if (loadedActs[actNumber]) {
        return loadedActs[actNumber];
      }

      // Get URL from MODULE_URLS array (actNumber is 1-indexed)
      const url = MODULE_URLS[actNumber - 1];

      if (!url) {
        throw new Error(`Act ${actNumber} URL not found in MODULE_URLS`);
      }

      try {
        console.log(`Loading act ${actNumber}...`);
        const actData = await decodeObfuscatedModule(url);

        // Extract and store __actMeta (contains actName, translations, etc.)
        if (actData.__actMeta) {
          loadedActMeta[actNumber] = actData.__actMeta;
          console.log(`Act ${actNumber} metadata:`, actData.__actMeta.actName);
        }

        // Store only pack data (exclude __actMeta)
        const packsOnly = { ...actData };
        delete packsOnly.__actMeta;

        loadedActs[actNumber] = packsOnly;
        Object.assign(wordpacks, packsOnly);

        console.log(`Act ${actNumber} loaded successfully:`, Object.keys(packsOnly).length, 'packs');
        return packsOnly;
      } catch (error) {
        console.error(`Failed to load act ${actNumber}:`, error);
        throw error;
      }
    }

    // Populate act selector dropdown
    // KEY FEATURE: Act names come from loaded module __actMeta, not inline config
    function populateActSelector(targetElement = null) {
      // Use provided element or find menu-act element
      const selectElement = targetElement || document.getElementById('menu-act');
      if (!selectElement) {
        console.warn('[populateActSelector] No target element found');
        return;
      }

      selectElement.innerHTML = '';

      // Get act numbers from loadedActMeta (populated when modules are loaded)
      const actNumbers = Object.keys(loadedActMeta).map(Number).sort((a, b) => a - b);

      if (actNumbers.length === 0) {
        console.warn('[populateActSelector] No acts loaded yet');
        return;
      }

      actNumbers.forEach(actNum => {
        const meta = loadedActMeta[actNum];
        const option = document.createElement('option');
        option.value = actNum;
        option.textContent = `Act ${actNum}: ${meta.actName}`;
        selectElement.appendChild(option);
      });

      // Use saved act if valid, otherwise default to first act
      if (currentAct && actNumbers.includes(currentAct)) {
        // Saved act is valid - use it
        selectElement.value = currentAct;
      } else if (actNumbers.length > 0) {
        // No saved act or invalid - default to first
        selectElement.value = actNumbers[0];
        currentAct = actNumbers[0];
        saveState(); // Save the default
      }
    }

    // Populate "I speak" language selector from loaded module metadata
    // KEY FEATURE: Languages come from __actMeta.translations in loaded modules
    function populateLanguageSelector(targetElement = null) {
      const selectElement = targetElement || document.getElementById('menu-language');
      if (!selectElement) {
        console.warn('[populateLanguageSelector] No target element found');
        return;
      }

      selectElement.innerHTML = '';
      const translations = getTranslationsConfig();

      if (!translations) {
        console.warn('[populateLanguageSelector] No translations loaded yet');
        return;
      }

      Object.entries(translations).forEach(([langCode, langConfig]) => {
        const option = document.createElement('option');
        option.value = langCode;
        option.textContent = langConfig.display;
        selectElement.appendChild(option);
      });

      // Use saved language if valid, otherwise default
      const validLanguages = Object.keys(translations);
      if (nativeLanguage && validLanguages.includes(nativeLanguage)) {
        selectElement.value = nativeLanguage;
      } else {
        // Invalid or no saved language - use default from loaded metadata
        nativeLanguage = getDefaultTranslation();
        selectElement.value = nativeLanguage;
        saveState();
      }
    }

    // ============================================================
    // Initialize tooltips from TOOLTIP_MESSAGES (single source of truth)
    // ============================================================
    // This function populates BOTH:
    //   1. Mode tooltips (the big instruction lists under each mode button)
    //   2. Control bar button tooltips (hover text for individual buttons)
    // All using the SAME TOOLTIP_MESSAGES, ensuring consistency.
    // ============================================================
    function initializeTooltips() {
      // ---------------------------------------------------------
      // MODE TOOLTIPS - Build instruction lists for each mode
      // ---------------------------------------------------------

      // Flashcard Mode: gotIt, confused, prevCard, nextCard, pronounce, peek
      const readingTooltip = document.getElementById('tooltip-reading');
      if (readingTooltip) {
        readingTooltip.innerHTML = `
          <strong> Flashcard Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.gotIt}<br>
            ${TOOLTIP_MESSAGES.confused}<br>
            ${TOOLTIP_MESSAGES.prevCard}<br>
            ${TOOLTIP_MESSAGES.nextCard}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // Spelling Mode: typeLetters, pronounce, peek
      const listeningTooltip = document.getElementById('tooltip-listening');
      if (listeningTooltip) {
        listeningTooltip.innerHTML = `
          <strong> Spelling Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.typeLetters}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // Pronunciation Mode: record, pronounce, peek
      const speakingTooltip = document.getElementById('tooltip-speaking');
      if (speakingTooltip) {
        speakingTooltip.innerHTML = `
          <strong> Pronunciation Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.record}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // Translation Mode: typeLetters, pronounce, peek
      const writingTooltip = document.getElementById('tooltip-writing');
      if (writingTooltip) {
        writingTooltip.innerHTML = `
          <strong> Translation Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.typeLetters}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // ---------------------------------------------------------
      // CONTROL BAR BUTTON TOOLTIPS - Same messages as mode tooltips
      // ---------------------------------------------------------
      // Note: These use innerHTML because messages contain HTML (styled spans)
      gotItBtn.innerHTML = '';
      gotItBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.gotIt);
      confusedBtn.innerHTML = '';
      confusedBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.confused);
      pronounceBtn.innerHTML = '';
      pronounceBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.pronounce);
      peekBtn.innerHTML = '';
      peekBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.peek);

      // Mic button tooltip (control bar)
      const micBtnControlEl = document.getElementById('mic-btn-control');
      if (micBtnControlEl) {
        micBtnControlEl.innerHTML = '';
        micBtnControlEl.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.record);
      }

      // ---------------------------------------------------------
      // Control bar button tooltips REMOVED per user request
      // Only mode selector buttons have hover tooltips now
      // ---------------------------------------------------------
    }

    // Helper: Create a tooltip element for a button (allows HTML content)
    function createButtonTooltip(button, htmlContent) {
      // Remove any existing tooltip
      const existing = button.querySelector('.btn-tooltip');
      if (existing) existing.remove();

      // Create tooltip element
      const tooltip = document.createElement('span');
      tooltip.className = 'btn-tooltip';
      tooltip.innerHTML = htmlContent;
      button.appendChild(tooltip);
    }

    // Initialize on page load
    // KEY FEATURE: Loads act data, preloads deck from saved state (or pack 1), then displays menu overlay
    // Core Objective: User sees content under the menu when toggling, state is preserved across sessions
    async function initializeApp() {
      // Initialize tooltips from single source of truth
      initializeTooltips();

      // Setup Chinese display options checkboxes
      setupChineseDisplayOptions();

      try {
        // First act is 1 (MODULE_URLS is 0-indexed, act numbers are 1-indexed)
        if (MODULE_URLS.length > 0) {
          currentAct = 1;
        }

        // Load ALL acts to get their metadata for dropdowns
        // (act names and translations come from __actMeta in each module)
        for (let actNum = 1; actNum <= MODULE_URLS.length; actNum++) {
          await loadAct(actNum);
        }

        // ============================================================
        // VALIDATE AND DETECT TARGET LANGUAGE
        // All modules must have the same wordColumns[0]
        // ============================================================
        if (!validateTargetLanguageConsistency()) {
          throw new Error('Modules have inconsistent target languages');
        }

        // Set the target language from loaded modules
        targetLanguage = getTargetLanguage();
        targetLanguageDisplay = toTitleCase(targetLanguage);

        // Apply Chinese mode CSS class if needed
        updateChineseModeClass();

        // Update page title based on detected language
        if (targetLanguageDisplay) {
          document.title = `${targetLanguageDisplay} Flashcard Typing Game`;
          document.getElementById('wordpack-title').textContent = `${targetLanguageDisplay} Flashcard Typing Game`;
        }

        console.log(`[initializeApp] Detected target language: ${targetLanguage} (${targetLanguageDisplay})`);

        // Now that modules are loaded, load voices based on module metadata
        // This ensures no voices are available if modules fail to load
        loadVoices();

        // Remember which act we initially loaded
        const firstAct = currentAct;

        // Restore any saved state (may change currentAct and currentWordpackKey)
        restoreSavedState();

        // Update Chinese display options visibility based on restored language
        updateChineseOptionsVisibility();

        // If saved act is different from the first act we loaded, load it
        if (currentAct !== firstAct) {
          await loadAct(currentAct);
        }

        // KEY FEATURE: Preload deck so there's content under the menu
        // If no saved wordpack, default to first pack in current act
        if (!currentWordpackKey && loadedActs[currentAct]) {
          const packKeys = Object.keys(loadedActs[currentAct]);
          if (packKeys.length > 0) {
            currentWordpackKey = packKeys[0];
          }
        }

        // Initialize the deck silently (content will be under the menu)
        if (currentWordpackKey && wordpacks[currentWordpackKey]) {
          initializeDeck(currentWordpackKey);
          updateWordpackTitle();
          updateBackLabel();

          // Set game-started state so card content is visible under menu
          flashcard.classList.add('game-started');
          document.body.classList.add('game-started');
          gameStarted = true;
        }

        // Show menu on card as overlay - this renders the menu and populates selectors
        showStartingCard(false);
      } catch (error) {
        console.error('Failed to initialize app:', error);
        // Show error in menu if it exists
        const menuAct = document.getElementById('menu-act');
        const menuWordpack = document.getElementById('menu-wordpack');
        if (menuAct) menuAct.innerHTML = '<option value="">Failed to load acts</option>';
        if (menuWordpack) menuWordpack.innerHTML = '<option value="">Failed to load wordpacks</option>';
      }
    }

    // NOTE: populateWordpackSelector was removed - functionality moved to populateWordpackSelectorOnCard()
    // which is called from renderMenuCard() and properly handles the menu-wordpack element

    // Restore saved state from localStorage
    // KEY FEATURE: Restores user's last session settings (speed, wordpack, act, language, voice)
    // If no saved state exists, creates one with current defaults
    function restoreSavedState() {
      const savedState = loadState();

      // If no saved state, save current defaults and return
      if (!savedState) {
        saveState(); // Save defaults so they persist
        return;
      }

      // Restore speech rate (validate against valid options)
      if (savedState.speed !== undefined && savedState.speed !== null) {
        // Only restore if it's a valid speed option, otherwise keep default
        if (VALID_SPEEDS.includes(savedState.speed)) {
          currentSpeed = savedState.speed;
        }
        // Speed buttons UI will be updated when menu renders
      }

      // Restore last selected act
      if (savedState.act) {
        currentAct = savedState.act;
      }

      // Restore last selected wordpack (value only - UI updated when menu renders)
      if (savedState.wordpackKey) {
        currentWordpackKey = savedState.wordpackKey;
      }

      // Restore native language (validate against valid options)
      if (savedState.language) {
        // Only restore if it's a valid language option, otherwise keep default
        if (getValidLanguages().includes(savedState.language)) {
          nativeLanguage = savedState.language;
        }
      }

      // Store saved voice URI - will be applied when voices are loaded
      if (savedState.voiceURI) {
        savedVoiceURI = savedState.voiceURI;
      }

      // Restore Chinese display options (default to true if not saved)
      if (savedState.showChineseChars !== undefined) {
        showChineseChars = savedState.showChineseChars;
      }
      if (savedState.showPinyin !== undefined) {
        showPinyin = savedState.showPinyin;
      }

      // Update checkbox states in UI
      const showCharsCheckbox = document.getElementById('showChineseChars');
      const showPinyinCheckbox = document.getElementById('showPinyin');
      if (showCharsCheckbox) showCharsCheckbox.checked = showChineseChars;
      if (showPinyinCheckbox) showPinyinCheckbox.checked = showPinyin;
    }

    function updateBackLabel() {
      // Card labels have been removed, this function is no longer needed
      // Kept for compatibility with existing code that calls it
      if (!backLabel) return;

      // Get display label from loaded module metadata
      const translations = getTranslationsConfig();
      if (!translations) return;
      const langConfig = translations[nativeLanguage];
      backLabel.textContent = langConfig ? langConfig.display : translations[getDefaultTranslation()].display;
    }

    // Shuffle array (Fisher-Yates algorithm)
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // ============================================================
    // ARCHITECTURE: Combine and Shuffle Base/Example Words
    // ============================================================
    /*
      Combines baseWords and exampleWords with controlled shuffling.

      Educational Psychology: Learners should encounter CORE VOCABULARY
      before CONTEXTUAL EXAMPLES.

      1. BASE WORDS are shuffled internally (variety within basics)
      2. EXAMPLE WORDS are shuffled internally (variety within examples)
      3. BASE WORDS ALWAYS COME FIRST (pedagogical order preserved)

      INPUT: pack object with { baseWords: [...], exampleWords: [...] }
      OUTPUT: Array of objects with { word: [...], type: "Base Word" | "Example Word" }
    */
    function combineAndShuffleWords(pack) {
      const baseWords = pack.baseWords || [];
      const exampleWords = pack.exampleWords || [];

      // Shuffle and tag base words
      const shuffledBase = shuffleArray(baseWords).map(word => ({
        word: word,
        type: "Base Word"
      }));

      // Shuffle and tag example words
      const shuffledExamples = shuffleArray(exampleWords).map(word => ({
        word: word,
        type: "Example Word"
      }));

      // Concatenate - BASE ALWAYS FIRST (pedagogical order)
      const combinedWords = [...shuffledBase, ...shuffledExamples];

      console.log(`[Architecture] Combined ${shuffledBase.length} base + ${shuffledExamples.length} examples = ${combinedWords.length} total words`);

      return combinedWords;
    }

    // ============================================================
    // KEY FEATURE: Deck Initialization with Linked Card Objects
    // Core Objective: Create shuffled deck where front/back are ALWAYS synced
    // Key Behaviors:
    //   - Each card is a SINGLE object with both spanish and translation
    //   - Front and back of card are NEVER separate - they are properties
    //     of the same card object (currentDeck[currentIndex])
    //   - Shuffling reorders cards but NEVER breaks the front/back link
    //   - This function is ONLY called when starting fresh or changing wordpack
    // ============================================================
    function initializeDeck(packKey) {
      if (!packKey || !wordpacks[packKey]) {
        currentDeck = [];
        originalDeck = [];
        updateDisplay();
        return;
      }

      const pack = wordpacks[packKey];
      // Get translation column index from loaded module metadata
      const translations = getTranslationsConfig();
      if (!translations) {
        console.error('[initializeDeck] No translations loaded');
        return;
      }
      const langConfig = translations[nativeLanguage];
      const nativeIndex = langConfig ? langConfig.index : translations[getDefaultTranslation()].index;

      // ============================================================
      // ARCHITECTURE: Combine baseWords + exampleWords with shuffling
      // ============================================================
      const words = combineAndShuffleWords(pack);

      // ============================================================
      // DYNAMIC LANGUAGE HANDLING
      // Card structure adapts based on target language:
      // - targetWord: The word being learned (column 0)
      // - pinyin: Pinyin for Chinese (column 1 if Chinese, or translation pinyin)
      // - translation: The translation in native language
      // - typingTarget: What user types (pinyin for Chinese, targetWord otherwise)
      // ============================================================
      const targetIsChinese = isChineseMode();

      // Get word columns from loaded metadata to find pinyin column
      const wordColumns = getWordColumns();

      // Find pinyin index - it follows 'chinese' column in the word array
      let pinyinIndex = -1;
      if (wordColumns) {
        const chineseIdx = wordColumns.indexOf('chinese');
        if (chineseIdx !== -1) {
          // Pinyin typically follows chinese column
          const pinyinIdx = wordColumns.indexOf('pinyin');
          if (pinyinIdx !== -1) {
            pinyinIndex = pinyinIdx;
          }
        }
      }

      // CRITICAL: Each card object contains BOTH front (target word) and back (translation)
      // These are NEVER stored separately - they are always linked as one object
      originalDeck = words.map((wordObj, idx) => {
        const word = wordObj.word;  // Extract word array from object
        const card = {
          id: `${packKey}-${idx}`,        // Unique ID for this card
          targetWord: word[0],            // Front of card (target language word)
          spanish: word[0],               // BACKWARDS COMPAT: Alias for non-Chinese modes
          translation: word[nativeIndex], // Back of card (translation)
          type: wordObj.type              // Word type for debugging (Base Word / Example Word)
        };

        // ============================================================
        // CHINESE-SPECIFIC HANDLING
        // ============================================================
        if (targetIsChinese) {
          // When learning Chinese: pinyin is at index 1 (directly after Chinese)
          card.pinyin = word[1] || '';
          card.chinese = word[0];         // Alias for Chinese mode
          // Typing target is pinyin (letter-based typing)
          card.typingTarget = card.pinyin;
        } else {
          // When learning Spanish/English: typing target is the target word
          card.typingTarget = card.targetWord;

          // Add pinyin when TRANSLATION is Chinese (not target language)
          if (nativeLanguage === 'chinese' && pinyinIndex !== -1) {
            card.translationPinyin = word[pinyinIndex] || '';
            card.translationIsChinese = true;
          }
        }

        return card;
      });

      // ============================================================
      // CRITICAL: DO NOT shuffle originalDeck here!
      // Words are already ordered by combineAndShuffleWords():
      //   1. Base words (shuffled internally)
      //   2. Example words (shuffled internally)
      // Shuffling here would mix base and example words together,
      // breaking the pedagogical ordering!
      // ============================================================
      currentDeck = [...originalDeck]; // Copy without shuffling
      currentIndex = 0;
      updateDisplay();
    }

    // Restart current wordpack
    function restartCurrentPack() {
      playButtonClickSound();
      if (originalDeck.length > 0) {
        // Keep pedagogical ordering (base words first, then examples)
        currentDeck = [...originalDeck]; // Copy without shuffling
        currentIndex = 0;
        if (currentMode === 'spelling' || currentMode === 'translation') {
          initializeTypingDisplay();
        }
        updateDisplay();
        saveState();
      }
    }

    // Go to next wordpack
    function goToNextPack() {
      playButtonClickSound();
      const packs = Object.keys(wordpacks);
      if (packs.length === 0) return;

      const currentPackIndex = packs.indexOf(currentWordpackKey);
      const nextPackIndex = (currentPackIndex + 1) % packs.length;
      const nextPackKey = packs[nextPackIndex];

      currentWordpackKey = nextPackKey;
      // Update menu selector if visible
      const menuWordpack = document.getElementById('menu-wordpack');
      if (menuWordpack) menuWordpack.value = nextPackKey;
      initializeDeck(nextPackKey);
      updateWordpackTitle();
      saveState();
    }

    // Generate random weathering pattern for a card
    function generateWeathering(seed) {
      // Use card ID as seed for consistent random pattern per card
      const random = (s) => {
        const x = Math.sin(s) * 10000;
        return x - Math.floor(x);
      };

      // Generate stronger sun-faded edges (more obvious)
      const topFade = 15 + random(seed) * 10; // 15-25%
      const rightFade = 15 + random(seed + 1) * 10;
      const bottomFade = 15 + random(seed + 2) * 10;
      const leftFade = 15 + random(seed + 3) * 10;

      // Vary the color tint (brownish/sepia tones)
      const redTint = 101 + Math.floor(random(seed + 4) * 20); // 101-120
      const greenTint = 67 + Math.floor(random(seed + 5) * 15); // 67-82
      const blueTint = 33 + Math.floor(random(seed + 6) * 10); // 33-43

      // Vary the edge intensity (stronger)
      const edgeIntensity = 0.18 + random(seed + 7) * 0.12; // 0.18-0.30

      // Overall card color variation (subtle)
      const overallIntensity = 0.03 + random(seed + 8) * 0.04; // 0.03-0.07

      // Random positions for color variation splotches
      const spot1X = 20 + random(seed + 9) * 30; // 20-50%
      const spot1Y = 20 + random(seed + 10) * 30;
      const spot2X = 50 + random(seed + 11) * 30; // 50-80%
      const spot2Y = 50 + random(seed + 12) * 30;
      const spot3X = 30 + random(seed + 13) * 40; // 30-70%
      const spot3Y = 60 + random(seed + 14) * 30;

      const gradients = [
        // Overall card color variations (subtle splotches across entire card)
        `radial-gradient(ellipse 60% 50% at ${spot1X}% ${spot1Y}%, rgba(${redTint}, ${greenTint}, ${blueTint}, ${overallIntensity}) 0%, transparent 60%)`,
        `radial-gradient(ellipse 50% 60% at ${spot2X}% ${spot2Y}%, rgba(${redTint + 5}, ${greenTint + 3}, ${blueTint + 2}, ${overallIntensity * 0.8}) 0%, transparent 55%)`,
        `radial-gradient(ellipse 55% 45% at ${spot3X}% ${spot3Y}%, rgba(${redTint - 5}, ${greenTint - 2}, ${blueTint}, ${overallIntensity * 0.9}) 0%, transparent 50%)`,
        // Stronger sun-faded edges
        `linear-gradient(to bottom, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${topFade}%)`,
        `linear-gradient(to left, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${rightFade}%)`,
        `linear-gradient(to top, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${bottomFade}%)`,
        `linear-gradient(to right, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${leftFade}%)`
      ];

      return gradients.join(', ');
    }

    // Render typing display with word grouping (keeps words together, wraps between words)
    function renderTypingDisplay() {
      let html = '';
      let currentWord = [];
      let currentWordStartIdx = 0;

      for (let idx = 0; idx < typingDisplay.length; idx++) {
        const actualChar = typingDisplay[idx]; // Always the real character

        if (actualChar === ' ') {
          // End of word - wrap accumulated chars in nowrap span
          if (currentWord.length > 0) {
            html += `<span style="white-space: nowrap;">${currentWord.join('')}</span>`;
            currentWord = [];
          }
          // Add space between words (browser handles line breaks naturally without trailing/leading spaces)
          html += ' ';
          currentWordStartIdx = idx + 1;
        } else {
          // Always render actual character to preserve layout
          // For untyped positions, show underscore overlay (character is invisible but takes space)
          const isTyped = typedPositions.has(idx);
          const wrongClass = wrongPositions.includes(idx) ? 'wrong' : '';

          if (isTyped) {
            // Typed: show actual character
            currentWord.push(`<span class="typing-char ${wrongClass}">${actualChar}</span>`);
          } else {
            // Untyped: invisible character with underscore overlay (preserves natural spacing)
            currentWord.push(`<span class="typing-char ${wrongClass}" style="position: relative; display: inline-block;"><span style="opacity: 0;">${actualChar}</span><span style="position: absolute; top: 0; left: 0;">_</span></span>`);
          }
        }
      }

      // Add remaining word
      if (currentWord.length > 0) {
        html += `<span style="white-space: nowrap;">${currentWord.join('')}</span>`;
      }

      return html;
    }

    // ============================================================
    // KEY FEATURE: Card Display - Front and Back Always Linked
    // Core Objective: Display current card with guaranteed sync
    // Key Behaviors:
    //   - ALWAYS uses single card object: currentDeck[currentIndex]
    //   - card.targetWord = front of card (the word being learned)
    //   - card.typingTarget = what user types (pinyin for Chinese, targetWord otherwise)
    //   - card.pinyin = pinyin pronunciation (Chinese mode only)
    //   - card.translation = back of card
    //   - These are NEVER from different sources - always same object
    // ============================================================

    /**
     * Renders the target word (front of card) with proper formatting
     * - For Chinese: renders with coupled Chinese characters + pinyin
     * - For other languages: plain text
     * @param {Object} card - Card object with targetWord and optionally pinyin
     * @returns {string} - HTML string for the target word
     */
    function renderTargetWord(card) {
      // If target language is Chinese, use coupled rendering
      if (isChineseMode() && card.pinyin) {
        return getChineseHtml(card.targetWord, card.pinyin);
      }
      return card.targetWord;
    }

    /**
     * Renders the translation text, using coupled Chinese+pinyin display when applicable
     * @param {Object} card - Card object with translation and optionally translationPinyin
     * @returns {string} - HTML string for the translation
     */
    function renderTranslation(card) {
      // If translation is Chinese, use coupled rendering
      if (card.translationIsChinese && card.translationPinyin) {
        return getChineseHtml(card.translation, card.translationPinyin);
      }
      // Otherwise, plain text
      return card.translation;
    }

    function updateDisplay() {
      // Starting card is shown/hidden by showStartingCard/exitStartingCard
      // Don't update card content when on starting card
      if (isOnStartingCard) {
        return;
      }

      if (currentDeck.length === 0) {
        // Show completion screen
        cardCounter.textContent = 'Pack Complete!';
        spanishWord.innerHTML = `
          <div style="font-size: 3rem; margin-bottom: 30px;"> Good Job! </div>
          <div style="font-size: 1.5rem; margin-bottom: 40px;">You've completed this wordpack!</div>
          <div style="display: flex; gap: 20px; justify-content: center;">
            <button onclick="restartCurrentPack()" style="padding: 15px 30px; font-size: 1.3rem; background: #8B7355; color: var(--color-text-light); border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
               Study Again
            </button>
            <button onclick="goToNextPack()" style="padding: 15px 30px; font-size: 1.3rem; background: #7A6347; color: var(--color-text-light); border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
               Next Pack
            </button>
          </div>
        `;
        spanishWord.className = 'card-word';
        englishWord.textContent = '';
        return;
      }

      // CRITICAL: Get SINGLE card object - front (target word) and back (translation) are ALWAYS linked
      const card = currentDeck[currentIndex];

      // Display counter (deck change indicator now shown as overlay stamp on card)
      let counterText = `Card ${currentIndex + 1} of ${currentDeck.length}`;

      // ============================================================
      // DEBUG MODE: Show word type (Base Word / Example Word)
      // ============================================================
      if (DEBUG_SHOW_WORD_TYPE && card.type) {
        const typeColor = card.type === "Base Word" ? "#2563eb" : "#059669";
        const typeWeight = card.type === "Base Word" ? "bold" : "normal";
        counterText += ` | <span style="color: ${typeColor}; font-weight: ${typeWeight};">${card.type}</span>`;
      }

      cardCounter.innerHTML = counterText; // Use innerHTML to render HTML tags

      // Get indicator elements (positioned at card corners, not inside card-word)
      const wrongLettersFront = document.getElementById('wrong-letters-front');
      const wrongCountFront = document.getElementById('wrong-count-front');

      // Mode-specific display
      if (currentMode === 'flashcard') {
        // FLASHCARD MODE - Purpose: Learn to read target word and understand meaning
        // Front: Target word | Back: Translation
        // For Chinese: renderTargetWord() returns coupled char+pinyin HTML
        // When translation is Chinese, renderTranslation() returns coupled char+pinyin HTML
        spanishWord.innerHTML = renderTargetWord(card);
        spanishWord.className = 'card-word';
        englishWord.innerHTML = `<div class="translation-text">${renderTranslation(card)}</div>`;
        englishWord.className = 'card-word';
        // Clear indicators
        wrongLettersFront.innerHTML = '';
        wrongCountFront.innerHTML = '';
      } else if (currentMode === 'spelling') {
        // SPELLING MODE - Purpose: Learn to understand spoken target language and spell it
        // Front: Hear audio + type what you hear | Back: Target word + translation
        // Update wrong indicators (positioned at card corners) - use stored variations (don't recalc)
        // Show all wrong letters including repeats (user can see each wrong attempt)
        wrongLettersFront.innerHTML = wrongLetters.length > 0
          ? wrongLetters.map(item => {
              // Use stored rotation/scale values - never recalculate (real writing doesn't move!)
              return `<span style="position: relative; display: inline-block; margin-right: 15px; transform: scale(${item.scale}) rotate(${item.rotation}deg);"><span style="color: var(--color-text-dark);">${item.letter}</span><span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(${item.xRotation}deg); color: #D32F2F; font-size: 0.7em; font-weight: bold; opacity: 0.7;"></span></span>`;
            }).join('')
          : '';
        const countRotate = -2 + Math.random() * 4; // -2deg to +2deg
        const countScale = 0.95 + Math.random() * 0.1; // 0.95 to 1.05
        wrongCountFront.innerHTML = wrongAttempts > 0
          ? `<span style="display: inline-block; transform: scale(${countScale}) rotate(${countRotate}deg);">-${wrongAttempts}</span>`
          : '';
        // Update card content (no indicators embedded here)
        spanishWord.innerHTML = `<div class="typing-display">${renderTypingDisplay()}</div>`;
        spanishWord.className = 'card-word';
        // Back shows target word + translation (with Chinese coupling if applicable)
        englishWord.innerHTML = `${renderTargetWord(card)}<br><div class="translation-text">${renderTranslation(card)}</div>`;
        englishWord.className = 'card-word';
      } else if (currentMode === 'translation') {
        // TRANSLATION MODE - Purpose: Learn to write/spell target word from translation
        // Front: Translation + type target word | Back: Correct target word
        // Update wrong indicators (positioned at card corners) - use stored variations (don't recalc)
        // Show all wrong letters including repeats (user can see each wrong attempt)
        wrongLettersFront.innerHTML = wrongLetters.length > 0
          ? wrongLetters.map(item => {
              // Use stored rotation/scale values - never recalculate (real writing doesn't move!)
              return `<span style="position: relative; display: inline-block; margin-right: 15px; transform: scale(${item.scale}) rotate(${item.rotation}deg);"><span style="color: var(--color-text-dark);">${item.letter}</span><span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(${item.xRotation}deg); color: #D32F2F; font-size: 0.7em; font-weight: bold; opacity: 0.7;"></span></span>`;
            }).join('')
          : '';
        const countRotate = -2 + Math.random() * 4; // -2deg to +2deg
        const countScale = 0.95 + Math.random() * 0.1; // 0.95 to 1.05
        wrongCountFront.innerHTML = wrongAttempts > 0
          ? `<span style="display: inline-block; transform: scale(${countScale}) rotate(${countRotate}deg);">-${wrongAttempts}</span>`
          : '';
        // Update card content (no indicators embedded here)
        // TRANSLATION MODE: Front shows translation (for user to translate FROM)
        // When translation is Chinese, show with coupled char+pinyin
        spanishWord.innerHTML = `<div class="translation-text">${renderTranslation(card)}</div><div style="margin: 10px 0;"></div><div class="typing-display">${renderTypingDisplay()}</div>`;
        spanishWord.className = 'card-word';
        // Back shows target word (with Chinese coupling if applicable)
        englishWord.innerHTML = renderTargetWord(card);
        englishWord.className = 'card-word';
      } else if (currentMode === 'pronunciation') {
        // PRONUNCIATION MODE - Purpose: Learn to pronounce target word correctly
        // Front: Target word + microphone button | Back: Translation (with Chinese coupling if applicable)
        spanishWord.innerHTML = renderTargetWord(card);
        spanishWord.className = 'card-word';
        englishWord.innerHTML = `<div class="translation-text">${renderTranslation(card)}</div>`;
        englishWord.className = 'card-word';
        // Clear indicators
        wrongLettersFront.innerHTML = '';
        wrongCountFront.innerHTML = '';
      }

      // Show/hide mic button based on mode (now in control bar, not on card)
      const micBtnControlEl = document.getElementById('mic-btn-control');
      if (currentMode === 'pronunciation') {
        micBtnControlEl.style.display = 'flex';
      } else {
        micBtnControlEl.style.display = 'none';
      }

      // Show/hide control bar buttons based on mode
      // Got It and Confused buttons: only in flashcard mode
      if (currentMode === 'flashcard') {
        gotItBtn.style.display = 'flex';
        confusedBtn.style.display = 'flex';
      } else {
        gotItBtn.style.display = 'none';
        confusedBtn.style.display = 'none';
      }

      // Separator: show in flashcard mode (after /) and pronunciation mode (after )
      if (currentMode === 'flashcard' || currentMode === 'pronunciation') {
        controlSeparator.style.display = 'block';
      } else {
        controlSeparator.style.display = 'none';
      }

      // Show/hide navigation arrows based on mode (only show in flashcard mode - others auto-advance)
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      if (currentMode === 'flashcard') {
        prevBtn.style.display = 'flex';
        nextBtn.style.display = 'flex';
      } else {
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
      }

      // Apply random weathering based on card ID
      const seed = card.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      weatheringFront.style.background = generateWeathering(seed);
      weatheringBack.style.background = generateWeathering(seed + 1000);

      // Reset flip state
      flashcard.classList.remove('flipped');
      isFlipped = false;
    }

    // ============================================================
    // KEY FEATURE: Auto-pronounce target word in spelling mode
    // - On card navigation (prev/next): auto-pronounce
    // - Helps users learn pronunciation through repetition
    // ============================================================

    // Navigate to previous card (with wrap-around)
    function goToPrevious() {
      if (currentDeck.length === 0) return;
      speechSynthesis.cancel(); // Stop speech on card navigation
      playCardFlipSound();
      currentIndex = (currentIndex - 1 + currentDeck.length) % currentDeck.length;
      if (currentMode === 'spelling' || currentMode === 'translation') {
        initializeTypingDisplay();
      }
      updateDisplay();
      saveState();

      // Auto-read in spelling mode (helps learn pronunciation)
      if (currentMode === 'spelling') {
        setTimeout(() => speakSpanish(), 300);
      }
    }

    // Navigate to next card (with wrap-around)
    function goToNext() {
      if (currentDeck.length === 0) return;
      speechSynthesis.cancel(); // Stop speech on card navigation
      playCardFlipSound();
      currentIndex = (currentIndex + 1) % currentDeck.length;
      if (currentMode === 'spelling' || currentMode === 'translation') {
        initializeTypingDisplay();
      }
      updateDisplay();
      saveState();

      // Auto-read in spelling mode (helps learn pronunciation)
      if (currentMode === 'spelling') {
        setTimeout(() => speakSpanish(), 300);
      }
    }

    // Move to next card (for typing mode completion)
    function moveToNextCard() {
      if (currentDeck.length === 0) return;
      playCardFlipSound();
      currentIndex = (currentIndex + 1) % currentDeck.length;
      if (currentMode === 'spelling' || currentMode === 'translation') {
        initializeTypingDisplay();
      }
      updateDisplay();
      saveState();

      // Auto-read in spelling mode only (not writing - user needs to translate)
      if (currentMode === 'spelling') {
        setTimeout(() => speakSpanish(), 300);
      }
    }

    // ============================================================
    // REMOVED FEATURE: Auto-pronounce on peek/flip removed per user request
    // User prefers manual control via pronounce button
    // ============================================================

    // Flip card
    function flipCard() {
      // Don't stop speech - let it continue while viewing back
      flashcard.classList.add('flipped');
      isFlipped = true;

      // Auto-pronounce removed - users can manually click pronounce button if needed
    }

    // Unflip card
    function unflipCard() {
      // Don't stop speech - let it continue while viewing front
      flashcard.classList.remove('flipped');
      isFlipped = false;
    }

    // Remove current card (Got it!)
    function removeCurrentCard() {
      if (currentDeck.length <= 1) {
        currentDeck = [];
        updateDisplay();
        saveState();
        return;
      }

      // Track deck change for visual indicator
      pendingDeckChange = -1;

      // Update display to show indicator while stamp is visible
      updateDisplay();

      // Show success stamp with ding sound (encapsulated)
      showSuccessStamp(() => {
        // Remove card from deck
        currentDeck.splice(currentIndex, 1);
        if (currentIndex >= currentDeck.length) {
          currentIndex = 0;
        }

        // Clear pending change and show next card with updated count
        pendingDeckChange = 0;

        // Play sound on page change (consistent timing)
        playCardFlipSound();

        // Show next card
        updateDisplay();
        saveState();
      });
    }

    // Add extra copies of current card (Confused)
    function addConfusedCards() {
      if (currentDeck.length === 0) return;

      // Track deck change for visual indicator (+2 cards)
      pendingDeckChange += 2;
      updateDisplay();

      // Show failure stamp with buzz sound (encapsulated)
      showFailureStamp(() => {
        // Add 2 copies to random positions in deck
        const card = { ...currentDeck[currentIndex] };

        for (let n = 0; n < 2; n++) {
          const randomPos = Math.floor(Math.random() * (currentDeck.length + 1));
          currentDeck.splice(randomPos, 0, { ...card, id: `${card.id}-copy-${Date.now()}-${n}` });

          // Adjust current index if we inserted before it
          if (randomPos <= currentIndex) {
            currentIndex++;
          }
        }

        // Clear pending change indicator
        pendingDeckChange = 0;

        // Play sound on page change
        playCardFlipSound();

        // Move to next card and update display
        currentIndex = (currentIndex + 1) % currentDeck.length;
        updateDisplay();
        saveState();
      });
    }

    // Reset deck to original shuffled state (fresh start in current mode)
    function resetDeck() {
      if (originalDeck.length === 0) return;
      playButtonClickSound();

      // Completely reset as if we just started this pack in this mode
      // CRITICAL: Keep pedagogical ordering (base words first, then examples)
      currentDeck = [...originalDeck]; // Copy without shuffling - preserve baseexample order
      currentIndex = 0;

      // Reset typing state for typing modes
      if (currentMode === 'spelling' || currentMode === 'translation') {
        initializeTypingDisplay();
      }

      // Reset flip state
      if (isFlipped) {
        flashcard.classList.remove('flipped');
        isFlipped = false;
      }

      // Reset deck change indicator
      pendingDeckChange = 0;

      updateDisplay();

      // Auto-pronounce in spelling mode
      if (currentMode === 'spelling' && currentDeck.length > 0) {
        setTimeout(() => speakSpanish(), 300);
      }

      saveState();
    }

    // Speak the target word (uses TTS for the detected target language)
    function speakTargetWord() {
      if (currentDeck.length === 0) return;

      const utterance = new SpeechSynthesisUtterance(currentDeck[currentIndex].targetWord);
      utterance.lang = getTtsLanguageCode();
      utterance.rate = currentSpeed;
      if (currentVoice) {
        utterance.voice = currentVoice;
      }
      speechSynthesis.cancel();
      speechSynthesis.speak(utterance);
    }

    // Alias for backwards compatibility - some places may still call speakSpanish
    function speakSpanish() {
      speakTargetWord();
    }

    // Set speech speed
    function setSpeed(speed, btn) {
      currentSpeed = speed;
      speedBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      saveState();
    }

    // Levenshtein distance for string similarity
    function levenshteinDistance(str1, str2) {
      const m = str1.length;
      const n = str2.length;
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (str1[i - 1] === str2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];
          } else {
            dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
          }
        }
      }
      return dp[m][n];
    }

    // Calculate similarity percentage
    function calculateSimilarity(expected, heard) {
      const exp = expected.toLowerCase().trim();
      const hrd = heard.toLowerCase().trim();
      
      if (exp === hrd) return 100;
      if (hrd.length === 0) return 0;
      
      const distance = levenshteinDistance(exp, hrd);
      const maxLen = Math.max(exp.length, hrd.length);
      const similarity = Math.max(0, ((maxLen - distance) / maxLen) * 100);
      
      return Math.round(similarity);
    }

    // Get feedback message based on score
    function getFeedbackMessage(score) {
      if (score >= 90) return "Excelente! Perfect!";
      if (score >= 75) return "Muy bien! Great job!";
      if (score >= 50) return "Bien! Keep practicing!";
      if (score >= 25) return "Getting there...";
      return "Try again!";
    }

    // Get score class for coloring
    function getScoreClass(score) {
      if (score >= 90) return "excellent";
      if (score >= 75) return "good";
      if (score >= 50) return "okay";
      return "poor";
    }

    // Show pronunciation feedback
    function showFeedback(score, heard, isFront = true) {
      const feedback = isFront ? feedbackFront : feedbackBack;
      const scoreEl = isFront ? scoreFront : scoreBack;
      const messageEl = isFront ? messageFront : messageBack;
      const heardEl = isFront ? heardFront : heardBack;

      // Speaking mode: Don't show overlay, auto-advance with stamps
      if (currentMode === 'pronunciation') {
        if (score >= 70) {
          // Pass! Remove card and advance
          pendingDeckChange = -1;
          updateDisplay();

          // Show success stamp with ding sound (encapsulated)
          showSuccessStamp(() => {
            // Remove card from deck
            if (currentDeck.length <= 1) {
              currentDeck = [];
            } else {
              currentDeck.splice(currentIndex, 1);
              if (currentIndex >= currentDeck.length) {
                currentIndex = 0;
              }
            }

            pendingDeckChange = 0;
            playCardFlipSound();
            updateDisplay();
            saveState();
          });
        } else {
          // Below 70% - add 2 penalty cards and advance
          addDuplicateCards(2);

          setTimeout(() => {
            moveToNextCard();
          }, 1600);
        }
        return; // Don't show overlay
      }

      // Non-pronunciation modes: show feedback overlay
      scoreEl.textContent = `${score}%`;
      scoreEl.className = `feedback-score ${getScoreClass(score)}`;
      messageEl.textContent = getFeedbackMessage(score);
      heardEl.textContent = `Heard: "${heard}"`;

      feedback.classList.add('visible');
    }

    // Hide feedback
    function hideFeedback() {
      feedbackFront.classList.remove('visible');
      feedbackBack.classList.remove('visible');
    }

    // Start listening for pronunciation
    function startListening(isFront = true) {
      if (!recognition) {
        alert('Speech recognition is not supported in your browser. Try Chrome or Edge.');
        return;
      }

      if (currentDeck.length === 0) return;
      if (isListening) return;

      isListening = true;
      // Use control bar mic button for listening animation
      micBtnControl.classList.add('spelling');

      recognition.onresult = (event) => {
        const results = event.results[0];
        let bestMatch = results[0].transcript;
        let bestScore = 0;

        const expected = currentDeck[currentIndex].spanish;

        // Check all alternatives for best match
        for (let i = 0; i < results.length; i++) {
          const transcript = results[i].transcript;
          const score = calculateSimilarity(expected, transcript);
          if (score > bestScore) {
            bestScore = score;
            bestMatch = transcript;
          }
        }

        showFeedback(bestScore, bestMatch, isFront);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        isListening = false;
        micBtnControl.classList.remove('spelling');

        if (event.error === 'no-speech') {
          showFeedback(0, '(no speech detected)', isFront);
        } else if (event.error === 'not-allowed') {
          alert('Microphone access denied. Please allow microphone access to use this feature.');
        }
      };

      recognition.onend = () => {
        isListening = false;
        micBtnControl.classList.remove('spelling');
      };

      recognition.start();
    }

    // Update wordpack title display
    function updateWordpackTitle() {
      if (currentWordpackKey && wordpacks[currentWordpackKey]) {
        const pack = wordpacks[currentWordpackKey];
        wordpackTitle.textContent = `Lesson ${pack.meta.wordpack}. ${pack.meta.english}`;
      } else {
        wordpackTitle.textContent = '';
      }
    }

    // Start the game
    // ============================================================
    // KEY FEATURE: Start/Resume Practice Session
    // Core Objective: Begin or continue studying flashcards
    // Key Behaviors:
    //   - If game already started with same wordpack, RESUME without reshuffling
    //   - Only initialize/shuffle deck when starting fresh or changing wordpack
    //   - Front and back of card are ALWAYS linked (same card object)
    // ============================================================
    function startGame() {
      // Values are already set via menu selectors or restored state
      // nativeLanguage and currentWordpackKey are already set

      // Update back label based on language
      updateBackLabel();

      // Update wordpack title
      updateWordpackTitle();

      // Exit starting card state if we're on it
      isOnStartingCard = false;
      flashcard.classList.remove('showing-menu');
      document.body.classList.remove('showing-menu');

      // KEY BEHAVIOR: Only initialize deck if:
      // 1. Game hasn't started yet (fresh start)
      // 2. No deck exists
      // 3. Wordpack changed (different from what's currently loaded)
      const needsNewDeck = !gameStarted ||
                           currentDeck.length === 0 ||
                           (currentDeck.length > 0 && currentDeck[0] &&
                            !currentDeck[0].id.startsWith(currentWordpackKey + '-'));

      if (needsNewDeck) {
        initializeDeck(currentWordpackKey);
      } else {
        // Resume: restore saved position and update display
        currentIndex = savedIndex;
        updateDisplay();
      }

      flashcard.classList.add('game-started');
      document.body.classList.add('game-started');
      gameStarted = true;
      saveState();
    }

    // Event Listeners

    prevBtn.addEventListener('click', () => {
      playButtonClickSound();
      goToPrevious();
    });
    nextBtn.addEventListener('click', () => {
      playButtonClickSound();
      goToNext();
    });
    gotItBtn.addEventListener('click', () => {
      playButtonClickSound();
      removeCurrentCard();
    });
    confusedBtn.addEventListener('click', () => {
      playButtonClickSound();
      addConfusedCards();
    });
    // Peek button (control bar - toggle flip on press)
    peekBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      playButtonClickSound();
      if (isFlipped) {
        unflipCard();
      } else {
        flipCard();
      }
    });
    // Reset/Refresh button - closes menu if open, then resets deck
    resetBtn.addEventListener('click', () => {
      playButtonClickSound();
      // Close menu if open
      if (isOnStartingCard) {
        exitStartingCard();
      }
      resetDeck();
    });

    // Pronounce button (no button click sound per user request)
    pronounceBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      speakSpanish();
    });

    // Peek button (hold to flip, release to unflip)
    peekBtnFront.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      flipCard();
    });
    peekBtnFront.addEventListener('mouseup', (e) => {
      e.stopPropagation();
      e.preventDefault();
      unflipCard();
    });
    peekBtnFront.addEventListener('mouseleave', (e) => {
      // If user moves mouse off button while holding, unflip
      unflipCard();
    });
    // Touch support for mobile
    peekBtnFront.addEventListener('touchstart', (e) => {
      e.stopPropagation();
      e.preventDefault();
      flipCard();
    });
    peekBtnFront.addEventListener('touchend', (e) => {
      e.stopPropagation();
      e.preventDefault();
      unflipCard();
    });
    peekBtnFront.addEventListener('touchcancel', (e) => {
      e.stopPropagation();
      e.preventDefault();
      unflipCard();
    });

    // Speed buttons
    speedBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        playButtonClickSound();
        const speed = parseFloat(btn.dataset.speed);
        setSpeed(speed, btn);
        // Play sample at new speed if game has started
        if (gameStarted && currentDeck.length > 0) {
          speakSpanish();
        }
      });
    });

    // Mic button in control bar (pronunciation mode)
    micBtnControl.addEventListener('click', (e) => {
      e.stopPropagation();
      playButtonClickSound();
      // Use current card side (front or back) for feedback display
      startListening(!isFlipped);
    });

    // Close feedback buttons
    closeFront.addEventListener('click', (e) => {
      e.stopPropagation();
      playButtonClickSound();
      hideFeedback();
    });
    closeBack.addEventListener('click', (e) => {
      e.stopPropagation();
      playButtonClickSound();
      hideFeedback();
    });

    // Menu button - toggle menu on/off
    menuBtn.addEventListener('click', () => {
      playButtonClickSound();
      if (isOnStartingCard) {
        exitStartingCard(); // Close menu if already showing
      } else {
        showStartingCard(false); // Show menu on card
      }
    });

    // Fullscreen button - toggle fullscreen mode
    fullscreenBtn.addEventListener('click', () => {
      playButtonClickSound();
      if (!document.fullscreenElement) {
        // Enter fullscreen
        document.documentElement.requestFullscreen().catch(err => {
          console.warn('Could not enter fullscreen:', err);
        });
      } else {
        // Exit fullscreen
        document.exitFullscreen().catch(err => {
          console.warn('Could not exit fullscreen:', err);
        });
      }
    });

    // Update fullscreen button icon when fullscreen state changes
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        fullscreenBtn.textContent = ''; // Already fullscreen - same icon works for exit
      } else {
        fullscreenBtn.textContent = ''; // Normal mode
      }
    });

    // KEY FEATURE: Click outside menu to close it
    // Clicking anywhere outside the flashcard area closes the menu
    document.addEventListener('click', (e) => {
      if (!isOnStartingCard) return; // Only when menu is open

      // Check if click is outside the flashcard
      const flashcardEl = document.querySelector('.flashcard');
      if (!flashcardEl.contains(e.target)) {
        // Also check it's not the menu button itself (handled separately)
        if (!menuBtn.contains(e.target)) {
          exitStartingCard();
        }
      }
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      // Don't handle navigation if on starting card (menu)
      if (isOnStartingCard) {
        return;
      }

      // Handle typing in listening and translation modes (accept letters, numbers, symbols - not space)
      if ((currentMode === 'spelling' || currentMode === 'translation') && e.key.length === 1 && e.key !== ' ') {
        e.preventDefault();
        handleTypingInput(e.key);
        return;
      }

      // Enter key removed from listening/translation modes - user should use navigation buttons

      // Prevent repeated actions when holding key down
      if (keysPressed[e.key]) {
        e.preventDefault();
        return;
      }
      keysPressed[e.key] = true;

      if (e.key === 'ArrowLeft') {
        // Only allow left arrow in flashcard mode
        if (currentMode === 'flashcard') {
          goToPrevious();
        }
      } else if (e.key === 'ArrowRight') {
        // Only allow right arrow in flashcard mode
        if (currentMode === 'flashcard') {
          goToNext();
        }
      } else if (e.key === 'ArrowUp') {
        // Up arrow: ALWAYS pronounce
        e.preventDefault();
        speakSpanish();
      } else if (e.key === 'ArrowDown') {
        // Down arrow: Hold to see translation (flip on keydown, unflip on keyup)
        e.preventDefault();
        flipCard();
      } else if (e.key === '1') {
        // Key 1: Remove card (Got it!) - only in flashcard mode
        if (currentMode === 'flashcard') {
          e.preventDefault();
          removeCurrentCard();
        }
      } else if (e.key === '2') {
        // Key 2: Add practice cards (Confused) - only in flashcard mode
        if (currentMode === 'flashcard') {
          e.preventDefault();
          addConfusedCards();
        }
      } else if (e.key === ' ') {
        // Space: pronounce in flashcard mode, record in pronunciation mode, play sound in translation mode, ignore in listening
        if (currentMode === 'flashcard') {
          e.preventDefault();
          speakSpanish();
        } else if (currentMode === 'pronunciation') {
          e.preventDefault();
          // Trigger mic button based on which side of card is showing
          const isFront = !isFlipped;
          startListening(isFront);
        } else if (currentMode === 'translation') {
          e.preventDefault();
          playScribbleSound(); // Play scribble sound but don't register input
        } else if (currentMode === 'spelling') {
          e.preventDefault(); // Ignore space in spelling mode
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      // Clear key state
      keysPressed[e.key] = false;

      // Down arrow: Release to unflip (hold behavior)
      if (e.key === 'ArrowDown') {
        unflipCard();
      }
    });

    // Mode selector event listeners
    // KEY FEATURE: Clicking mode while menu open closes menu and switches to that mode
    modeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        playButtonClickSound();
        const mode = btn.dataset.mode;
        // Close menu if open, then switch mode
        if (isOnStartingCard) {
          exitStartingCard();
        }
        switchMode(mode);
      });
    });

    // Initialize
    initializeApp();
  </script>
</body>
</html>
