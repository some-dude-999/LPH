<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=1024">
  <title>Flashcard Typing Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <!-- Shared wordpack logic (loading, decoding, shuffling, typing validation, debug tools) -->
  <script src="../wordpack-logic.js"></script>
  <!-- Shared game sounds (ding, buzz, card flip, button click, typing sounds) -->
  <script src="../game-sounds.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
  <!-- Chinese font - loaded but only applied when Chinese modules are used -->
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC:wght@700&display=swap" rel="stylesheet">
  <style>
    /* =================================================================
       DESIGN SYSTEM - Single source of truth for fonts, colors, textures
       ================================================================= */
    :root {
      /* ===========================================
         FONTS - Only 4 fonts used in entire project
         =========================================== */
      /* 1. Handwriting font - main card text (target words) */
      --font-card: 'IM Fell English', serif;

      /* 2. Monospace font - answer/back of card, tooltips */
      --font-answer: 'Courier New', monospace;

      /* 3. UI font - buttons, titles, labels, everything else */
      --font-ui: 'Cinzel', serif;

      /* 4. Chinese font - front card Chinese characters only */
      --font-chinese: 'LXGW WenKai TC', serif;

      /* ===========================================
         COLORS - Only 3 text colors used
         =========================================== */
      /* 1. Dark brown - main text on light backgrounds */
      --color-text-dark: #2C1810;

      /* 2. Off-white/cream - text on dark backgrounds (card counter, etc) */
      --color-text-light: #F5E6D3;

      /* 3. Gold - accent for titles and special elements */
      --color-text-gold: #E8D498;

      /* ===========================================
         TEXTURES - Paper and cardboard effects
         =========================================== */
      /* Paper texture (for cards) - 200x200 viewBox */
      --paper-texture: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.5' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)'/%3E%3C/svg%3E");
      --paper-texture-size: 200px 200px;

      /* Cardboard texture (for buttons) - Same 200x200 viewBox, 2x larger grain */
      --cardboard-texture: url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.5' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)'/%3E%3C/svg%3E");
      --cardboard-texture-size: 400px 400px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background:
        radial-gradient(ellipse at center, #8B7355 0%, #5D4E37 50%, #3D2E1F 100%);
      font-family: var(--font-card);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      padding-top: 80px; /* Space for fixed header */
      color: var(--color-text-dark);
    }

    /* ============================================================
       KEY FEATURE: Fixed Page Header
       Core Objective: Keep mode buttons, title, and UI buttons
       always visible at the top of the page
       Key Behaviors:
         - Fixed position at top of viewport
         - Contains mode selector (left), title (center), UI buttons (right)
         - Always visible even when scrolling/fullscreen
       ============================================================ */
    .page-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
      background: linear-gradient(180deg, rgba(61, 46, 31, 0.85) 0%, rgba(61, 46, 31, 0) 100%);
    }

    .header-buttons {
      display: flex;
      gap: 10px;
    }

    /* Remove focus outline from all interactive elements */
    button:focus,
    button:active,
    select:focus,
    input:focus,
    .mode-btn:focus,
    .mode-btn:active,
    .action-btn:focus,
    .action-btn:active,
    .nav-btn:focus,
    .nav-btn:active {
      outline: none !important;
    }

    /* Wordpack Selector */
    .selector-container {
      background: rgba(60, 46, 31, 0.6);
      padding: 12px 20px;
      border-radius: 8px;
      margin-bottom: 30px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      border: 1px solid rgba(139, 115, 85, 0.3);
    }

    .selector-container label {
      font-family: var(--font-ui);
      font-size: 1rem;
      font-weight: bold;
      margin-right: 10px;
      color: var(--color-text-gold);
    }

    #wordpack-select {
      font-family: var(--font-ui);
      font-size: 1rem;
      font-weight: bold;
      padding: 8px 15px;
      border: 1px solid rgba(139, 115, 85, 0.4);
      border-radius: 5px;
      background: rgba(45, 35, 25, 0.8);
      color: var(--color-text-gold);
      cursor: pointer;
      min-width: 200px;
    }

    #wordpack-select:focus {
      outline: none;
      border-color: #8B7355;
      box-shadow: 0 0 5px rgba(139, 115, 85, 0.3);
    }

    #wordpack-select option {
      background: #3D2E1F;
      color: var(--color-text-gold);
    }

    /* Wordpack Title - Warm gold with subtle texture */
    /* ============================================================
       KEY FEATURE: Page Title in Header
       Core Objective: Show context while keeping card as focal point
       Key Behaviors:
         - Visible but not overpowering
         - Centered in header bar
       ============================================================ */
    .wordpack-title {
      /* Bright gold gradient */
      background-image:
        var(--cardboard-texture),
        linear-gradient(180deg,
          #E8C252 0%,      /* Bright gold */
          #D4AF37 30%,     /* Classic gold */
          #C9A227 60%,     /* Medium gold */
          #A67C38 100%     /* Bronze gold */
        );
      background-blend-mode: overlay;
      background-size: var(--cardboard-texture-size), 100%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      font-family: var(--font-ui);
      font-size: 1.4rem;
      font-weight: 600;
      text-shadow:
        0 1px 2px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: opacity 0.3s ease;
      letter-spacing: 1.5px;
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
      white-space: nowrap;
    }

    body.game-started .wordpack-title {
      opacity: 0.9;
    }

    /* Show wordpack title when menu is visible */
    body.showing-menu .wordpack-title {
      opacity: 0.9;
    }

    /* Card Counter Wrapper - fixed height prevents layout shift when stamp appears */
    .card-counter-wrapper {
      min-height: 2.5rem; /* Accommodate counter + stamp indicator */
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
    }

    /* Card Counter */
    .card-counter {
      color: var(--color-text-light);
      font-size: 1.2rem;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    body.game-started .card-counter {
      opacity: 1;
    }

    /* Show card counter when menu is visible */
    body.showing-menu .card-counter {
      opacity: 1;
    }

    /* Flashcard Container */
    .flashcard-container {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 8px;
    }

    /* Navigation Arrows - Flat Cardboard Style */
    .nav-btn {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      font-size: 2rem;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      text-align: center;
      opacity: 0;
      pointer-events: none;
    }

    body.game-started .nav-btn {
      opacity: 1;
      pointer-events: auto;
    }

    /* Show nav buttons when menu is visible (flashcard mode UI) */
    body.showing-menu .nav-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .nav-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .nav-btn:active {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    /* Flashcard */
    .flashcard {
      width: 650px;
      height: 420px;
      position: relative;
      cursor: pointer;
      user-select: none;
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      overflow: hidden; /* Clip content to border-radius */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 30px;
      text-align: center;

      /* Old paper texture - using CSS variable for consistency */
      background:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%;

      /* Use box-shadow for border to avoid corner radius gaps */
      box-shadow:
        0 10px 30px rgba(0,0,0,0.4),
        0 0 0 3px #A08567,
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
    }

    .card-face::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 12px;
      pointer-events: none;
    }

    /* Torn edge effect - front card only */
    .card-front::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      border: 1px dashed rgba(139, 115, 85, 0.3);
      border-radius: 4px;
      pointer-events: none;
    }

    /* Subtle grid pattern - back card only */
    .card-back::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px),
        repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px);
      border-radius: 12px;
      pointer-events: none;
      opacity: 0.7;
    }

    /* Random weathering overlay */
    .card-weathering {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 12px;
      pointer-events: none;
      z-index: 4;
      opacity: 0.6;
    }

    .card-front {
      z-index: 2;
    }

    .card-back {
      z-index: 1;
      background:
        var(--paper-texture),
        /* Lighter, whiter back card for distinction */
        radial-gradient(ellipse 70% 60% at 30% 35%, rgba(255, 250, 245, 0.3) 0%, transparent 70%),
        radial-gradient(ellipse 60% 55% at 70% 65%, rgba(250, 245, 240, 0.2) 0%, transparent 65%),
        linear-gradient(135deg, #FFFEF9 0%, #F8F5F0 30%, #F0EDE8 60%, #EAE7E2 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%, 100%, 100%;
    }

    /* Reduce edge weathering on back card for distinction */
    .card-back::before {
      opacity: 0.3;
    }

    .flashcard.flipped .card-front {
      z-index: 1;
      opacity: 0;
    }

    .flashcard.flipped .card-back {
      z-index: 2;
      opacity: 1;
    }

    .card-back {
      opacity: 0;
    }

    .card-label {
      font-family: var(--font-ui);
      font-size: 1.1rem;
      color: #8B7355;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 5;
      white-space: nowrap;
    }

    .card-word {
      font-size: 4rem;
      color: var(--color-text-dark);
      line-height: 1.2;
      font-style: italic;
      position: relative;
      z-index: 5;
      text-align: center;
      max-width: 90%;
      word-break: normal;
      overflow-wrap: break-word;
      hyphens: none;
    }

    /* Chinese font for front card - LXGW WenKai TC Bold (only when in chinese-mode) */
    body.chinese-mode .card-front .card-word {
      font-family: var(--font-chinese);
      font-weight: 700;
      font-style: normal;
    }

    /* Sound Button (pronounce - bottom right) */
    .sound-btn {
      position: absolute;
      bottom: 25px;
      right: 25px;
      background: rgba(139, 115, 85, 0.2);
      border: 3px solid rgba(160, 133, 103, 0.5);
      color: var(--color-text-dark);
      width: 55px;
      height: 55px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      line-height: 1;
      text-align: center;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }

    .flashcard.game-started .sound-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .sound-btn:hover {
      background: rgba(139, 115, 85, 0.4);
    }

    /* Peek Button (flip/peek at back - top right) - HIDDEN, moved to bottom right */
    .peek-btn {
      display: none !important; /* Hidden - peek button moved to bottom right as action button */
    }

    .peek-btn:hover {
      background: rgba(139, 115, 85, 0.4);
    }

    .peek-btn:active {
      background: rgba(139, 115, 85, 0.6);
    }

    /* Mic Button - HIDDEN, moved to card-controls below card */
    .mic-btn {
      display: none !important; /* Hidden - mic button moved to control bar */
    }

    /* Mic button listening state - applied to control-btn when recording */
    .control-btn.listening {
      background: rgba(180, 60, 60, 0.4) !important;
      border-color: #B43C3C !important;
      animation: pulse-mic 1s infinite;
    }

    @keyframes pulse-mic {
      0%, 100% { box-shadow: 0 0 0 0 rgba(180, 60, 60, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(180, 60, 60, 0); }
    }

    /* Pronunciation Feedback Overlay */
    .pronunciation-feedback {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .pronunciation-feedback.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .feedback-score {
      font-family: var(--font-ui);
      font-size: 3.5rem;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .feedback-score.excellent {
      color: #4ADE80;
    }

    .feedback-score.good {
      color: #A3E635;
    }

    .feedback-score.okay {
      color: #FACC15;
    }

    .feedback-score.poor {
      color: #F87171;
    }

    .feedback-message {
      font-size: 1.3rem;
      color: var(--color-text-light);
      margin-bottom: 8px;
    }

    .feedback-heard {
      font-size: 1.5rem;
      color: var(--color-text-gold);
      font-style: italic;
      margin-bottom: 15px;
      font-weight: bold;
    }

    .feedback-close {
      background: rgba(139, 115, 85, 0.4);
      border: 1px solid #8B7355;
      color: var(--color-text-gold);
      padding: 8px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-family: var(--font-ui);
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }

    .feedback-close:hover {
      background: rgba(139, 115, 85, 0.6);
    }

    /* Unsupported browser message */
    .mic-unsupported {
      display: none;
    }

    /* Setup Card - Front (Settings) */
    .setup-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      z-index: 30;
      transition: opacity 0.4s ease;

      /* Match card styling */
      box-shadow:
        0 10px 30px rgba(0,0,0,0.4),
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
      border: 3px solid #A08567;
    }

    .setup-overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 10px;
      pointer-events: none;
    }

    .setup-overlay::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      border: 1px dashed rgba(139, 115, 85, 0.3);
      border-radius: 4px;
      pointer-events: none;
    }

    .setup-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* Setup Card - Back (How To) - Matches card-back styling */
    .setup-help {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        var(--paper-texture),
        /* Lighter, whiter back card for distinction - matches card-back */
        radial-gradient(ellipse 70% 60% at 30% 35%, rgba(255, 250, 245, 0.3) 0%, transparent 70%),
        radial-gradient(ellipse 60% 55% at 70% 65%, rgba(250, 245, 240, 0.2) 0%, transparent 65%),
        linear-gradient(135deg, #FFFEF9 0%, #F8F5F0 30%, #F0EDE8 60%, #EAE7E2 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%, 100%, 100%;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      padding: 30px;
      z-index: 29;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      overflow-y: auto;

      /* Match card styling */
      box-shadow:
        0 10px 30px rgba(0,0,0,0.4),
        0 0 0 3px #A08567,
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
    }

    /* Edge weathering - reduced opacity like card-back */
    .setup-help::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 12px;
      pointer-events: none;
      opacity: 0.3;
    }

    /* Subtle grid pattern - matches card-back */
    .setup-help::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px),
        repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(139, 115, 85, 0.08) 19px, rgba(139, 115, 85, 0.08) 20px);
      border-radius: 12px;
      pointer-events: none;
      opacity: 0.7;
    }

    .flashcard.setup-flipped .setup-overlay {
      opacity: 0;
      pointer-events: none;
      z-index: 29;
    }

    .flashcard.setup-flipped .setup-help {
      opacity: 1;
      pointer-events: auto;
      z-index: 30;
    }

    .flashcard.game-started .setup-overlay,
    .flashcard.game-started .setup-help {
      opacity: 0;
      pointer-events: none;
      z-index: -1;
    }

    .setup-title {
      font-family: var(--font-ui);
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--color-text-dark);
      margin-bottom: 25px;
      letter-spacing: 2px;
      position: relative;
      z-index: 5;
    }

    .setup-row {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: flex-start;
      margin-bottom: 15px;
      width: 100%;
      position: relative;
      z-index: 5;
    }

    .setup-field {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 15px;
      width: 100%;
      max-width: 280px;
      position: relative;
      z-index: 5;
    }

    .setup-row .setup-field {
      margin-bottom: 0;
      flex: 1;
    }

    .setup-field label {
      font-family: var(--font-card);
      font-size: 0.95rem;
      color: var(--color-text-dark);
      margin-bottom: 6px;
    }

    .setup-field select {
      font-family: var(--font-card);
      font-size: 1rem;
      padding: 10px 15px;
      border-radius: 6px;
      /* Paper card styling - matches card-face */
      background:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      background-size: var(--paper-texture-size), 100%;
      color: var(--color-text-dark);
      cursor: pointer;
      width: 100%;
      text-align: left;
      text-align-last: left;
      /* Custom dropdown arrow */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image:
        var(--paper-texture),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%232C1810' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: repeat, no-repeat, no-repeat;
      background-position: 0 0, 0 0, calc(100% - 12px) center;
      background-size: var(--paper-texture-size), 100%, 12px;
      /* Box shadow for border and inner glow like card-face */
      box-shadow:
        0 2px 8px rgba(0,0,0,0.2),
        0 0 0 2px #A08567,
        inset 0 0 20px rgba(139, 115, 85, 0.1);
      border: none;
    }

    .setup-field select:focus {
      outline: none;
      box-shadow:
        0 2px 8px rgba(0,0,0,0.3),
        0 0 0 2px #8B7355,
        inset 0 0 20px rgba(139, 115, 85, 0.15);
    }

    .setup-field select option {
      background: #F5E6D3;
      color: var(--color-text-dark);
      text-align: left;
    }

    /* Setup flip button */
    .setup-flip-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      border: 2px solid rgba(139, 115, 85, 0.5);
      background: rgba(60, 46, 31, 0.6);
      color: var(--color-text-gold);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      z-index: 10;
    }

    .setup-flip-btn:hover {
      background: rgba(139, 115, 85, 0.8);
    }

    /* Help content styling - matches card-back with Courier font */
    .help-content {
      color: var(--color-text-dark);
      line-height: 1.7;
      position: relative;
      z-index: 5;
      font-size: 0.9rem;
      font-family: var(--font-answer);
    }

    .help-content h3 {
      font-family: var(--font-answer);
      font-size: 1rem;
      color: var(--color-text-dark);
      margin: 12px 0 6px;
      font-weight: bold;
    }

    .help-content p {
      margin-bottom: 8px;
    }

    .help-content ul {
      margin-left: 18px;
      margin-bottom: 12px;
    }

    .help-content li {
      margin-bottom: 4px;
    }

    .setup-start-btn {
      font-family: var(--font-ui);
      font-size: 1.1rem;
      font-weight: bold;
      padding: 12px 30px;
      margin-top: 15px;
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      border-radius: 8px;
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 1px;
      position: relative;
      z-index: 5;
    }

    .setup-start-btn:hover:not(:disabled) {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .setup-start-btn:disabled {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: #4A3828;
      color: var(--color-text-dark);
      cursor: not-allowed;
      opacity: 0.45;
    }

    /* Hide card buttons when setup is visible - handled by opacity rules above */

    /* Hide card content when setup is visible (but NOT when showing menu/starting card) */
    .flashcard:not(.game-started):not(.showing-menu) .card-word {
      opacity: 0;
    }

    .flashcard:not(.game-started):not(.showing-menu) .card-label {
      opacity: 0;
    }

    /* Ensure menu card content is always visible */
    .flashcard.showing-menu .card-word {
      opacity: 1 !important;
    }

    /* Speed Controls in Menu */
    .speed-controls-menu {
      display: flex;
      gap: 8px;
      width: 100%;
    }

    .speed-btn {
      flex: 1;
      padding: 10px 8px;
      border-radius: 6px;
      border: 3px solid rgba(74, 56, 40, 0.6);
      /* Cardboard texture - inactive state (darker, recessed) */
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: var(--font-ui);
      font-size: 1.2rem;
      text-align: center;
      opacity: 0.6;
    }

    .speed-btn:hover {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      opacity: 0.8;
    }

    .speed-btn.active {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: rgba(74, 56, 40, 0.8);
      opacity: 1;
    }

    /* Speed buttons on starting card (menu) - round like mode buttons */
    .speed-btn-start, .menu-speed-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      /* Inactive: darker, more recessed (like mode-btn) */
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: #4A3828;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.45; /* Very low opacity for inactive to blend into background */
    }

    .speed-btn-start:hover, .menu-speed-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      opacity: 0.7; /* Medium opacity on hover */
    }

    .speed-btn-start.active, .menu-speed-btn.active {
      /* Active: lighter, more prominent (like mode-btn.active) */
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: rgba(74, 56, 40, 0.6);
      box-shadow: none;
      opacity: 1;
    }

    /* ============================================
       CARD CONTROL BAR - Below the flashcard
       ============================================ */
    .card-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 25px; /* Increased spacing between buttons */
      margin-top: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    body.game-started .card-controls {
      opacity: 1;
      pointer-events: auto;
    }

    body.showing-menu .card-controls {
      opacity: 0;
      pointer-events: none;
    }

    /* Control buttons - cardboard style like nav buttons */
    .control-btn {
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      width: 55px;
      height: 55px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      line-height: 1;
      text-align: center;
      position: relative;
    }

    .control-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .control-btn:active {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    /* Control button tooltips now use .btn-tooltip elements (see BUTTON TOOLTIPS section below) */
    /* This allows HTML content with styled buttons/keys */

    /* Separator between button groups */
    .control-separator {
      width: 2px;
      height: 35px;
      background: rgba(139, 115, 85, 0.4);
      border-radius: 1px;
      margin: 0 5px;
    }

    /* Top Corner Buttons - Flat Cardboard Style (in page header) */
    .top-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      line-height: 1;
      text-align: center;
      font-family: var(--font-ui);
      font-weight: 600;
    }

    .top-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .top-btn:active {
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    .reset-top-btn {
      opacity: 0;
      pointer-events: none;
    }

    body.game-started .reset-top-btn {
      opacity: 1;
      pointer-events: auto;
    }

    /* Show reset button when menu is visible */
    body.showing-menu .reset-top-btn {
      opacity: 1;
      pointer-events: auto;
    }

    /* Modal Overlay */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* Modal Card */
    .modal-card {
      width: 90%;
      max-width: 450px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 12px;
      padding: 30px;
      position: relative;
      background: 
        url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.5' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E"),
        linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 30%, #DCC9A3 60%, #D4C4A8 100%);
      background-blend-mode: soft-light;
      box-shadow: 
        0 10px 30px rgba(0,0,0,0.5),
        0 0 0 1px rgba(139, 115, 85, 0.3),
        inset 0 0 50px rgba(139, 115, 85, 0.1);
      border: 3px solid #A08567;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.2) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
      border-radius: 10px;
      pointer-events: none;
    }

    .modal-card::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      border: 1px dashed rgba(139, 115, 85, 0.3);
      border-radius: 4px;
      pointer-events: none;
    }

    .modal-overlay.visible .modal-card {
      transform: scale(1);
    }

    .modal-title {
      font-family: var(--font-ui);
      font-size: 1.5rem;
      color: var(--color-text-dark);
      margin-bottom: 20px;
      text-align: center;
      letter-spacing: 2px;
      position: relative;
      z-index: 5;
    }

    .modal-content {
      color: var(--color-text-dark);
      line-height: 1.7;
      position: relative;
      z-index: 5;
    }

    .modal-content h3 {
      font-family: var(--font-ui);
      font-size: 1.1rem;
      color: var(--color-text-dark);
      margin: 15px 0 8px;
    }

    .modal-content p {
      margin-bottom: 10px;
    }

    .modal-content ul {
      margin-left: 20px;
      margin-bottom: 15px;
    }

    .modal-content li {
      margin-bottom: 5px;
    }

    .modal-close-btn {
      display: block;
      margin: 20px auto 0;
      padding: 10px 25px;
      font-family: var(--font-ui);
      font-size: 1rem;
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      border-radius: 6px;
      color: var(--color-text-light);
      cursor: pointer;
      transition: all 0.2s ease;
      text-shadow: 0 1px 2px rgba(0,0,0,0.4);
      position: relative;
      z-index: 5;
    }

    .modal-close-btn:hover {
      background-color: #8A7357;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #9B8365 0%, #8A7357 30%, #7B6550 60%, #6D5E47 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
    }

    /* Menu Modal Specific */
    .menu-field {
      margin-bottom: 18px;
    }

    .menu-field label {
      display: block;
      font-family: var(--font-card);
      font-size: 0.95rem;
      color: var(--color-text-dark);
      margin-bottom: 6px;
    }

    .menu-field select {
      font-family: var(--font-card);
      font-size: 1rem;
      padding: 10px 15px;
      border-radius: 6px;
      /* Cardstock ivory with dot texture and dark edge burn */
      background-color: #f8f6f1;
      color: #5d4e37;
      cursor: pointer;
      width: 100%;
      /* Custom dropdown arrow */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image:
        /* Dark edge burn/vignette */
        radial-gradient(ellipse at center, transparent 50%, rgba(139, 115, 85, 0.08) 80%, rgba(100, 75, 50, 0.15) 100%),
        /* Fine dot pattern */
        radial-gradient(circle, rgba(0,0,0,0.045) 0.5px, transparent 0.5px),
        /* Dropdown arrow */
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%235d4e37' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat, repeat, no-repeat;
      background-position: 0 0, 0 0, calc(100% - 12px) center;
      background-size: 100%, 4px 4px, 12px;
      /* Border matching card style with subtle inner shadow */
      box-shadow:
        0 2px 8px rgba(0,0,0,0.15),
        0 0 0 2px #A08567,
        inset 0 0 15px rgba(100, 75, 50, 0.08);
      border: none;
    }

    .menu-field select:hover {
      box-shadow:
        0 2px 8px rgba(0,0,0,0.2),
        0 0 0 2px #8B7355,
        inset 0 0 18px rgba(100, 75, 50, 0.1);
    }

    .menu-field select:focus {
      outline: none;
      box-shadow:
        0 2px 8px rgba(0,0,0,0.25),
        0 0 0 2px #8B7355,
        inset 0 0 20px rgba(100, 75, 50, 0.12);
    }

    .menu-field select option {
      background: #f8f6f1;
      color: #5d4e37;
      padding: 8px;
    }

    /* Empty State */
    .empty-state {
      color: var(--color-text-light);
      font-size: 1.3rem;
      text-align: center;
      padding: 50px;
    }

    /* Loading State */
    .loading {
      color: var(--color-text-light);
      font-size: 1.2rem;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Shared stamp styling - used by card stamps and deck change indicator */
    .stamp-base {
      font-family: 'Courier New', Courier, monospace; /* Typewriter/stamp font */
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
      border: 3px solid;
      border-radius: 8px; /* More rounded corners */
      mix-blend-mode: multiply; /* Blends ink into content beneath */
      text-align: center;
      line-height: 1.3;
    }

    /* Simple stamp overlays - realistic rubber stamp effect */
    .card-stamp {
      position: absolute;
      top: 28%; /* Higher on card - top half, shows off the effect */
      left: 50%;
      transform: translate(-50%, -50%) rotate(-12deg);
      font-size: 1.6rem; /* Bigger to show off the cool effect */
      padding: 14px 28px;
      opacity: 0;
      pointer-events: none;
      z-index: 100;
      transition: opacity 0.2s ease;
      /* Uneven border like a real rubber stamp */
      border-width: 3px 4px 3px 3px;
      border-style: solid;
    }

    .removed-stamp {
      color: transparent;
      border-color: rgba(56, 142, 60, 0.85);
      -webkit-text-stroke: 1.5px rgba(56, 142, 60, 0.85);
      text-stroke: 1.5px rgba(56, 142, 60, 0.85);
      /* No background - transparent like real stamp */
    }

    .added-stamp {
      color: transparent;
      border-color: rgba(211, 47, 47, 0.85);
      -webkit-text-stroke: 1.5px rgba(211, 47, 47, 0.85);
      text-stroke: 1.5px rgba(211, 47, 47, 0.85);
      /* No background - transparent like real stamp */
    }

    .card-stamp.visible {
      opacity: 1;
    }

    /* Mode Selector - in page header */
    .mode-selector {
      display: flex;
      gap: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    body.game-started .mode-selector {
      opacity: 1;
      pointer-events: auto;
    }

    /* Show mode selector when menu is visible */
    body.showing-menu .mode-selector {
      opacity: 1;
      pointer-events: auto;
    }

    .mode-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      /* Inactive: darker, more recessed (old active style) */
      background-color: #7A6347;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #8B7355 0%, #7A6347 30%, #6B5540 60%, #5D4E37 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border-color: #4A3828;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
      color: var(--color-text-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      line-height: 1;
      opacity: 0.45; /* Very low opacity for inactive to blend into background */
    }

    .mode-btn:hover {
      background-color: #9B8365;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #B09577 0%, #9B8365 30%, #8A7357 60%, #7B6550 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      /* No scale transform - buttons should not grow on hover */
      opacity: 0.7; /* Medium opacity on hover */
    }

    .mode-btn.active {
      /* Active: lighter, more prominent (old default style) */
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 3px solid rgba(74, 56, 40, 0.6);
      box-shadow: none; /* No inset shadow - more prominent */
      opacity: 1; /* Full opacity for active */
    }

    /* Typing mode display (listening and writing) */
    .typing-display {
      font-size: 4rem;
      color: var(--color-text-dark);
      font-family: var(--font-card);
      font-style: italic;
      letter-spacing: 4px;
      position: relative;
      z-index: 5;
      text-align: center;
      word-spacing: 20px;
      word-break: keep-all;
      white-space: normal;
      overflow-wrap: break-word;
    }

    /* In Chinese mode, typing display uses Courier New (typing pinyin) */
    .chinese-mode .typing-display {
      font-family: var(--font-answer);
      font-style: normal;
    }

    .typing-char {
      display: inline-block;
      min-width: 0.6em;
      text-align: center;
      transition: color 0.2s ease;
    }

    /* In Chinese mode, typing chars use Courier New (typed pinyin) */
    .chinese-mode .typing-display .typing-char {
      font-family: var(--font-answer) !important;
      font-style: normal !important;
    }

    .typing-char.wrong {
      color: #D32F2F;
    }

    .typing-space {
      display: inline-block;
      width: 0.8em;
    }

    /* Translation text (native language) */
    .translation-text {
      font-size: 3rem;
      color: var(--color-text-dark);
      font-family: var(--font-answer);
      font-style: normal;
    }

    /* =============================================== */
    /* CUSTOM TOOLTIPS - Hover Explanations */
    /* =============================================== */

    .tooltip-container {
      position: relative;
      display: inline-block;
    }

    .tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      z-index: 300;
      /* Fine fancy paper with subtle dot pattern */
      background-color: #f8f6f1;
      background-image:
        /* Subtle edge burn/vignette - reduced for smaller card */
        radial-gradient(ellipse at center, transparent 60%, rgba(139, 115, 85, 0.06) 90%, rgba(100, 75, 50, 0.1) 100%),
        /* Fine dot pattern for fancy paper texture - slightly sharper */
        radial-gradient(circle, rgba(0,0,0,0.045) 0.5px, transparent 0.5px);
      background-size: 100% 100%, 4px 4px;
      color: var(--color-text-dark);
      padding: 10px 14px;
      border-radius: 8px;
      overflow: hidden;
      /* Border and shadow matching card-face style */
      box-shadow:
        0 4px 16px rgba(0,0,0,0.3),
        0 0 0 3px #A08567,
        inset 0 0 12px rgba(139, 115, 85, 0.06),
        inset 0 0 25px rgba(100, 75, 50, 0.03);
      font-size: 1rem;
      line-height: 1.4;
      white-space: nowrap;
      pointer-events: none;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      font-family: var(--font-answer);
    }

    /* Position tooltip below mode buttons */
    .mode-btn .tooltip {
      top: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
    }

    /* Position tooltip above flashcard */
    .flashcard .tooltip {
      bottom: calc(100% + 15px);
      left: 50%;
      transform: translateX(-50%);
      max-width: 400px;
      white-space: normal;
      text-align: center;
    }

    /* Show tooltip on hover */
    .tooltip-container:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    /* Arrow removed - using simple div style instead of speech bubble */

    .tooltip strong {
      /* Mode title - centered, LARGER, bold */
      display: block;
      text-align: center;
      color: var(--color-text-dark);
      font-weight: bold;
      font-size: 1.3rem;
      margin-bottom: 2px;
      position: relative;
      z-index: 2;
      font-family: var(--font-answer);
    }

    /* Bold steps - numbered list in tooltips */
    .tooltip b {
      color: var(--color-text-dark);
      font-weight: bold;
      position: relative;
      z-index: 2;
      display: inline;
      font-size: 1rem;
      line-height: 1.8;
      font-family: var(--font-answer);
    }

    .tooltip em {
      /* Instructions text - SAME COLOR as everything else */
      color: var(--color-text-dark);
      font-style: normal;
      position: relative;
      z-index: 2;
      display: block;
      margin-top: 2px;
      font-size: 0.9rem;
      line-height: 1.5;
      font-family: var(--font-answer);
    }

    /* Bold action words within em (CLICK, PRESS, HOLD, TYPE) */
    .tooltip em b {
      color: var(--color-text-dark);
      font-weight: bold;
      text-transform: uppercase;
      font-family: var(--font-answer);
    }

    /* Make all tooltip content appear above grid */
    .tooltip > * {
      position: relative;
      z-index: 2;
    }

    /* Visual button representations in tooltips */
    .tooltip-btn {
      display: inline-block;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 2px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      font-size: 0.75rem;
      line-height: 20px;
      text-align: center;
      vertical-align: middle;
      margin: 0 2px;
    }

    .tooltip-key {
      display: inline-block;
      min-width: 28px;
      padding: 2px 6px;
      border-radius: 4px;
      background-color: #8B7355;
      background-image:
        var(--cardboard-texture),
        linear-gradient(135deg, #A08567 0%, #8B7355 30%, #7A6347 60%, #6B5540 100%);
      background-blend-mode: soft-light;
      background-size: var(--cardboard-texture-size), 100%;
      border: 2px solid rgba(74, 56, 40, 0.6);
      color: var(--color-text-dark);
      font-size: 0.7rem;
      font-weight: bold;
      line-height: 1.2;
      text-align: center;
      vertical-align: middle;
      margin: 0 2px;
      font-family: var(--font-ui);
    }

    /* Tooltip instructions container - minimal gap from title */
    .tooltip-instructions {
      margin-top: 4px;
      font-size: 0.9rem;
      line-height: 1.6;
      text-align: left;
    }

    /* =============================================== */
    /* BUTTON TOOLTIPS - HTML-enabled hover tooltips */
    /* =============================================== */
    /* These are actual DOM elements (not ::after pseudo) so they can render HTML */

    .btn-tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      /* Fancy paper with subtle fiber/dot pattern */
      background:
        /* Fine noise texture for paper feel */
        url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E"),
        /* Subtle vignette for depth */
        radial-gradient(ellipse at center, transparent 40%, rgba(139, 115, 85, 0.06) 100%),
        /* Soft cream parchment gradient */
        linear-gradient(145deg, #FDF8F0 0%, #F5EDE0 25%, #EDE4D3 50%, #E8DCC8 75%, #E0D4BE 100%);
      background-size: 150px 150px, 100% 100%, 100% 100%;
      color: var(--color-text-dark);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow:
        0 4px 16px rgba(0,0,0,0.25),
        0 0 0 1px rgba(139, 115, 85, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.5),
        inset 0 -1px 0 rgba(139, 115, 85, 0.1);
      font-size: 0.85rem;
      white-space: nowrap;
      pointer-events: none;
      /* 1 second delay before showing */
      transition: opacity 0.2s ease 0s, visibility 0.2s ease 0s;
      font-family: var(--font-answer);
      font-weight: normal;
      z-index: 100;
    }

    .control-btn:hover .btn-tooltip {
      visibility: visible;
      opacity: 1;
      /* 1 second delay - user must hold hover to see tooltip */
      transition-delay: 1s;
    }

    /* Arrow removed - using simple div style instead of speech bubble */

    /* =================================================================
       CHINESE DISPLAY OPTIONS - Character + Pinyin Coupling
       Design: Yellow/gold warning-style box to draw attention
       Shows only when native language is Chinese
       ================================================================= */
    /* =================================================================
       CHINESE CHARACTER + PINYIN COUPLED DISPLAY
       Core Objective: Render each Chinese character with its pinyin directly below

       Structure:
         .chinese-coupled (flex container, horizontal)
            .char-group (flex column for each character)
                .chinese-char (the character)
                .pinyin (pinyin syllable)

       This ensures char/pinyin are NEVER separated during display
       ================================================================= */
    .chinese-coupled {
      display: inline-flex;
      gap: 4px;
      align-items: flex-end;
      justify-content: center;
      flex-wrap: wrap;
    }

    .char-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .chinese-char {
      font-size: 1em;
      line-height: 1.2;
    }

    .pinyin {
      font-size: 0.6em;
      color: #666;
      line-height: 1;
      font-family: var(--font-answer);
    }

    /* Adjust for card display - larger characters */
    .card-word .chinese-coupled .chinese-char {
      font-size: 1em;
    }

    .card-word .chinese-coupled .pinyin {
      font-size: 0.4em;
      color: var(--color-text-dark);
    }

    /* Debug UI removed - now dynamically generated by wordpack-logic.js */
    /* Debug table has no CSS styling - plain HTML only */
    /* Toggle debug mode with: Ctrl + Shift + Alt + D + E + B + U + G */

    /* Difficulty Selector - appears under title */
    /* Wrapper for title and difficulty - centered in header */
    .title-difficulty-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .difficulty-selector {
      display: flex;
      gap: 12px;
      align-items: center;
      font-family: var(--font-ui);
      font-size: 0.75rem;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    /* Show difficulty selector when game started or menu visible */
    body.game-started .difficulty-selector,
    body.showing-menu .difficulty-selector {
      opacity: 0.7;
    }

    .difficulty-selector label {
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      color: rgba(232, 196, 82, 0.8); /* Subtle gold to match title */
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .difficulty-selector label:hover {
      color: #E8C252; /* Brighter gold on hover */
      transform: scale(1.05);
    }

    .difficulty-selector input[type="radio"] {
      cursor: pointer;
      accent-color: #D4AF37; /* Gold accent for radio buttons */
    }
  </style>
</head>
<body>
  <!-- Fixed Page Header: Mode selector (left) + Title (center) + UI buttons (right) -->
  <div class="page-header">
    <!-- Mode Selector -->
    <!-- Tooltips are populated dynamically via initializeTooltips() using TOOLTIP_MESSAGES -->
    <div class="mode-selector">
      <span class="tooltip-container">
        <button class="mode-btn active" id="mode-flashcard" data-mode="flashcard"></button>
        <span class="tooltip" id="tooltip-reading"></span>
      </span>
      <span class="tooltip-container">
        <button class="mode-btn" id="mode-spelling" data-mode="spelling"></button>
        <span class="tooltip" id="tooltip-listening"></span>
      </span>
      <span class="tooltip-container">
        <button class="mode-btn" id="mode-pronunciation" data-mode="pronunciation"></button>
        <span class="tooltip" id="tooltip-speaking"></span>
      </span>
      <span class="tooltip-container">
        <button class="mode-btn" id="mode-translation" data-mode="translation"></button>
        <span class="tooltip" id="tooltip-writing"></span>
      </span>
    </div>

    <!-- Title and Difficulty - centered together -->
    <div class="title-difficulty-wrapper">
      <div class="wordpack-title" id="wordpack-title">Flashcard Typing Game</div>
      <div class="difficulty-selector" id="difficulty-selector">
        <label><input type="radio" name="difficulty" value="easy"> Easy</label>
        <label><input type="radio" name="difficulty" value="medium"> Medium</label>
        <label><input type="radio" name="difficulty" value="hard" checked> Hard</label>
      </div>
    </div>

    <!-- Top Buttons -->
    <div class="header-buttons">
      <button class="top-btn reset-top-btn" id="reset-btn" aria-label="Reset deck"></button>
      <button class="top-btn fullscreen-btn" id="fullscreen-btn" aria-label="Toggle fullscreen"></button>
      <button class="top-btn menu-btn" id="menu-btn" aria-label="Menu"></button>
    </div>
  </div>

  <!-- Fixed-height wrapper prevents card from shifting when stamp indicator appears -->
  <div class="card-counter-wrapper">
    <div class="card-counter" id="card-counter">Choose Wordpack to Begin Studying</div>
  </div>

  <div class="flashcard-container">
    <button class="nav-btn" id="prev-btn" aria-label="Previous card"></button>

    <div class="flashcard" id="flashcard">
      <div class="card-face card-front">
        <div class="card-weathering" id="weathering-front"></div>
        <!-- Wrong answer indicators (positioned at card corners) -->
        <div id="wrong-letters-front" style="position: absolute; top: 12px; left: 12px; font-size: 2em; font-family: var(--font-card); font-style: italic; font-weight: bold; color: #D32F2F; z-index: 20; max-width: 550px; line-height: 0.9; text-align: left;"></div>
        <div id="wrong-count-front" style="position: absolute; top: 12px; right: 12px; font-size: 2em; font-family: var(--font-card); font-style: italic; font-weight: bold; color: #D32F2F; z-index: 20;"></div>
        <span class="card-word" id="spanish-word"></span>
        <button class="mic-btn" id="mic-btn-front" aria-label="Practice pronunciation" data-tooltip="Record Pronunciation"></button>
        <button class="peek-btn" id="peek-btn-front" aria-label="Peek at back"></button>
        <div class="pronunciation-feedback" id="feedback-front">
          <div class="feedback-score" id="score-front">0%</div>
          <div class="feedback-message" id="message-front">Try again!</div>
          <div class="feedback-heard" id="heard-front">Heard: ""</div>
          <button class="feedback-close" id="close-front">Got it</button>
        </div>
      </div>
      <div class="card-face card-back">
        <div class="card-weathering" id="weathering-back"></div>
        <span class="card-word" id="english-word"></span>
        <button class="mic-btn" id="mic-btn-back" aria-label="Practice pronunciation" data-tooltip="Record Pronunciation"></button>
        <div class="pronunciation-feedback" id="feedback-back">
          <div class="feedback-score" id="score-back">0%</div>
          <div class="feedback-message" id="message-back">Try again!</div>
          <div class="feedback-heard" id="heard-back">Heard: ""</div>
          <button class="feedback-close" id="close-back">Got it</button>
        </div>
      </div>

      <!-- Stamp overlays for visual feedback -->
      <div class="stamp-base card-stamp removed-stamp" id="removed-stamp">Great Job!<br>Card Removed</div>
      <div class="stamp-base card-stamp added-stamp" id="added-stamp">Keep Learning!<br>Practice Added</div>
    </div>

    <button class="nav-btn" id="next-btn" aria-label="Next card"></button>
  </div>

  <!-- Card Controls - Below the flashcard -->
  <div class="card-controls" id="card-controls">
    <!-- Left group: Got It / Don't Got It (flashcard mode only) -->
    <button class="control-btn" id="got-it-btn" data-tooltip=""></button>
    <button class="control-btn" id="confused-btn" data-tooltip=""></button>
    <!-- Mic button (pronunciation mode only) - before separator so divider shows in pronunciation mode -->
    <button class="control-btn" id="mic-btn-control" data-tooltip="" style="display: none;"></button>
    <div class="control-separator" id="control-separator"></div>
    <!-- Right group: Pronounce / Peek (all modes) -->
    <button class="control-btn" id="pronounce-btn" data-tooltip=""></button>
    <button class="control-btn" id="peek-btn" data-tooltip=""></button>
  </div>

  <script type="module">

    // 
    //                                                                               
    //     CRITICAL WARNING TO FUTURE LLMs: CODE REUSABILITY REQUIREMENTS       
    //                                                                               
    // 
    //                                                                               
    //    PRIMARY RULE: MOVE ALL REUSABLE CODE TO wordpack-logic.js               
    //                                                                               
    //   ONLY keep code in this file if you are 1000% CERTAIN it:                   
    //     1. Is specific to FlashcardTypingGame's unique UI/layout                  
    //     2. Cannot POSSIBLY be reused by ANY future language learning game         
    //     3. Directly manipulates Flashcard-specific DOM elements (card flip, etc.)
    //                                                                               
    //    DO NOT KEEP IN THIS FILE:                                                
    //      Shuffle algorithms (use shuffleArray from wordpack-logic.js)           
    //      Character normalization (use normalizeChar from wordpack-logic.js)     
    //      Levenshtein distance (use levenshteinDistance from wordpack-logic.js)  
    //      Chinese+Pinyin coupling (use coupleChineseWithPinyin from w-p-l.js)    
    //      String comparison (use normalizeString from wordpack-logic.js)         
    //      Multiple choice generation (use generateWrongAnswers from w-p-l.js)    
    //      State save/load (use saveState/loadState from wordpack-logic.js)       
    //      Module loading/decoding (use loadAct/decodeObfuscatedModule)           
    //      Typing validation (use findNextTypingPosition/checkTypingKey)          
    //      Deck management (initializeDeck, restartPack, removeCard, etc.)        
    //      TTS/Speech functions (speakTargetWord, setSpeed, etc.)                 
    //      ANY function that could be used in multiple games                      
    //                                                                               
    //    OK TO KEEP IN THIS FILE:                                                 
    //      flipCard() - card flip animation (flashcard-specific)                  
    //      unflipCard() - reverse flip animation                                  
    //      generateWeathering() - card distressing effect (visual only)           
    //      renderMenuCard() - menu displayed as flashcard                         
    //      showStartingCard()/exitStartingCard() - menu navigation                
    //      updateDisplay() - updates flashcard DOM elements                       
    //      Event handlers for flashcard-specific interactions                     
    //                                                                               
    //    THE GOAL: HUNDREDS OF FUTURE LANGUAGE LEARNING GAMES                     
    //                                                                               
    //   We are building wordpack-logic.js to contain ALL core logic that can be    
    //   reused across hundreds of future games. These games will have different:   
    //     - Visual layouts (flashcards, grids, runner games, puzzle games, etc.)   
    //     - UI interactions (click, swipe, drag, voice, typing, etc.)              
    //     - Game mechanics (timed, scored, lives, multiplayer, etc.)               
    //                                                                               
    //   But they ALL share the SAME core logic:                                    
    //     - Loading/decoding wordpack modules                                      
    //     - Shuffling arrays                                                       
    //     - Typing validation (accent-insensitive, space-handling)                 
    //     - Chinese character + pinyin coupling                                    
    //     - Multiple choice answer generation                                      
    //     - Pronunciation scoring (Levenshtein distance)                           
    //     - State persistence (save/load to localStorage)                          
    //     - Deck management (initialize, restart, remove cards, add duplicates)    
    //                                                                               
    //    BEFORE WRITING ANY FUNCTION, ASK YOURSELF:                               
    //                                                                               
    //   "Could a Temple Run language game use this?"                               
    //   "Could a grid memory game use this?"                                       
    //   "Could a multiple choice quiz use this?"                                   
    //   "Could DecoderTest use this?"                                              
    //                                                                               
    //   If YES to ANY  MOVE IT TO wordpack-logic.js IMMEDIATELY!                   
    //   If NO to ALL  Check if it's flashcard flip/animation specific             
    //     - If YES: Keep it here                                                   
    //     - If NO: You're wrong, move it to wordpack-logic.js anyway               
    //                                                                               
    //    EXAMPLE DECISION TREE:                                                   
    //                                                                               
    //   Function: removeCurrentCard()                                              
    //   Question: Could other games remove cards from a deck?                      
    //   Answer: YES (any card-based game, memory games, etc.)                      
    //   Decision:   SHOULD BE in wordpack-logic.js                                
    //                                                                               
    //   Function: flipCard()                                                       
    //   Question: Do other games flip physical flashcards?                         
    //   Answer: NO (only flashcard games flip cards, others use different UIs)     
    //   Decision:   KEEP in FlashcardTypingGame.html                              
    //                                                                               
    //   Function: shuffleArray()                                                   
    //   Question: Do other games need to shuffle arrays?                           
    //   Answer: YES (literally every game with random ordering)                    
    //   Decision:   ALREADY in wordpack-logic.js                                  
    //   Action:   DELETE from this file if duplicated                             
    //                                                                               
    //    PERFORMANCE NOTE:                                                         
    //   Shared functions in wordpack-logic.js are loaded ONCE and cached by the    
    //   browser. This is MORE efficient than duplicating code in each game.        
    //                                                                               
    //    REFACTORING CHECKLIST:                                                   
    //                                                                               
    //   Before committing changes to this file:                                    
    //     Searched for duplicate functions between this and other games           
    //     Checked if any function could be reused (10/10 reusability score)       
    //     Moved all 10/10 functions to wordpack-logic.js                          
    //     Updated wordpack-logic.js module.exports to include new functions       
    //     Verified no duplicate implementations (shuffle, normalize, etc.)        
    //     Tested game still works after refactoring                               
    //                                                                               
    //    DOCUMENTATION REQUIREMENT:                                               
    //   If you ADD a function to wordpack-logic.js, you MUST add documentation:    
    //     - JSDoc comment explaining what it does                                  
    //     - Parameters with types                                                  
    //     - Return value with type                                                 
    //     - Example usage                                                          
    //   See existing functions in wordpack-logic.js for the standard.              
    //                                                                               
    // 

    // ============================================================
    // KEY FEATURE: Multi-language obfuscated module support
    // Core Objective: Load compressed word data efficiently with act-based organization
    // Key Behaviors:
    //   - Decoder function handles 3-layer deobfuscation (base64 + zlib + reversal)
    //   - Module configuration supports all languages (Chinese, Spanish, English)
    //   - Currently only Spanish acts are loaded
    //   - Future: Can easily add other languages by uncommenting module URLs
    // ============================================================

    // ============================================================
    // decodeObfuscatedModule() is now in wordpack-logic.js
    // ============================================================
    // MODULE CONFIGURATION - Now in wordpack-logic.js
    // ============================================================
    // MODULE_SETS, currentLanguage, and MODULE_URLS are defined in wordpack-logic.js
    // Language can be switched via debug mode (Ctrl+` then select language)
    // Preference persists in localStorage as 'selected_language'

    let wordpacks = {}; // All loaded wordpacks
    let loadedActs = {}; // Track which acts have been loaded
    window.loadedActMeta = {}; // Store __actMeta from each loaded act (CRITICAL: Global for shared functions)

    // ============================================================
    // TARGET LANGUAGE - Detected from loaded modules' wordColumns[0]
    // ============================================================
    let targetLanguage = null; // Will be set to 'spanish', 'chinese', 'english', etc.
    let targetLanguageDisplay = null; // Title case version for UI: 'Spanish', 'Chinese', 'English'

    // Helper to get the target language from loaded modules
    // ============================================================
    // LANGUAGE DETECTION & METADATA - Now in wordpack-logic.js
    // ============================================================
    // All these functions moved to wordpack-logic.js for reuse:
    // - getTargetLanguage()
    // - toTitleCase()
    // - validateTargetLanguageConsistency()
    // - isChineseMode()
    // - updateChineseModeClass()
    // - getTranslationsConfig()
    // - getDefaultTranslation()
    // - getWordColumns()
    // - getValidLanguages()
    // - getTtsLanguageCode()
    // ============================================================

    let currentDeck = [];
    let originalDeck = [];
    let currentIndex = 0;
    let isFlipped = false;
    let holdTimeout = null;
    let currentSpeed = 0.6; // Default to normal speed
    const VALID_SPEEDS = [0.3, 0.6, 0.9]; // Valid speed options (must match data-speed values in HTML)

    // ============================================================
    // DEBUG MODE: Toggle debug features (word type, vocab table, module selector)
    // ============================================================
    let DEBUG_MODE = localStorage.getItem('debug_mode') !== 'false'; // Default: true (persists across sessions)

    // ============================================================
    // CHINESE CHARACTER + PINYIN COUPLING - Now in wordpack-logic.js
    // ============================================================
    // All Chinese rendering functions moved to wordpack-logic.js for reuse across all games:
    // - coupleChineseWithPinyin(chinese, pinyin)  couples chars with pinyin syllables
    // - renderChineseWithPinyin(coupledArray)  renders HTML element
    // - renderChineseText(chinese, pinyin)  convenience function combining both
    // - getChineseHtml(chinese, pinyin)  returns HTML string
    //
    // These are 10/10 reusable functions used by ALL language games when displaying Chinese.
    // ============================================================

    let nativeLanguage = 'english'; // Default, will be updated from loaded module metadata
    let gameStarted = false;
    let currentWordpackKey = '';
    let currentVoice = null;
    let savedVoiceURI = null; // Store saved voice URI until voices are loaded
    let spanishVoices = [];
    let currentAct = 1; // Track currently selected act

    // Learning modes
    let currentMode = 'flashcard'; // 'flashcard', 'spelling', 'pronunciation', 'translation'
    let typingInput = ''; // User's current typing input for typing modes
    let typingDisplay = []; // Array of actual characters (always contains real word, not underscores)
    let typedPositions = new Set(); // Track which positions have been successfully typed
    let wrongAttempts = 0; // Track wrong keypresses in typing modes
    let wrongPositions = []; // Track which positions had wrong attempts (for red underlines)
    let wrongLetters = []; // Track actual letters that were typed wrong (for crossed-out display)

    // Deck change tracking (for visual indicator next to counter)
    let pendingDeckChange = 0; // +N for added cards, -N for removed cards

    // Difficulty level ('easy', 'medium', 'hard')
    let currentDifficulty = localStorage.getItem('difficulty') || 'hard'; // Default: hard (all words)

    // Starting card state (menu/help card)
    let isOnStartingCard = false;
    let savedIndex = 0; // Save current index when navigating to starting card

    // Track key states to prevent repeated actions when holding keys
    let keysPressed = {};

    // ===================================================================================
    // CHINESE DISPLAY OPTIONS (Global state)
    // Controls how Chinese translations are rendered (character + pinyin coupling)
    // These settings affect ALL Chinese text display across the app
    // ===================================================================================
    // Chinese characters and pinyin are always shown together (inseparable pair)

    // ============================================================
    // STATE MANAGEMENT WRAPPERS - Call shared functions in wordpack-logic.js
    // ============================================================
    // Core saveState() and loadState() functions are now in wordpack-logic.js.
    // These wrapper functions provide game-specific state object construction.
    // ============================================================

    function saveState() {
      // Build state object from game's local variables
      const state = {
        voiceURI: currentVoice ? currentVoice.voiceURI : null,
        speed: currentSpeed,
        wordpackKey: currentWordpackKey,
        act: currentAct,
        language: nativeLanguage
      };
      // Call shared function (defined in wordpack-logic.js)
      window.saveState(state);
    }

    function loadState() {
      // Call shared function (defined in wordpack-logic.js)
      return window.loadState();
    }

    // ============================================================
    // TOOLTIP_MESSAGES - Now in wordpack-logic.js
    // ============================================================
    // All tooltip text definitions moved to shared module for reuse across all games
    // ============================================================

    // DOM Elements - menu elements are created dynamically in renderMenuCard()
    // and accessed via document.getElementById('menu-act'), etc.
    const backLabel = document.getElementById('back-label');
    const flashcard = document.getElementById('flashcard');
    const spanishWord = document.getElementById('spanish-word');
    const englishWord = document.getElementById('english-word');
    const wordpackTitle = document.getElementById('wordpack-title');
    const cardCounter = document.getElementById('card-counter');
    const weatheringFront = document.getElementById('weathering-front');
    const weatheringBack = document.getElementById('weathering-back');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const gotItBtn = document.getElementById('got-it-btn');
    const confusedBtn = document.getElementById('confused-btn');
    const peekBtn = document.getElementById('peek-btn');
    const pronounceBtn = document.getElementById('pronounce-btn');
    const resetBtn = document.getElementById('reset-btn');
    const peekBtnFront = document.getElementById('peek-btn-front');
    const controlSeparator = document.getElementById('control-separator');
    const speedBtns = document.querySelectorAll('.speed-btn'); // Includes both setup and menu buttons
    const removedStamp = document.getElementById('removed-stamp');
    const addedStamp = document.getElementById('added-stamp');

    // Mode selector elements
    const modeBtns = document.querySelectorAll('.mode-btn');
    const modeFlashcard = document.getElementById('mode-flashcard');
    const modeSpelling = document.getElementById('mode-spelling');
    const modePronunciation = document.getElementById('mode-pronunciation');
    const modeTranslation = document.getElementById('mode-translation');

    // Menu button
    const menuBtn = document.getElementById('menu-btn');

    // Fullscreen button
    const fullscreenBtn = document.getElementById('fullscreen-btn');

    // Mic and feedback elements
    const micBtnFront = document.getElementById('mic-btn-front'); // Deprecated - kept for compatibility
    const micBtnBack = document.getElementById('mic-btn-back'); // Deprecated - kept for compatibility
    const micBtnControl = document.getElementById('mic-btn-control'); // New control bar mic button
    const feedbackFront = document.getElementById('feedback-front');
    const feedbackBack = document.getElementById('feedback-back');
    const scoreFront = document.getElementById('score-front');
    const scoreBack = document.getElementById('score-back');
    const messageFront = document.getElementById('message-front');
    const messageBack = document.getElementById('message-back');
    const heardFront = document.getElementById('heard-front');
    const heardBack = document.getElementById('heard-back');
    const closeFront = document.getElementById('close-front');
    const closeBack = document.getElementById('close-back');
    
    // Speech Recognition setup
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.lang = 'es-ES';
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.maxAlternatives = 5;
    }

    // ===================================================================================
    // SOUND FUNCTIONS - Now in game-sounds.js (shared across all games)
    // ===================================================================================
    // All sound functions moved to ../game-sounds.js:
    // - getAudioContext()
    // - playCardFlipSound()
    // - playDingSound()
    // - playBuzzSound()
    // - playButtonClickSound()
    // - playKeyboardSound()
    // - playScribbleSound()
    //
    // These are now globally available after importing game-sounds.js

    // ===================================================================================
    // KEY FEATURE: Stamp Display Functions (Wrappers for Shared Logic)
    // Core Objective: Visual feedback for correct/wrong answers - use shared functions
    // Key Behaviors:
    //   - showSuccessStamp: green "Card Removed" stamp + ding sound
    //   - showFailureStamp: red "Extra Practice" stamp + buzz sound
    //   - Both hide after 1.5 seconds and execute callback
    // ===================================================================================
    // NOTE: Core stamp logic is now in wordpack-logic.js (window.showSuccessStamp, window.showFailureStamp)
    // These wrappers provide game-specific element references (removedStamp, addedStamp)
    function showSuccessStamp(onComplete) {
      // Call shared function from wordpack-logic.js (use window. to access global function)
      window.showSuccessStamp(removedStamp, onComplete);
    }

    function showFailureStamp(onComplete) {
      // Call shared function from wordpack-logic.js (use window. to access global function)
      window.showFailureStamp(addedStamp, onComplete);
    }

    // ===================================================================================
    // MODE SWITCHING AND DISPLAY FUNCTIONS
    // ===================================================================================

    // NOTE: normalizeChar() is now in wordpack-logic.js (globally available)

    // Navigate to starting card (menu/help card)
    function showStartingCard(showBack = false) {
      if (!isOnStartingCard && currentDeck.length > 0) {
        savedIndex = currentIndex;
      }
      isOnStartingCard = true;

      // Add showing-menu class so menu content and UI elements are visible
      flashcard.classList.add('showing-menu');
      document.body.classList.add('showing-menu');

      // Update titles (use detected target language)
      const gameTitle = targetLanguageDisplay
        ? `${targetLanguageDisplay} Flashcard Typing Game`
        : 'Flashcard Typing Game';
      wordpackTitle.textContent = gameTitle;
      cardCounter.textContent = 'Choose Lesson to Begin Studying';

      // Render menu card (looks identical to a flashcard)
      renderMenuCard();

      // Unflip card face if currently flipped
      if (isFlipped) {
        flashcard.classList.remove('flipped');
        isFlipped = false;
      }

      // Flip to back if help was requested
      if (showBack) {
        setTimeout(() => flipCard(), 100);
      }
    }

    // Return from starting card to saved position
    function exitStartingCard() {
      if (!isOnStartingCard) return;
      isOnStartingCard = false;

      // Remove showing-menu class
      flashcard.classList.remove('showing-menu');
      document.body.classList.remove('showing-menu');

      currentIndex = savedIndex;
      updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks); // Restore wordpack title
      updateDisplay();
    }

    // Render the menu card (looks like a regular flashcard)
    function renderMenuCard() {
      // Get language name for UI text (use detected or fallback to generic)
      const langName = targetLanguageDisplay || 'Target';
      const voiceLabel = targetLanguageDisplay ? `${targetLanguageDisplay} Voice` : 'Voice';
      // For Chinese, typing is pinyin-based
      const typingDesc = isChineseMode() ? 'type pinyin' : 'type what you heard';
      const translationTypingDesc = isChineseMode() ? 'type pinyin' : `type ${langName} translation`;

      // Front: Menu/Settings (styled like target language side)
      spanishWord.innerHTML = `
        <div style="font-size: 1.1rem; text-align: left; max-width: 550px; margin: 0 auto; line-height: 1.8;">
          <!-- Row 1: Act and Wordpack -->
          <div style="display: flex; gap: 15px; margin-bottom: 20px;">
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>Choose Act</label>
              <select id="menu-act">
              </select>
            </div>
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>Choose Wordpack</label>
              <select id="menu-wordpack">
              </select>
            </div>
          </div>

          <!-- Row 2: Language and Speed -->
          <div style="display: flex; gap: 15px; margin-bottom: 20px;">
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>I speak</label>
              <select id="menu-language">
              </select>
            </div>
            <div class="menu-field" style="flex: 1; margin-bottom: 0;">
              <label>Pronunciation Speed</label>
              <div style="display: flex; gap: 8px; justify-content: center;">
                <button class="menu-speed-btn" data-speed="0.3"></button>
                <button class="menu-speed-btn" data-speed="0.6"></button>
                <button class="menu-speed-btn" data-speed="0.9"></button>
              </div>
            </div>
          </div>

          <!-- Row 3: Voice -->
          <div class="menu-field" style="margin-bottom: 25px;">
            <label>${voiceLabel}</label>
            <select id="menu-voice">
              <option value="">Loading voices...</option>
            </select>
          </div>

          <button id="start-practice-btn" class="setup-start-btn" style="width: 100%;">
             Start Game
          </button>
        </div>
      `;
      spanishWord.className = 'card-word';

      // Back: Help/Instructions (styled like translation side)
      englishWord.innerHTML = `
        <div style="font-size: 2rem; font-weight: bold; margin-bottom: 20px;"> How to Use</div>

        <div style="font-size: 1.1rem; text-align: left; max-width: 500px; margin: 0 auto; line-height: 1.8;">
          <div style="margin-bottom: 15px;">
            <strong> Flashcard Mode:</strong> ${langName} word  flip to see translation
          </div>

          <div style="margin-bottom: 15px;">
            <strong> Spelling Mode:</strong> Hear ${langName}  ${typingDesc}
          </div>

          <div style="margin-bottom: 15px;">
            <strong> Pronunciation Mode:</strong> See ${langName}  say it out loud (Space to record)
          </div>

          <div style="margin-bottom: 15px;">
            <strong> Translation Mode:</strong> See translation  ${translationTypingDesc}
          </div>

          <div style="margin-bottom: 15px;">
            <strong>Controls:</strong><br>
             Click card or  to flip<br>
               to navigate<br>
             Space: Hear pronunciation (reading) / Record speech (speaking) / Type practice (listening/writing)<br>
             Type letters in listening/translation modes
          </div>

          <div style="margin-bottom: 15px;">
            <strong>Buttons:</strong><br>
              Remove mastered card<br>
              Add 2 practice copies<br>
              Reset all cards
          </div>
        </div>
      `;
      englishWord.className = 'card-word';

      // Populate selectors after render
      setTimeout(() => {
        const menuAct = document.getElementById('menu-act');
        const menuWordpack = document.getElementById('menu-wordpack');
        const menuLanguage = document.getElementById('menu-language');
        const menuVoice = document.getElementById('menu-voice');
        const startPracticeBtn = document.getElementById('start-practice-btn');

        // Populate act selector
        if (menuAct) {
          // Use shared function from wordpack-logic.js
          window.populateActSelector(menuAct, loadedActMeta, null);

          // Game-specific: Set saved value and handle defaults
          const actNumbers = Object.keys(loadedActMeta).map(Number).sort((a, b) => a - b);
          if (currentAct && actNumbers.includes(currentAct)) {
            menuAct.value = currentAct;
          } else if (actNumbers.length > 0) {
            menuAct.value = actNumbers[0];
            currentAct = actNumbers[0];
            saveState();
          }

          menuAct.addEventListener('change', async (e) => {
            playButtonClickSound();
            const selectedAct = parseInt(e.target.value);
            currentAct = selectedAct;
            menuWordpack.innerHTML = '';
            menuWordpack.disabled = true;

            try {
              await loadAct(selectedAct);
              populateWordpackSelectorOnCard(selectedAct);
              menuWordpack.disabled = false;
            } catch (error) {
              console.error('Failed to load act:', error);
              menuWordpack.innerHTML = '<option value="">Failed to load act</option>';
            }
          });
        }

        // Populate wordpack selector
        if (menuWordpack) {
          populateWordpackSelectorOnCard(currentAct);
          // Restore saved wordpack selection if available
          if (currentWordpackKey && loadedActs[currentAct] && loadedActs[currentAct][currentWordpackKey]) {
            menuWordpack.value = currentWordpackKey;
          }

          menuWordpack.addEventListener('change', (e) => {
            playButtonClickSound();
            currentWordpackKey = e.target.value;
            saveState();
          });
        }

        // Language selector - populated from config, not hardcoded HTML
        if (menuLanguage) {
          // Use shared function from wordpack-logic.js
          const translations = getTranslationsConfig();
          if (translations) {
            window.populateNativeLanguageSelector(menuLanguage, translations, nativeLanguage, null);

            // Game-specific: Validate and set default if needed
            const validLanguages = Object.keys(translations);
            if (!nativeLanguage || !validLanguages.includes(nativeLanguage)) {
              nativeLanguage = getDefaultTranslation();
              menuLanguage.value = nativeLanguage;
              saveState();
            }
          }

          menuLanguage.addEventListener('change', (e) => {
            playButtonClickSound();
            nativeLanguage = e.target.value;
            updateBackLabel();
            // Reinitialize deck to include/exclude pinyin based on new language
            if (currentWordpackKey) {
              initializeDeck(currentWordpackKey);
            }
            saveState();
          });
        }

        // Voice selector - use saved state (currentVoice or savedVoiceURI)
        // No "Default" placeholder - always show actual voice name
        if (menuVoice && spanishVoices.length > 0) {
          menuVoice.innerHTML = ''; // Clear - no placeholder
          spanishVoices.forEach((voice) => {
            const option = document.createElement('option');
            option.value = voice.voiceURI;
            option.textContent = `${voice.name} (${voice.lang})`;
            menuVoice.appendChild(option);
          });

          // Use currentVoice if set, otherwise use savedVoiceURI from state, otherwise first voice
          const voiceURIToRestore = currentVoice ? currentVoice.voiceURI : savedVoiceURI;
          if (voiceURIToRestore && spanishVoices.find(v => v.voiceURI === voiceURIToRestore)) {
            menuVoice.value = voiceURIToRestore;
            // Also set currentVoice if we have the URI but not the voice object
            if (!currentVoice && savedVoiceURI) {
              currentVoice = spanishVoices.find(v => v.voiceURI === savedVoiceURI) || null;
            }
          } else {
            // No saved voice or saved voice not found - default to first voice
            const firstVoice = spanishVoices[0];
            menuVoice.value = firstVoice.voiceURI;
            currentVoice = firstVoice;
            savedVoiceURI = firstVoice.voiceURI;
          }

          menuVoice.addEventListener('change', (e) => {
            playButtonClickSound();
            const newVoiceURI = e.target.value;
            currentVoice = spanishVoices.find(v => v.voiceURI === newVoiceURI) || null;
            savedVoiceURI = newVoiceURI; // Also update savedVoiceURI
            saveState();
            // Preview the new voice by speaking the current word
            if (currentDeck.length > 0) {
              setTimeout(() => speakTargetWord(), 100);
            }
          });
        }

        // Speed buttons - use CSS classes for cardboard styling
        const speedBtns = document.querySelectorAll('.menu-speed-btn');
        // First reset ALL buttons to default state (remove active class)
        speedBtns.forEach(b => {
          b.classList.remove('active');
        });
        // Then highlight the one matching saved currentSpeed
        speedBtns.forEach(btn => {
          if (parseFloat(btn.dataset.speed) === currentSpeed) {
            btn.classList.add('active');
          }
          btn.addEventListener('click', () => {
            playButtonClickSound();
            currentSpeed = parseFloat(btn.dataset.speed);
            speedBtns.forEach(b => {
              b.classList.remove('active');
            });
            btn.classList.add('active');
            saveState();
            // Preview the new speed by speaking the current word
            if (currentDeck.length > 0) {
              setTimeout(() => speakTargetWord(), 100);
            }
          });
        });

        // Start Practice button
        if (startPracticeBtn) {
          startPracticeBtn.addEventListener('click', () => {
            playButtonClickSound(); // Always play sound for feedback
            if (currentWordpackKey && nativeLanguage) {
              startGame();
            }
          });
        }
      }, 0);
    }

    // Helper function to populate wordpack selector on card
    // KEY FEATURE: Uses saved state first, only defaults to first pack if no saved state
    function populateWordpackSelectorOnCard(actNumber) {
      const menuWordpack = document.getElementById('menu-wordpack');
      if (!menuWordpack || !actNumber) return;

      menuWordpack.innerHTML = ''; // Clear existing options - no placeholder

      const actData = loadedActs[actNumber];
      if (!actData) return;

      // Filter out __actMeta - only get actual pack keys
      const packKeys = Object.keys(actData).filter(key => key !== '__actMeta');
      packKeys.sort((a, b) => {
        const numA = actData[a].meta.wordpack;
        const numB = actData[b].meta.wordpack;
        return numA - numB;
      });

      packKeys.forEach(packKey => {
        const pack = actData[packKey];
        const option = document.createElement('option');
        option.value = packKey;
        option.textContent = `${pack.meta.wordpack}. ${pack.meta.english}`;
        menuWordpack.appendChild(option);
      });

      // Use saved wordpack if valid for this act, otherwise default to first pack
      if (currentWordpackKey && actData[currentWordpackKey]) {
        // Saved wordpack exists in this act - use it
        menuWordpack.value = currentWordpackKey;
      } else if (packKeys.length > 0) {
        // No saved wordpack or not valid for this act - default to first
        menuWordpack.value = packKeys[0];
        currentWordpackKey = packKeys[0];
        saveState(); // Save the default
      }
    }

    // Switch to a different learning mode
    function switchMode(newMode) {
      if (currentMode === newMode) return;

      // Stop all speech sounds - mode change is like a reset
      speechSynthesis.cancel();

      currentMode = newMode;

      // Update active button
      modeBtns.forEach(btn => btn.classList.remove('active'));
      if (newMode === 'flashcard') modeFlashcard.classList.add('active');
      if (newMode === 'spelling') modeSpelling.classList.add('active');
      if (newMode === 'pronunciation') modePronunciation.classList.add('active');
      if (newMode === 'translation') modeTranslation.classList.add('active');

      // Completely reset pack as if starting new game in this mode
      // (Reset from original deck, not modified current deck)
      // CRITICAL: Keep pedagogical ordering (base words first, then examples)
      if (originalDeck.length > 0) {
        currentDeck = [...originalDeck]; // Copy without shuffling - preserve baseexample order
        currentIndex = 0;
      }

      // Reset flip state
      if (isFlipped) {
        flashcard.classList.remove('flipped');
        isFlipped = false;
      }

      // Reset deck change indicator
      pendingDeckChange = 0;

      // Initialize typing display for listening and translation modes
      if ((newMode === 'spelling' || newMode === 'translation') && currentDeck.length > 0) {
        initializeTypingDisplay();
      }

      updateDisplay();

      // Auto-pronounce target word in spelling mode only (not writing - user needs to translate)
      if (newMode === 'spelling' && currentDeck.length > 0) {
        setTimeout(() => speakTargetWord(), 300);
      }

      // Update debug simulate button visibility based on new mode
      if (typeof updateSimulateButtonsVisibility === 'function') {
        updateSimulateButtonsVisibility();
      }

      // Save state (only saves speech rate and pack selection, not deck progress)
      saveState();
    }

    // Initialize typing display for spelling and translation modes
    function initializeTypingDisplay() {
      const word = currentDeck[currentIndex].typingTarget;
      typingInput = '';
      typingDisplay = word.split('');
      typedPositions = new Set();
      wrongAttempts = 0;
      wrongPositions = [];
      wrongLetters = [];
    }

    // NOTE: addDuplicateCards() has been moved to wordpack-logic.js as a pure function.
    // All calls now use: addDuplicateCards(deck, card, count) which returns {deck, newIndex}.

    // Handle typing input for listening and translation modes
    // NOTE: Uses shared helper functions from wordpack-logic.js for validation
    function handleTypingInput(key) {
      if ((currentMode !== 'spelling' && currentMode !== 'translation') || currentDeck.length === 0) return;

      // Use typingTarget (pinyin for Chinese, spanish for others)
      const word = currentDeck[currentIndex].typingTarget;
      const targetChars = word.split('');

      // Find next typing position using shared helper (handles spaces automatically)
      const nextPos = findNextTypingPosition(targetChars, typedPositions);

      if (nextPos === -1) {
        // Already completed
        return;
      }

      // Check if key matches using shared helper (handles normalization)
      const keyCheck = checkTypingKey(key, targetChars[nextPos]);

      if (keyCheck === 'correct') {
        // Correct! Mark position as typed
        typedPositions.add(nextPos);
        playScribbleSound(); // Felt pen writing sound
        updateDisplay();

        // Check if word is complete using shared helper
        if (isWordComplete(targetChars, typedPositions)) {
          // Word completed!
          // 0-1 wrong = correct (show green stamp and remove card)
          // 2+ wrong = always +2 penalty cards

          if (wrongAttempts <= 1) {
            // Correct! Show green stamp and remove card automatically
            pendingDeckChange = -1; // Track deck change for visual indicator
            updateDisplay(); // Show indicator while stamp is visible

            // Show success stamp with ding sound (encapsulated)
            showSuccessStamp(() => {
              // Remove card from deck
              if (currentDeck.length <= 1) {
                currentDeck = [];
              } else {
                currentDeck.splice(currentIndex, 1);
                if (currentIndex >= currentDeck.length) {
                  currentIndex = 0;
                }
              }

              // Clear pending change
              pendingDeckChange = 0;

              // Play sound on page change (consistent timing)
              playCardFlipSound();

              // Re-initialize typing for next card (only if deck is not empty)
              if ((currentMode === 'spelling' || currentMode === 'translation') && currentDeck.length > 0) {
                initializeTypingDisplay();
              }
              updateDisplay();
              saveState();

              // Auto-pronounce in spelling mode
              if (currentMode === 'spelling' && currentDeck.length > 0) {
                setTimeout(() => speakTargetWord(), 300);
              }
            });
          } else {
            // Wrong - always add 2 penalty cards (using shared function from wordpack-logic.js)
            const result = addDuplicateCards(currentDeck, currentDeck[currentIndex], 2);
            currentDeck = result.deck;
            currentIndex = result.newIndex;

            // Auto-advance after stamp duration (1600ms > 1500ms stamp)
            setTimeout(() => {
              if (currentMode === 'spelling' || currentMode === 'translation') {
                moveToNextCard();
              }
            }, 1600);
          }
        }
      } else {
        // Wrong key pressed - mark position as wrong, increment counter, and track wrong letter
        playScribbleSound(); // Play scribble sound for any key press
        if (!wrongPositions.includes(nextPos)) {
          wrongPositions.push(nextPos);
        }
        wrongAttempts++;
        // Store wrong letter with its style (lowercase, random rotation/scale - set once, never changes)
        wrongLetters.push({
          letter: key.toLowerCase(), // Case-insensitive
          rotation: -8 + Math.random() * 16, // -8deg to +8deg
          scale: 0.95 + Math.random() * 0.1, // 0.95 to 1.05
          xRotation: -5 + Math.random() * 10 // -5deg to +5deg for X mark
        });
        updateDisplay(); // Update to show red color and wrong indicators
      }
    }

    // ============================================================
    // NOTE: isWritingComplete() removed - use isWordComplete() from wordpack-logic.js
    // Usage: isWordComplete(typingDisplay, typedPositions)
    // ============================================================

    // Load voices based on TTS language code from loaded modules
    // KEY FEATURE: Voices only load if modules are loaded - no module = no voices
    function loadVoices() {
      const ttsLangCode = getTtsLanguageCode();

      // Only filter voices if we have a language code from loaded modules
      if (!ttsLangCode) {
        spanishVoices = []; // No modules loaded = no voices
        return;
      }

      // Use shared function from wordpack-logic.js to load voices
      spanishVoices = window.loadVoicesForLanguage(ttsLangCode);

      // Restore saved voice if we have a saved URI and voices are now available
      if (savedVoiceURI && spanishVoices.length > 0 && !currentVoice) {
        // Use shared function from wordpack-logic.js to find voice by URI
        currentVoice = window.findVoiceByURI(savedVoiceURI, spanishVoices) || null;
      }
      // Voice selector is now populated in renderMenuCard() when menu is created
    }

    function populateVoiceSelector() {
      // DEPRECATED: Voice selector is now populated inside renderMenuCard()
      // This function kept for compatibility but does nothing
    }

    // Load voices when available
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = loadVoices;
    }
    loadVoices();

    // ============================================================
    // KEY FEATURE: Load acts on demand with obfuscated modules
    // Core Objective: Efficiently load only needed acts, decode them
    // Key Behaviors:
    //   - Populate act selector on page load
    //   - Load and decode act data when user selects an act
    //   - Cache loaded acts to avoid re-loading
    //   - Populate wordpack selector with packs from selected act
    // ============================================================

    // ============================================================
    // NOTE: loadAct() removed - use window.loadAct() from wordpack-logic.js
    // This function handles loading obfuscated modules, extracting metadata,
    // and caching loaded acts for reuse.
    // ============================================================

    // ============================================================
    // NOTE: populateActSelector() removed - use window.populateActSelector() from wordpack-logic.js
    // NOTE: populateLanguageSelector() removed - use window.populateNativeLanguageSelector() from wordpack-logic.js
    // These functions populate dropdowns with act names and language options from loaded module metadata.
    // ============================================================

    // ============================================================
    // Initialize tooltips from TOOLTIP_MESSAGES (single source of truth)
    // ============================================================
    // This function populates BOTH:
    //   1. Mode tooltips (the big instruction lists under each mode button)
    //   2. Control bar button tooltips (hover text for individual buttons)
    // All using the SAME TOOLTIP_MESSAGES, ensuring consistency.
    // ============================================================
    function initializeTooltips() {
      // ---------------------------------------------------------
      // MODE TOOLTIPS - Build instruction lists for each mode
      // ---------------------------------------------------------

      // Flashcard Mode: gotIt, confused, prevCard, nextCard, pronounce, peek
      const readingTooltip = document.getElementById('tooltip-reading');
      if (readingTooltip) {
        readingTooltip.innerHTML = `
          <strong> Flashcard Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.gotIt}<br>
            ${TOOLTIP_MESSAGES.confused}<br>
            ${TOOLTIP_MESSAGES.prevCard}<br>
            ${TOOLTIP_MESSAGES.nextCard}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // Spelling Mode: typeLetters, pronounce, peek
      const listeningTooltip = document.getElementById('tooltip-listening');
      if (listeningTooltip) {
        listeningTooltip.innerHTML = `
          <strong> Spelling Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.typeLetters}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // Pronunciation Mode: record, pronounce, peek
      const speakingTooltip = document.getElementById('tooltip-speaking');
      if (speakingTooltip) {
        speakingTooltip.innerHTML = `
          <strong> Pronunciation Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.record}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // Translation Mode: typeLetters, pronounce, peek
      const writingTooltip = document.getElementById('tooltip-writing');
      if (writingTooltip) {
        writingTooltip.innerHTML = `
          <strong> Translation Mode</strong>
          <div class="tooltip-instructions">
            ${TOOLTIP_MESSAGES.typeLetters}<br>
            ${TOOLTIP_MESSAGES.pronounce}<br>
            ${TOOLTIP_MESSAGES.peek}
          </div>
        `;
      }

      // ---------------------------------------------------------
      // CONTROL BAR BUTTON TOOLTIPS - Same messages as mode tooltips
      // ---------------------------------------------------------
      // Note: These use innerHTML because messages contain HTML (styled spans)
      gotItBtn.innerHTML = '';
      gotItBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.gotIt);
      confusedBtn.innerHTML = '';
      confusedBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.confused);
      pronounceBtn.innerHTML = '';
      pronounceBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.pronounce);
      peekBtn.innerHTML = '';
      peekBtn.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.peek);

      // Mic button tooltip (control bar)
      const micBtnControlEl = document.getElementById('mic-btn-control');
      if (micBtnControlEl) {
        micBtnControlEl.innerHTML = '';
        micBtnControlEl.setAttribute('data-tooltip-html', TOOLTIP_MESSAGES.record);
      }

      // ---------------------------------------------------------
      // Control bar button tooltips REMOVED per user request
      // Only mode selector buttons have hover tooltips now
      // ---------------------------------------------------------
    }

    // ============================================================
    // NOTE: createButtonTooltip() removed - use shared version from wordpack-logic.js
    // The function is available globally as window.createButtonTooltip()
    // ============================================================

    // Initialize on page load
    // KEY FEATURE: Loads act data, preloads deck from saved state (or pack 1), then displays menu overlay
    // Core Objective: User sees content under the menu when toggling, state is preserved across sessions
    async function initializeApp() {
      // Initialize tooltips from single source of truth
      initializeTooltips();

      try {
        // First act is 1 (MODULE_URLS is 0-indexed, act numbers are 1-indexed)
        if (MODULE_URLS.length > 0) {
          currentAct = 1;
        }

        // Load ALL acts to get their metadata for dropdowns
        // (act names and translations come from __actMeta in each module)
        for (let actNum = 1; actNum <= MODULE_URLS.length; actNum++) {
          await loadAct(actNum);
        }

        // ============================================================
        // VALIDATE AND DETECT TARGET LANGUAGE
        // All modules must have the same wordColumns[0]
        // ============================================================
        if (!validateTargetLanguageConsistency()) {
          throw new Error('Modules have inconsistent target languages');
        }

        // Set the target language from loaded modules
        targetLanguage = getTargetLanguage();
        targetLanguageDisplay = toTitleCase(targetLanguage);

        // Apply Chinese mode CSS class if needed
        updateChineseModeClass();

        // Update page title based on detected language
        if (targetLanguageDisplay) {
          document.title = `${targetLanguageDisplay} Flashcard Typing Game`;
          document.getElementById('wordpack-title').textContent = `${targetLanguageDisplay} Flashcard Typing Game`;
        }

        console.log(`[initializeApp] Detected target language: ${targetLanguage} (${targetLanguageDisplay})`);

        // Now that modules are loaded, load voices based on module metadata
        // This ensures no voices are available if modules fail to load
        loadVoices();

        // Remember which act we initially loaded
        const firstAct = currentAct;

        // Restore any saved state (may change currentAct and currentWordpackKey)
        restoreSavedState();

        // If saved act is different from the first act we loaded, load it
        if (currentAct !== firstAct) {
          await loadAct(currentAct);
        }

        // KEY FEATURE: Preload deck so there's content under the menu
        // If no saved wordpack, default to first pack in current act
        if (!currentWordpackKey && loadedActs[currentAct]) {
          const packKeys = Object.keys(loadedActs[currentAct]);
          if (packKeys.length > 0) {
            currentWordpackKey = packKeys[0];
          }
        }

        // Initialize the deck silently (content will be under the menu)
        if (currentWordpackKey && wordpacks[currentWordpackKey]) {
          initializeDeck(currentWordpackKey);
          updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks);
          updateBackLabel();

          // Set game-started state so card content is visible under menu
          flashcard.classList.add('game-started');
          document.body.classList.add('game-started');
          gameStarted = true;
        }

        // Show menu on card as overlay - this renders the menu and populates selectors
        showStartingCard(false);
      } catch (error) {
        console.error('Failed to initialize app:', error);
        // Show error in menu if it exists
        const menuAct = document.getElementById('menu-act');
        const menuWordpack = document.getElementById('menu-wordpack');
        if (menuAct) menuAct.innerHTML = '<option value="">Failed to load acts</option>';
        if (menuWordpack) menuWordpack.innerHTML = '<option value="">Failed to load wordpacks</option>';
      }
    }

    // NOTE: populateWordpackSelector was removed - functionality moved to populateWordpackSelectorOnCard()
    // which is called from renderMenuCard() and properly handles the menu-wordpack element

    // Restore saved state from localStorage
    // KEY FEATURE: Restores user's last session settings (speed, wordpack, act, language, voice)
    // If no saved state exists, creates one with current defaults
    function restoreSavedState() {
      const savedState = loadState();

      // If no saved state, save current defaults and return
      if (!savedState) {
        saveState(); // Save defaults so they persist
        return;
      }

      // Restore speech rate (validate against valid options)
      if (savedState.speed !== undefined && savedState.speed !== null) {
        // Only restore if it's a valid speed option, otherwise keep default
        if (VALID_SPEEDS.includes(savedState.speed)) {
          currentSpeed = savedState.speed;
        }
        // Speed buttons UI will be updated when menu renders
      }

      // Restore last selected act
      if (savedState.act) {
        currentAct = savedState.act;
      }

      // Restore last selected wordpack (value only - UI updated when menu renders)
      if (savedState.wordpackKey) {
        currentWordpackKey = savedState.wordpackKey;
      }

      // Restore native language (validate against valid options)
      if (savedState.language) {
        // Only restore if it's a valid language option, otherwise keep default
        if (getValidLanguages().includes(savedState.language)) {
          nativeLanguage = savedState.language;
        }
      }

      // Store saved voice URI - will be applied when voices are loaded
      if (savedState.voiceURI) {
        savedVoiceURI = savedState.voiceURI;
      }

      // Chinese characters and pinyin are always shown together (no user toggle)
    }

    function updateBackLabel() {
      // Card labels have been removed, this function is no longer needed
      // Kept for compatibility with existing code that calls it
      if (!backLabel) return;

      // Get display label from loaded module metadata
      const translations = getTranslationsConfig();
      if (!translations) return;
      const langConfig = translations[nativeLanguage];
      backLabel.textContent = langConfig ? langConfig.display : translations[getDefaultTranslation()].display;
    }

    // ============================================================
    // shuffleArray() - Now in wordpack-logic.js
    // ============================================================
    // Fisher-Yates shuffle algorithm moved to shared module for reuse
    // ============================================================

    // ============================================================
    // combineAndShuffleWords() - Now in wordpack-logic.js
    // ============================================================
    // Educational word combining logic moved to shared module
    // Takes difficulty parameter: 'easy' (base only), 'medium' (examples only), 'hard' (all)
    // ============================================================

    // ============================================================
    // KEY FEATURE: Deck Initialization with Linked Card Objects
    // Core Objective: Create shuffled deck where front/back are ALWAYS synced
    // Key Behaviors:
    //   - Each card is a SINGLE object with both spanish and translation
    //   - Front and back of card are NEVER separate - they are properties
    //     of the same card object (currentDeck[currentIndex])
    //   - Shuffling reorders cards but NEVER breaks the front/back link
    //   - This function is ONLY called when starting fresh or changing wordpack
    // ============================================================
    function initializeDeck(packKey) {
      if (!packKey || !wordpacks[packKey]) {
        currentDeck = [];
        originalDeck = [];
        updateDisplay();
        return;
      }

      const pack = wordpacks[packKey];
      // Get translation column index from loaded module metadata
      const translations = getTranslationsConfig();
      if (!translations) {
        console.error('[initializeDeck] No translations loaded');
        return;
      }
      const langConfig = translations[nativeLanguage];
      const nativeIndex = langConfig ? langConfig.index : translations[getDefaultTranslation()].index;

      // ============================================================
      // ARCHITECTURE: Combine baseWords + exampleWords with shuffling
      // ============================================================
      const words = combineAndShuffleWords(pack, currentDifficulty);

      // ============================================================
      // DYNAMIC LANGUAGE HANDLING
      // Card structure adapts based on target language:
      // - targetWord: The word being learned (column 0)
      // - pinyin: Pinyin for Chinese (column 1 if Chinese, or translation pinyin)
      // - translation: The translation in native language
      // - typingTarget: What user types (pinyin for Chinese, targetWord otherwise)
      // ============================================================
      const targetIsChinese = isChineseMode();

      // Get word columns from loaded metadata to find pinyin column
      const wordColumns = getWordColumns();

      // Find pinyin index - it follows 'chinese' column in the word array
      let pinyinIndex = -1;
      if (wordColumns) {
        const chineseIdx = wordColumns.indexOf('chinese');
        if (chineseIdx !== -1) {
          // Pinyin typically follows chinese column
          const pinyinIdx = wordColumns.indexOf('pinyin');
          if (pinyinIdx !== -1) {
            pinyinIndex = pinyinIdx;
          }
        }
      }

      // CRITICAL: Each card object contains BOTH front (target word) and back (translation)
      // These are NEVER stored separately - they are always linked as one object
      originalDeck = words.map((wordObj, idx) => {
        const word = wordObj.word;  // Extract word array from object
        const card = {
          id: `${packKey}-${idx}`,        // Unique ID for this card
          targetWord: word[0],            // Front of card (target language word)
          spanish: word[0],               // BACKWARDS COMPAT: Alias for non-Chinese modes
          translation: word[nativeIndex], // Back of card (translation)
          type: wordObj.type,             // Word type for debugging (Base Word / Example Word)
          rawWord: word                   // Store full word array for debug table access
        };

        // ============================================================
        // CHINESE-SPECIFIC HANDLING
        // ============================================================
        if (targetIsChinese) {
          // When learning Chinese: pinyin is at index 1 (directly after Chinese)
          card.pinyin = word[1] || '';
          card.chinese = word[0];         // Alias for Chinese mode
          // Typing target is pinyin (letter-based typing)
          card.typingTarget = card.pinyin;
        } else {
          // When learning Spanish/English: typing target is the target word
          card.typingTarget = card.targetWord;

          // Add pinyin when TRANSLATION is Chinese (not target language)
          if (nativeLanguage === 'chinese' && pinyinIndex !== -1) {
            card.translationPinyin = word[pinyinIndex] || '';
            card.translationIsChinese = true;
          }
        }

        return card;
      });

      // ============================================================
      // CRITICAL: DO NOT shuffle originalDeck here!
      // Words are already ordered by combineAndShuffleWords():
      //   1. Base words (shuffled internally)
      //   2. Example words (shuffled internally)
      // Shuffling here would mix base and example words together,
      // breaking the pedagogical ordering!
      // ============================================================
      currentDeck = [...originalDeck]; // Copy without shuffling
      currentIndex = 0;
      updateDisplay();

      // Update debug table with new deck data (if debug mode is enabled)
      if (typeof updateDebugTable === 'function') {
        updateDebugTable();
      }
    }

    // ============================================================
    // GAME-SPECIFIC WRAPPER: Restart current wordpack
    // ============================================================
    // WHY THIS EXISTS: Wraps shared resetDeckToOriginal() with game-specific:
    //   - Access to local variables (originalDeck, currentDeck, currentIndex)
    //   - Game-specific callbacks (initializeTypingDisplay, updateDisplay, saveState)
    //   - Flash-card specific sound effects (playButtonClickSound)
    // REUSABILITY: 2/10 - Other games need different callbacks/context
    // ============================================================
    function restartCurrentPack() {
      playButtonClickSound();

      if (originalDeck.length > 0) {
        const result = resetDeckToOriginal(originalDeck, {
          onReset: (newDeck) => {
            currentDeck = newDeck;
            currentIndex = 0;
            if (currentMode === 'spelling' || currentMode === 'translation') {
              initializeTypingDisplay();
            }
            updateDisplay();
            saveState();

            // Update debug table to show full deck again
            if (typeof updateDebugTable === 'function') {
              updateDebugTable();
            }
          }
        });

        currentDeck = result.deck;
        currentIndex = result.currentIndex;
      }
    }

    // Go to next wordpack
    // ============================================================
    // NOTE: Now uses shared navigateToNextPack() from wordpack-logic.js
    // ============================================================
    function goToNextPack() {
      playButtonClickSound();

      const nextPackKey = navigateToNextPack(wordpacks, currentWordpackKey);
      currentWordpackKey = nextPackKey;

      // Update menu selector if visible
      const menuWordpack = document.getElementById('menu-wordpack');
      if (menuWordpack) menuWordpack.value = nextPackKey;

      initializeDeck(nextPackKey);
      updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks);
      saveState();
    }

    // Generate random weathering pattern for a card
    function generateWeathering(seed) {
      // Use card ID as seed for consistent random pattern per card
      const random = (s) => {
        const x = Math.sin(s) * 10000;
        return x - Math.floor(x);
      };

      // Generate stronger sun-faded edges (more obvious)
      const topFade = 15 + random(seed) * 10; // 15-25%
      const rightFade = 15 + random(seed + 1) * 10;
      const bottomFade = 15 + random(seed + 2) * 10;
      const leftFade = 15 + random(seed + 3) * 10;

      // Vary the color tint (brownish/sepia tones)
      const redTint = 101 + Math.floor(random(seed + 4) * 20); // 101-120
      const greenTint = 67 + Math.floor(random(seed + 5) * 15); // 67-82
      const blueTint = 33 + Math.floor(random(seed + 6) * 10); // 33-43

      // Vary the edge intensity (stronger)
      const edgeIntensity = 0.18 + random(seed + 7) * 0.12; // 0.18-0.30

      // Overall card color variation (subtle)
      const overallIntensity = 0.03 + random(seed + 8) * 0.04; // 0.03-0.07

      // Random positions for color variation splotches
      const spot1X = 20 + random(seed + 9) * 30; // 20-50%
      const spot1Y = 20 + random(seed + 10) * 30;
      const spot2X = 50 + random(seed + 11) * 30; // 50-80%
      const spot2Y = 50 + random(seed + 12) * 30;
      const spot3X = 30 + random(seed + 13) * 40; // 30-70%
      const spot3Y = 60 + random(seed + 14) * 30;

      const gradients = [
        // Overall card color variations (subtle splotches across entire card)
        `radial-gradient(ellipse 60% 50% at ${spot1X}% ${spot1Y}%, rgba(${redTint}, ${greenTint}, ${blueTint}, ${overallIntensity}) 0%, transparent 60%)`,
        `radial-gradient(ellipse 50% 60% at ${spot2X}% ${spot2Y}%, rgba(${redTint + 5}, ${greenTint + 3}, ${blueTint + 2}, ${overallIntensity * 0.8}) 0%, transparent 55%)`,
        `radial-gradient(ellipse 55% 45% at ${spot3X}% ${spot3Y}%, rgba(${redTint - 5}, ${greenTint - 2}, ${blueTint}, ${overallIntensity * 0.9}) 0%, transparent 50%)`,
        // Stronger sun-faded edges
        `linear-gradient(to bottom, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${topFade}%)`,
        `linear-gradient(to left, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${rightFade}%)`,
        `linear-gradient(to top, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${bottomFade}%)`,
        `linear-gradient(to right, rgba(${redTint}, ${greenTint}, ${blueTint}, ${edgeIntensity}) 0%, transparent ${leftFade}%)`
      ];

      return gradients.join(', ');
    }

    // ============================================================
    // NOTE: renderTypingDisplay() removed - use shared version from wordpack-logic.js
    // Use: window.renderTypingDisplayHTML(typingDisplay, typedPositions, wrongPositions)
    // ============================================================

    // ============================================================
    // KEY FEATURE: Card Display - Front and Back Always Linked
    // Core Objective: Display current card with guaranteed sync
    // Key Behaviors:
    //   - ALWAYS uses single card object: currentDeck[currentIndex]
    //   - card.targetWord = front of card (the word being learned)
    //   - card.typingTarget = what user types (pinyin for Chinese, targetWord otherwise)
    //   - card.pinyin = pinyin pronunciation (Chinese mode only)
    //   - card.translation = back of card
    //   - These are NEVER from different sources - always same object
    // ============================================================

    // ============================================================
    // NOTE: renderTargetWord() removed - use shared version from wordpack-logic.js
    // Use: window.renderTargetWordHTML(card, isChineseMode())
    // ============================================================

    // ============================================================
    // NOTE: renderTranslation() removed - use shared version from wordpack-logic.js
    // Use: window.renderTranslationHTML(card)
    // ============================================================

    function updateDisplay() {
      // Starting card is shown/hidden by showStartingCard/exitStartingCard
      // Don't update card content when on starting card
      if (isOnStartingCard) {
        return;
      }

      if (currentDeck.length === 0) {
        // Show completion screen
        cardCounter.textContent = 'Pack Complete!';
        spanishWord.innerHTML = `
          <div style="font-size: 3rem; margin-bottom: 30px;"> Good Job! </div>
          <div style="font-size: 1.5rem; margin-bottom: 40px;">You've completed this wordpack!</div>
          <div style="display: flex; gap: 20px; justify-content: center;">
            <button onclick="restartCurrentPack()" style="padding: 15px 30px; font-size: 1.3rem; background: #8B7355; color: var(--color-text-light); border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
               Study Again
            </button>
            <button onclick="goToNextPack()" style="padding: 15px 30px; font-size: 1.3rem; background: #7A6347; color: var(--color-text-light); border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
               Next Pack
            </button>
          </div>
        `;
        spanishWord.className = 'card-word';
        englishWord.textContent = '';
        return;
      }

      // CRITICAL: Get SINGLE card object - front (target word) and back (translation) are ALWAYS linked
      const card = currentDeck[currentIndex];

      // Display counter - different format for auto-advance vs manual modes
      // Flashcard mode: manual advance, shows "Card X of Y"
      // Other modes: auto-advance on correct answer, shows "Y Cards Left"
      let counterText;
      if (currentMode === 'flashcard') {
        counterText = `Card ${currentIndex + 1} of ${currentDeck.length}`;
      } else {
        counterText = `${currentDeck.length} Cards Left`;
      }

      cardCounter.textContent = counterText; // Plain text, no HTML

      // Get indicator elements (positioned at card corners, not inside card-word)
      const wrongLettersFront = document.getElementById('wrong-letters-front');
      const wrongCountFront = document.getElementById('wrong-count-front');

      // Mode-specific display
      if (currentMode === 'flashcard') {
        // FLASHCARD MODE - Purpose: Learn to read target word and understand meaning
        // Front: Target word | Back: Translation
        // For Chinese: renderTargetWordHTML() returns coupled char+pinyin HTML
        // When translation is Chinese, renderTranslationHTML() returns coupled char+pinyin HTML
        spanishWord.innerHTML = renderTargetWordHTML(card, isChineseMode());
        spanishWord.className = 'card-word';
        englishWord.innerHTML = `<div class="translation-text">${renderTranslationHTML(card)}</div>`;
        englishWord.className = 'card-word';
        // Clear indicators
        wrongLettersFront.innerHTML = '';
        wrongCountFront.innerHTML = '';
      } else if (currentMode === 'spelling') {
        // SPELLING MODE - Purpose: Learn to understand spoken target language and spell it
        // Front: Hear audio + type what you hear | Back: Target word + translation
        // Update wrong indicators (positioned at card corners) - use stored variations (don't recalc)
        // Show all wrong letters including repeats (user can see each wrong attempt)
        wrongLettersFront.innerHTML = wrongLetters.length > 0
          ? wrongLetters.map(item => {
              // Use stored rotation/scale values - never recalculate (real writing doesn't move!)
              return `<span style="position: relative; display: inline-block; margin-right: 15px; transform: scale(${item.scale}) rotate(${item.rotation}deg);"><span style="color: var(--color-text-dark);">${item.letter}</span><span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(${item.xRotation}deg); color: #D32F2F; font-size: 0.7em; font-weight: bold; opacity: 0.7;"></span></span>`;
            }).join('')
          : '';
        const countRotate = -2 + Math.random() * 4; // -2deg to +2deg
        const countScale = 0.95 + Math.random() * 0.1; // 0.95 to 1.05
        wrongCountFront.innerHTML = wrongAttempts > 0
          ? `<span style="display: inline-block; transform: scale(${countScale}) rotate(${countRotate}deg);">-${wrongAttempts}</span>`
          : '';
        // Update card content (no indicators embedded here)
        spanishWord.innerHTML = `<div class="typing-display">${renderTypingDisplayHTML(typingDisplay, typedPositions, wrongPositions)}</div>`;
        spanishWord.className = 'card-word';
        // Back shows target word + translation (with Chinese coupling if applicable)
        englishWord.innerHTML = `${renderTargetWordHTML(card, isChineseMode())}<br><div class="translation-text">${renderTranslationHTML(card)}</div>`;
        englishWord.className = 'card-word';
      } else if (currentMode === 'translation') {
        // TRANSLATION MODE - Purpose: Learn to write/spell target word from translation
        // Front: Translation + type target word | Back: Correct target word
        // Update wrong indicators (positioned at card corners) - use stored variations (don't recalc)
        // Show all wrong letters including repeats (user can see each wrong attempt)
        wrongLettersFront.innerHTML = wrongLetters.length > 0
          ? wrongLetters.map(item => {
              // Use stored rotation/scale values - never recalculate (real writing doesn't move!)
              return `<span style="position: relative; display: inline-block; margin-right: 15px; transform: scale(${item.scale}) rotate(${item.rotation}deg);"><span style="color: var(--color-text-dark);">${item.letter}</span><span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(${item.xRotation}deg); color: #D32F2F; font-size: 0.7em; font-weight: bold; opacity: 0.7;"></span></span>`;
            }).join('')
          : '';
        const countRotate = -2 + Math.random() * 4; // -2deg to +2deg
        const countScale = 0.95 + Math.random() * 0.1; // 0.95 to 1.05
        wrongCountFront.innerHTML = wrongAttempts > 0
          ? `<span style="display: inline-block; transform: scale(${countScale}) rotate(${countRotate}deg);">-${wrongAttempts}</span>`
          : '';
        // Update card content (no indicators embedded here)
        // TRANSLATION MODE: Front shows translation (for user to translate FROM)
        // When translation is Chinese, show with coupled char+pinyin
        spanishWord.innerHTML = `<div class="translation-text">${renderTranslationHTML(card)}</div><div style="margin: 10px 0;"></div><div class="typing-display">${renderTypingDisplayHTML(typingDisplay, typedPositions, wrongPositions)}</div>`;
        spanishWord.className = 'card-word';
        // Back shows target word (with Chinese coupling if applicable)
        englishWord.innerHTML = renderTargetWordHTML(card, isChineseMode());
        englishWord.className = 'card-word';
      } else if (currentMode === 'pronunciation') {
        // PRONUNCIATION MODE - Purpose: Learn to pronounce target word correctly
        // Front: Target word + microphone button | Back: Translation (with Chinese coupling if applicable)
        spanishWord.innerHTML = renderTargetWordHTML(card, isChineseMode());
        spanishWord.className = 'card-word';
        englishWord.innerHTML = `<div class="translation-text">${renderTranslationHTML(card)}</div>`;
        englishWord.className = 'card-word';
        // Clear indicators
        wrongLettersFront.innerHTML = '';
        wrongCountFront.innerHTML = '';
      }

      // Show/hide mic button based on mode (now in control bar, not on card)
      const micBtnControlEl = document.getElementById('mic-btn-control');
      if (currentMode === 'pronunciation') {
        micBtnControlEl.style.display = 'flex';
      } else {
        micBtnControlEl.style.display = 'none';
      }

      // Show/hide control bar buttons based on mode
      // Got It and Confused buttons: only in flashcard mode
      if (currentMode === 'flashcard') {
        gotItBtn.style.display = 'flex';
        confusedBtn.style.display = 'flex';
      } else {
        gotItBtn.style.display = 'none';
        confusedBtn.style.display = 'none';
      }

      // Separator: show in flashcard mode (after /) and pronunciation mode (after )
      if (currentMode === 'flashcard' || currentMode === 'pronunciation') {
        controlSeparator.style.display = 'block';
      } else {
        controlSeparator.style.display = 'none';
      }

      // Show/hide navigation arrows based on mode (only show in flashcard mode - others auto-advance)
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      if (currentMode === 'flashcard') {
        prevBtn.style.display = 'flex';
        nextBtn.style.display = 'flex';
      } else {
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
      }

      // Apply random weathering based on card ID
      const seed = card.id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      weatheringFront.style.background = generateWeathering(seed);
      weatheringBack.style.background = generateWeathering(seed + 1000);

      // Reset flip state
      flashcard.classList.remove('flipped');
      isFlipped = false;
    }

    // ============================================================
    // KEY FEATURE: Auto-pronounce target word in spelling mode
    // - On card navigation (prev/next): auto-pronounce
    // - Helps users learn pronunciation through repetition
    // ============================================================

    // ============================================================
    // GAME-SPECIFIC WRAPPER: Navigate to previous card
    // ============================================================
    // WHY THIS EXISTS: Wraps shared navigateToPrevious() with game-specific:
    //   - Access to local variables (currentDeck, currentIndex, currentMode)
    //   - Game-specific callbacks (initializeTypingDisplay, updateDisplay, saveState)
    //   - Game-specific sound (playCardFlipSound) and speech control
    // REUSABILITY: 2/10 - Other games need different navigation behavior
    // ============================================================
    function goToPrevious() {
      if (currentDeck.length === 0) return;

      navigateToPrevious(
        { deck: currentDeck, currentIndex },
        {
          onNavigate: (newIndex) => {
            speechSynthesis.cancel();
            playCardFlipSound();
            currentIndex = newIndex;
            if (currentMode === 'spelling' || currentMode === 'translation') {
              initializeTypingDisplay();
            }
            updateDisplay();
            saveState();
          },
          onAutoSpeak: currentMode === 'spelling' ? speakSpanish : null
        }
      );
    }

    // ============================================================
    // GAME-SPECIFIC WRAPPER: Navigate to next card
    // ============================================================
    // WHY THIS EXISTS: Wraps shared navigateToNext() with game-specific:
    //   - Access to local variables (currentDeck, currentIndex, currentMode)
    //   - Game-specific callbacks (initializeTypingDisplay, updateDisplay, saveState)
    //   - Game-specific sound (playCardFlipSound) and speech control
    // REUSABILITY: 2/10 - Other games need different navigation behavior
    // ============================================================
    function goToNext() {
      if (currentDeck.length === 0) return;

      navigateToNext(
        { deck: currentDeck, currentIndex },
        {
          onNavigate: (newIndex) => {
            speechSynthesis.cancel();
            playCardFlipSound();
            currentIndex = newIndex;
            if (currentMode === 'spelling' || currentMode === 'translation') {
              initializeTypingDisplay();
            }
            updateDisplay();
            saveState();
          },
          onAutoSpeak: currentMode === 'spelling' ? speakSpanish : null
        }
      );
    }

    // Move to next card (for typing mode completion)
    // ============================================================
    // NOTE: Now uses shared navigateToNext() from wordpack-logic.js (same as goToNext but no speech.cancel)
    // ============================================================
    function moveToNextCard() {
      if (currentDeck.length === 0) return;

      navigateToNext(
        { deck: currentDeck, currentIndex },
        {
          onNavigate: (newIndex) => {
            playCardFlipSound();
            currentIndex = newIndex;
            if (currentMode === 'spelling' || currentMode === 'translation') {
              initializeTypingDisplay();
            }
            updateDisplay();
            saveState();
          },
          onAutoSpeak: currentMode === 'spelling' ? speakSpanish : null
        }
      );
    }

    // ============================================================
    // REMOVED FEATURE: Auto-pronounce on peek/flip removed per user request
    // User prefers manual control via pronounce button
    // ============================================================

    // Flip card
    function flipCard() {
      // Don't stop speech - let it continue while viewing back
      flashcard.classList.add('flipped');
      isFlipped = true;

      // Auto-pronounce removed - users can manually click pronounce button if needed
    }

    // Unflip card
    function unflipCard() {
      // Don't stop speech - let it continue while viewing front
      flashcard.classList.remove('flipped');
      isFlipped = false;
    }

    // Remove current card (Got it!)
    // ============================================================
    // NOTE: Now uses shared removeCard() from wordpack-logic.js
    // ============================================================
    function removeCurrentCard() {
      if (currentDeck.length <= 1) {
        currentDeck = [];
        updateDisplay();
        saveState();

        if (typeof updateDebugTable === 'function') {
          updateDebugTable();
        }
        return;
      }

      // Track deck change for visual indicator
      pendingDeckChange = -1;
      updateDisplay();

      // Show success stamp with ding sound
      showSuccessStamp(() => {
        const result = removeCard(currentDeck, currentIndex);
        currentDeck = result.deck;
        currentIndex = result.newIndex;

        // Clear pending change
        pendingDeckChange = 0;

        // Play sound on page change
        playCardFlipSound();

        // Show next card
        updateDisplay();
        saveState();

        // Update debug table
        if (typeof updateDebugTable === 'function') {
          updateDebugTable();
        }
      });
    }

    // Add extra copies of current card (Confused)
    // ============================================================
    // NOTE: Now uses shared addDuplicateCards() from wordpack-logic.js
    // ============================================================
    function addConfusedCards() {
      if (currentDeck.length === 0) return;

      // Track deck change for visual indicator (+2 cards)
      pendingDeckChange += 2;
      updateDisplay();

      // Show failure stamp with buzz sound
      showFailureStamp(() => {
        const result = addDuplicateCards(currentDeck, currentDeck[currentIndex], 2);
        currentDeck = result.deck;
        currentIndex = result.newIndex;

        // Clear pending change indicator
        pendingDeckChange = 0;

        // Play sound on page change
        playCardFlipSound();

        // Move to next card (already done by addDuplicateCards, but we want wrap-around)
        currentIndex = (currentIndex + 1) % currentDeck.length;
        updateDisplay();
        saveState();
      });
    }

    // ============================================================
    // GAME-SPECIFIC WRAPPER: Reset deck to original state
    // ============================================================
    // WHY THIS EXISTS: Wraps shared resetDeckToOriginal() with game-specific:
    //   - Access to local variables (originalDeck, isFlipped, pendingDeckChange)
    //   - Game-specific callbacks (initializeTypingDisplay, updateDisplay, saveState)
    //   - Flash-card specific behaviors (reset flip state, auto-pronounce)
    // REUSABILITY: 2/10 - Other games need different reset behaviors
    // ============================================================
    function resetDeck() {
      if (originalDeck.length === 0) return;
      playButtonClickSound();

      const result = resetDeckToOriginal(originalDeck, {
        onReset: (newDeck) => {
          currentDeck = newDeck;
          currentIndex = 0;

          // Reset typing state for typing modes
          if (currentMode === 'spelling' || currentMode === 'translation') {
            initializeTypingDisplay();
          }

          // Reset flip state
          if (isFlipped) {
            flashcard.classList.remove('flipped');
            isFlipped = false;
          }

          // Reset deck change indicator
          pendingDeckChange = 0;

          updateDisplay();

          // Auto-pronounce in spelling mode
          if (currentMode === 'spelling' && currentDeck.length > 0) {
            setTimeout(() => speakTargetWord(), 300);
          }

          saveState();
        }
      });

      currentDeck = result.deck;
      currentIndex = result.currentIndex;
    }

    // ============================================================
    // GAME-SPECIFIC WRAPPER: Speak the target word
    // ============================================================
    // WHY THIS EXISTS: Wraps shared speakWord() with game-specific:
    //   - Access to local variables (currentDeck, currentIndex, currentVoice, currentSpeed)
    //   - Gets current card's targetWord from deck
    //   - Uses game's TTS settings
    // REUSABILITY: 3/10 - Similar pattern across games but needs local context
    // ============================================================
    function speakTargetWord() {
      if (currentDeck.length === 0) return;

      // Use shared function from wordpack-logic.js
      window.speakWord(currentDeck[currentIndex].targetWord, {
        languageCode: getTtsLanguageCode(),
        voice: currentVoice,
        speed: currentSpeed
      });
    }

    // Alias for backwards compatibility - some places may still call speakSpanish
    // ============================================================
    // NOTE: speakTargetWord() DELETED - unnecessary wrapper
    // ============================================================
    // This function was just calling speakTargetWord() - no added value.
    // All calls updated to use speakTargetWord() directly.
    // ============================================================

    // ============================================================
    // GAME-SPECIFIC WRAPPER: Set speech speed
    // ============================================================
    // WHY THIS EXISTS: Wraps shared setTTSSpeed() with game-specific:
    //   - Access to local variable (speedBtns)
    //   - Updates local currentSpeed variable
    //   - Calls game's saveState()
    // REUSABILITY: 3/10 - Similar pattern but needs local context
    // ============================================================
    function setSpeed(speed, btn) {
      currentSpeed = setTTSSpeed(speed, Array.from(speedBtns));
      saveState();
    }

    // ============================================================
    // PRONUNCIATION FUNCTIONS - Now in wordpack-logic.js
    // ============================================================
    // The following functions are now in wordpack-logic.js for reuse:
    // - levenshteinDistance()
    // - calculateSimilarity() - Now takes language parameter
    // - getFeedbackMessage()
    // - getScoreClass()
    // - normalizePronunciationText()
    // - getSimilarityThreshold()
    // - updatePronunciationDebug()
    // ============================================================

    // Show pronunciation feedback
    function showFeedback(score, heard, expected, isFront = true) {
      const feedback = isFront ? feedbackFront : feedbackBack;
      const scoreEl = isFront ? scoreFront : scoreBack;
      const messageEl = isFront ? messageFront : messageBack;
      const heardEl = isFront ? heardFront : heardBack;

      // Use dynamic threshold based on word length
      const threshold = getSimilarityThreshold(expected);
      const thresholdPercent = threshold * 100;

      // Speaking mode: Don't show overlay, auto-advance with stamps
      if (currentMode === 'pronunciation') {
        if (score >= thresholdPercent) {
          // Pass! Remove card and advance
          pendingDeckChange = -1;
          updateDisplay();

          // Show success stamp with ding sound (encapsulated)
          showSuccessStamp(() => {
            // Remove card from deck
            if (currentDeck.length <= 1) {
              currentDeck = [];
            } else {
              currentDeck.splice(currentIndex, 1);
              if (currentIndex >= currentDeck.length) {
                currentIndex = 0;
              }
            }

            pendingDeckChange = 0;
            playCardFlipSound();
            updateDisplay();
            saveState();
          });
        } else {
          // Below 70% - add 2 penalty cards and advance (using shared function from wordpack-logic.js)
          const result = addDuplicateCards(currentDeck, currentDeck[currentIndex], 2);
          currentDeck = result.deck;
          currentIndex = result.newIndex;

          setTimeout(() => {
            moveToNextCard();
          }, 1600);
        }
        return; // Don't show overlay
      }

      // Non-pronunciation modes: show feedback overlay
      scoreEl.textContent = `${score}%`;
      scoreEl.className = `feedback-score ${getScoreClass(score)}`;
      messageEl.textContent = getFeedbackMessage(score);
      heardEl.textContent = `Heard: "${heard}"`;

      feedback.classList.add('visible');
    }

    // ============================================================
    // NOTE: hideFeedback() removed - use window.hideFeedback() from wordpack-logic.js
    // Usage: window.hideFeedback([feedbackFront, feedbackBack]);
    // ============================================================

    // Start listening for pronunciation
    function startListening(isFront = true) {
      if (!recognition) {
        alert('Speech recognition is not supported in your browser. Try Chrome or Edge.');
        return;
      }

      if (currentDeck.length === 0) return;
      if (isListening) return;

      isListening = true;
      // Use control bar mic button for listening animation
      micBtnControl.classList.add('spelling');

      recognition.onresult = (event) => {
        const results = event.results[0];
        let bestMatch = results[0].transcript;
        let bestScore = 0;
        let bestNormalizedExpected = '';
        let bestNormalizedHeard = '';

        // Get expected word based on current language
        const card = currentDeck[currentIndex];
        const targetLang = getTargetLanguage();
        const expected = card[targetLang] || card.spanish || '';

        // Get language code for speech recognition
        const languageCode = getTtsLanguageCode() || 'en-US';

        // Check all alternatives for best match
        for (let i = 0; i < results.length; i++) {
          const transcript = results[i].transcript;
          const result = calculateSimilarity(expected, transcript, targetLang);
          if (result.score > bestScore) {
            bestScore = result.score;
            bestMatch = transcript;
            bestNormalizedExpected = result.normalizedExpected;
            bestNormalizedHeard = result.normalizedHeard;
          }
        }

        // Update pronunciation debug panel
        const threshold = getSimilarityThreshold(expected);
        updatePronunciationDebug({
          languageCode,
          expected,
          heard: bestMatch,
          normalizedExpected: bestNormalizedExpected,
          normalizedHeard: bestNormalizedHeard,
          score: bestScore,
          threshold,
          passed: bestScore >= (threshold * 100)
        });

        showFeedback(bestScore, bestMatch, expected, isFront);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        isListening = false;
        micBtnControl.classList.remove('spelling');

        if (event.error === 'no-speech') {
          const card = currentDeck[currentIndex];
          const targetLang = getTargetLanguage();
          const expected = card[targetLang] || card.spanish || '';
          showFeedback(0, '(no speech detected)', expected, isFront);
        } else if (event.error === 'not-allowed') {
          alert('Microphone access denied. Please allow microphone access to use this feature.');
        }
      };

      recognition.onend = () => {
        isListening = false;
        micBtnControl.classList.remove('spelling');
      };

      recognition.start();
    }

    // ============================================================
    // NOTE: updateWordpackTitle() removed - use updateWordpackTitleDisplay() from wordpack-logic.js
    // Usage: updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks);
    // ============================================================

    // Start the game
    // ============================================================
    // KEY FEATURE: Start/Resume Practice Session
    // Core Objective: Begin or continue studying flashcards
    // Key Behaviors:
    //   - If game already started with same wordpack, RESUME without reshuffling
    //   - Only initialize/shuffle deck when starting fresh or changing wordpack
    //   - Front and back of card are ALWAYS linked (same card object)
    // ============================================================
    function startGame() {
      // Values are already set via menu selectors or restored state
      // nativeLanguage and currentWordpackKey are already set

      // Update back label based on language
      updateBackLabel();

      // Update wordpack title
      updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks);

      // Exit starting card state if we're on it
      isOnStartingCard = false;
      flashcard.classList.remove('showing-menu');
      document.body.classList.remove('showing-menu');

      // KEY BEHAVIOR: Only initialize deck if:
      // 1. Game hasn't started yet (fresh start)
      // 2. No deck exists
      // 3. Wordpack changed (different from what's currently loaded)
      const needsNewDeck = !gameStarted ||
                           currentDeck.length === 0 ||
                           (currentDeck.length > 0 && currentDeck[0] &&
                            !currentDeck[0].id.startsWith(currentWordpackKey + '-'));

      if (needsNewDeck) {
        initializeDeck(currentWordpackKey);
      } else {
        // Resume: restore saved position and update display
        currentIndex = savedIndex;
        updateDisplay();
      }

      flashcard.classList.add('game-started');
      document.body.classList.add('game-started');
      gameStarted = true;
      saveState();
    }

    // Event Listeners

    prevBtn.addEventListener('click', () => {
      playButtonClickSound();
      goToPrevious();
    });
    nextBtn.addEventListener('click', () => {
      playButtonClickSound();
      goToNext();
    });
    gotItBtn.addEventListener('click', () => {
      playButtonClickSound();
      removeCurrentCard();
    });
    confusedBtn.addEventListener('click', () => {
      playButtonClickSound();
      addConfusedCards();
    });
    // Peek button (control bar - toggle flip on press)
    peekBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      playButtonClickSound();
      if (isFlipped) {
        unflipCard();
      } else {
        flipCard();
      }
    });
    // Reset/Refresh button - closes menu if open, then resets deck
    resetBtn.addEventListener('click', () => {
      playButtonClickSound();
      // Close menu if open
      if (isOnStartingCard) {
        exitStartingCard();
      }
      resetDeck();
    });

    // Pronounce button (no button click sound per user request)
    pronounceBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      speakTargetWord();
    });

    // Peek button (hold to flip, release to unflip)
    peekBtnFront.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      flipCard();
    });
    peekBtnFront.addEventListener('mouseup', (e) => {
      e.stopPropagation();
      e.preventDefault();
      unflipCard();
    });
    peekBtnFront.addEventListener('mouseleave', (e) => {
      // If user moves mouse off button while holding, unflip
      unflipCard();
    });
    // Touch support for mobile
    peekBtnFront.addEventListener('touchstart', (e) => {
      e.stopPropagation();
      e.preventDefault();
      flipCard();
    });
    peekBtnFront.addEventListener('touchend', (e) => {
      e.stopPropagation();
      e.preventDefault();
      unflipCard();
    });
    peekBtnFront.addEventListener('touchcancel', (e) => {
      e.stopPropagation();
      e.preventDefault();
      unflipCard();
    });

    // Speed buttons
    speedBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        playButtonClickSound();
        const speed = parseFloat(btn.dataset.speed);
        setSpeed(speed, btn);
        // Play sample at new speed if game has started
        if (gameStarted && currentDeck.length > 0) {
          speakTargetWord();
        }
      });
    });

    // Mic button in control bar (pronunciation mode)
    micBtnControl.addEventListener('click', (e) => {
      e.stopPropagation();
      playButtonClickSound();
      // Use current card side (front or back) for feedback display
      startListening(!isFlipped);
    });

    // Close feedback buttons
    closeFront.addEventListener('click', (e) => {
      e.stopPropagation();
      playButtonClickSound();
      window.hideFeedback([feedbackFront, feedbackBack]);
    });
    closeBack.addEventListener('click', (e) => {
      e.stopPropagation();
      playButtonClickSound();
      window.hideFeedback([feedbackFront, feedbackBack]);
    });

    // Menu button - toggle menu on/off
    menuBtn.addEventListener('click', () => {
      playButtonClickSound();
      if (isOnStartingCard) {
        exitStartingCard(); // Close menu if already showing
      } else {
        showStartingCard(false); // Show menu on card
      }
    });

    // Fullscreen button - toggle fullscreen mode
    fullscreenBtn.addEventListener('click', () => {
      playButtonClickSound();
      if (!document.fullscreenElement) {
        // Enter fullscreen
        document.documentElement.requestFullscreen().catch(err => {
          console.warn('Could not enter fullscreen:', err);
        });
      } else {
        // Exit fullscreen
        document.exitFullscreen().catch(err => {
          console.warn('Could not exit fullscreen:', err);
        });
      }
    });

    // Update fullscreen button icon when fullscreen state changes
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        fullscreenBtn.textContent = ''; // Already fullscreen - same icon works for exit
      } else {
        fullscreenBtn.textContent = ''; // Normal mode
      }
    });

    // KEY FEATURE: Click outside menu to close it
    // Clicking anywhere outside the flashcard area closes the menu
    document.addEventListener('click', (e) => {
      if (!isOnStartingCard) return; // Only when menu is open

      // Check if click is outside the flashcard
      const flashcardEl = document.querySelector('.flashcard');
      if (!flashcardEl.contains(e.target)) {
        // Also check it's not the menu button itself (handled separately)
        if (!menuBtn.contains(e.target)) {
          exitStartingCard();
        }
      }
    });

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      // Don't handle navigation if on starting card (menu)
      if (isOnStartingCard) {
        return;
      }

      // Handle typing in listening and translation modes (accept letters, numbers, symbols - not space)
      if ((currentMode === 'spelling' || currentMode === 'translation') && e.key.length === 1 && e.key !== ' ') {
        e.preventDefault();
        handleTypingInput(e.key);
        return;
      }

      // Enter key removed from listening/translation modes - user should use navigation buttons

      // Prevent repeated actions when holding key down
      if (keysPressed[e.key]) {
        e.preventDefault();
        return;
      }
      keysPressed[e.key] = true;

      if (e.key === 'ArrowLeft') {
        // Only allow left arrow in flashcard mode
        if (currentMode === 'flashcard') {
          goToPrevious();
        }
      } else if (e.key === 'ArrowRight') {
        // Only allow right arrow in flashcard mode
        if (currentMode === 'flashcard') {
          goToNext();
        }
      } else if (e.key === 'ArrowUp') {
        // Up arrow: ALWAYS pronounce
        e.preventDefault();
        speakTargetWord();
      } else if (e.key === 'ArrowDown') {
        // Down arrow: Hold to see translation (flip on keydown, unflip on keyup)
        e.preventDefault();
        flipCard();
      } else if (e.key === '1') {
        // Key 1: Remove card (Got it!) - only in flashcard mode
        if (currentMode === 'flashcard') {
          e.preventDefault();
          removeCurrentCard();
        }
      } else if (e.key === '2') {
        // Key 2: Add practice cards (Confused) - only in flashcard mode
        if (currentMode === 'flashcard') {
          e.preventDefault();
          addConfusedCards();
        }
      } else if (e.key === ' ') {
        // Space: pronounce in flashcard mode, record in pronunciation mode, play sound in translation mode, ignore in listening
        if (currentMode === 'flashcard') {
          e.preventDefault();
          speakTargetWord();
        } else if (currentMode === 'pronunciation') {
          e.preventDefault();
          // Trigger mic button based on which side of card is showing
          const isFront = !isFlipped;
          startListening(isFront);
        } else if (currentMode === 'translation') {
          e.preventDefault();
          playScribbleSound(); // Play scribble sound but don't register input
        } else if (currentMode === 'spelling') {
          e.preventDefault(); // Ignore space in spelling mode
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      // Clear key state
      keysPressed[e.key] = false;

      // Down arrow: Release to unflip (hold behavior)
      if (e.key === 'ArrowDown') {
        unflipCard();
      }
    });

    // Mode selector event listeners
    // KEY FEATURE: Clicking mode while menu open closes menu and switches to that mode
    modeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        playButtonClickSound();
        const mode = btn.dataset.mode;
        // Close menu if open, then switch mode
        if (isOnStartingCard) {
          exitStartingCard();
        }
        switchMode(mode);
      });
    });

    // Initialize
    initializeApp();

    // ============================================================
    // DEBUG UI - Now handled by wordpack-logic.js
    // ============================================================
    // Debug functionality moved to wordpack-logic.js:
    // - DEBUG_MODE flag (toggled by hotkey: Ctrl+Shift+Alt+DEBUG)
    // - updateDebugTable(options) function
    // - initializeDebugUI() to create debug table
    // - toggleDebugMode() for programmatic control
    //
    // Initialize debug UI (creates debug table in DOM if not exists)
    initializeDebugUI();

    // ============================================================
    // DEBUG: Wrapper to update table with local scope data
    // ============================================================
    // The external updateDebugTable() can't access local variables, so we wrap it

    // CRITICAL: Save reference to ORIGINAL function BEFORE overriding
    const originalUpdateDebugTable = window.updateDebugTable || updateDebugTable;

    function updateDebugTableWrapper() {
      if (!window.DEBUG_MODE) return;

      // Call the ORIGINAL function (not the wrapper!) with data from local scope
      originalUpdateDebugTable({
        deck: currentDeck,
        targetLang: getTargetLanguage() || 'target',
        nativeLang: nativeLanguage || 'native',
        wordColumns: getWordColumns() || [],
        translations: getTranslationsConfig() || {}
      });
    }

    // Override the global updateDebugTable to use our wrapper
    window.updateDebugTable = updateDebugTableWrapper;

    // ============================================================
    // DEBUG: Simulate Functions (called by buttons in debug table)
    // ============================================================

    // ============================================================
    // NOTE: Debug simulation now uses shared simulateCorrectAnswer() from wordpack-logic.js
    // ============================================================
    // Simulate Right Answer - removes current card (correct answer behavior)
    window.simulateRight = function() {
      if (currentDeck.length === 0) return;

      playDingSound();

      const result = simulateCorrectAnswer(currentDeck, currentIndex, () => {
        if (currentMode === 'spelling' || currentMode === 'translation') {
          initializeTypingDisplay();
        }
        updateDisplay();
        saveState();
        updateDebugTable();
        console.log('[Debug] Simulated RIGHT answer - card removed');
      });

      currentDeck = result.deck;
      currentIndex = result.currentIndex;
    };

    // ============================================================
    // NOTE: Debug simulation now uses shared simulateWrongAnswer() from wordpack-logic.js
    // ============================================================
    // Simulate Wrong Answer - adds 2 duplicate cards (wrong answer behavior)
    window.simulateWrong = function() {
      if (currentDeck.length === 0) return;

      playBuzzSound();

      const result = simulateWrongAnswer(currentDeck, currentIndex, 2, () => {
        if (currentMode === 'spelling' || currentMode === 'translation') {
          initializeTypingDisplay();
        }
        updateDisplay();
        saveState();
        updateDebugTable();
        console.log('[Debug] Simulated WRONG answer - added 2 duplicate cards');
      });

      currentDeck = result.deck;
      currentIndex = result.currentIndex;
    };

    // ============================================================
    // NOTE: Debug simulation now uses shared simulateNearVictory() from wordpack-logic.js
    // ============================================================
    // Simulate Near Victory - remove all cards except last one
    window.simulateNearVictory = function() {
      if (currentDeck.length === 0) return;

      playButtonClickSound();

      const result = simulateNearVictory(currentDeck, () => {
        if (currentMode === 'spelling' || currentMode === 'translation') {
          initializeTypingDisplay();
        }
        updateDisplay();
        saveState();
        updateDebugTable();
        console.log('[Debug] Simulated NEAR VICTORY - only last card remains');
      });

      currentDeck = result.deck;
      currentIndex = result.currentIndex;
    };

    // ============================================================
    // Difficulty Selector Event Listeners
    // ============================================================
    const difficultySelector = document.getElementById('difficulty-selector');
    if (difficultySelector) {
      // Set initial checked state
      const difficultyRadios = difficultySelector.querySelectorAll('input[name="difficulty"]');
      difficultyRadios.forEach(radio => {
        if (radio.value === currentDifficulty) {
          radio.checked = true;
        }
      });

      // Handle difficulty changes
      difficultyRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          playButtonClickSound();
          const newDifficulty = e.target.value;
          currentDifficulty = newDifficulty;

          // Save to localStorage
          localStorage.setItem('difficulty', newDifficulty);

          // Reinitialize deck with new difficulty
          if (currentWordpackKey && wordpacks[currentWordpackKey]) {
            initializeDeck(currentWordpackKey);
            updateWordpackTitleDisplay(wordpackTitle, currentWordpackKey, wordpacks);
            updateDisplay();
            saveState();

            // Update debug table
            if (typeof updateDebugTable === 'function') {
              updateDebugTable();
            }
          }

          console.log(`[Difficulty] Changed to: ${newDifficulty}`);
        });
      });
    }
  </script>

  <!-- Debug UI is now generated dynamically by wordpack-logic.js via initializeDebugUI() -->
  <!-- Toggle debug mode with hotkey: Ctrl + ` (backtick key, next to "1") -->
</body>
</html>
