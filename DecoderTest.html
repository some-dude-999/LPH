<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wordpack Data Structure Debugger</title>

  <!--
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                                              â•‘
    â•‘   ğŸ® LANGUAGE LEARNING GAME - REFERENCE TEMPLATE IMPLEMENTATION ğŸ®           â•‘
    â•‘                                                                              â•‘
    â•‘   This file serves as the CANONICAL REFERENCE for all language learning     â•‘
    â•‘   games in this project. It demonstrates 100% compliance with our design    â•‘
    â•‘   principles and should be used as a template for building new games.       â•‘
    â•‘                                                                              â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    ============================================================
    TABLE OF CONTENTS
    ============================================================
    1. DESIGN PRINCIPLES OVERVIEW
    2. DATA STRUCTURE ARCHITECTURE
    3. STATE PERSISTENCE (localStorage)
    4. DRY (Don't Repeat Yourself) PATTERNS
    5. KEY FEATURES DOCUMENTATION
    6. COLUMN MAPPING BY LANGUAGE
    7. HOW TO USE THIS TEMPLATE

    ============================================================
    1. DESIGN PRINCIPLES OVERVIEW
    ============================================================

    This project follows strict design principles to ensure maintainability,
    consistency, and ease of development. ALL games must follow these rules:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 1: KEY FEATURES ARE SACRED                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - Every important feature MUST have a KEY FEATURE comment block        â”‚
    â”‚ - KEY FEATURES document: Core Objective + Key Behaviors                â”‚
    â”‚ - KEY FEATURES can NEVER be removed without explicit user request      â”‚
    â”‚ - Code can change, but the FEATURE must be preserved                   â”‚
    â”‚                                                                        â”‚
    â”‚ FORMAT:                                                                â”‚
    â”‚   // ============================================================     â”‚
    â”‚   // KEY FEATURE: [High-level description]                            â”‚
    â”‚   // Core Objective: [Why this feature exists]                        â”‚
    â”‚   // Key Behaviors:                                                   â”‚
    â”‚   //   - [Behavior 1 that must be preserved]                          â”‚
    â”‚   //   - [Behavior 2 that must be preserved]                          â”‚
    â”‚   // ============================================================     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 2: DRY (Don't Repeat Yourself) - ENCAPSULATION               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - NEVER copy-paste the same code in multiple places                    â”‚
    â”‚ - If something happens together, put it in ONE function                â”‚
    â”‚ - Ask: "If I needed to change this, how many places would I update?"   â”‚
    â”‚ - If answer > 1, you need to encapsulate                               â”‚
    â”‚                                                                        â”‚
    â”‚ EXAMPLES IN THIS FILE:                                                 â”‚
    â”‚   - autoSelectFirstActAndPack(): Called from 2 places                  â”‚
    â”‚   - setupModeCheckboxes(): Config-driven, not 3 separate functions     â”‚
    â”‚   - resetListeningState(): Used in 3 event handlers                    â”‚
    â”‚   - normalizeCharForTyping(): Single function for accent removal       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 3: STATE PERSISTENCE (localStorage) - MANDATORY              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - ALL user-configurable settings MUST be saved to localStorage         â”‚
    â”‚ - On page load, restore saved state (or use sensible defaults)         â”‚
    â”‚ - User should return to EXACTLY where they left off                    â”‚
    â”‚ - Validate saved values against current valid options                  â”‚
    â”‚                                                                        â”‚
    â”‚ WHAT MUST BE SAVED:                                                    â”‚
    â”‚   - Language selection (Spanish, Chinese, English)                     â”‚
    â”‚   - Act selection                                                      â”‚
    â”‚   - Pack selection                                                     â”‚
    â”‚   - Native language ("I speak") selection                              â”‚
    â”‚   - Mode toggles (multiple choice, typing, pronunciation)              â”‚
    â”‚   - Any other user preference                                          â”‚
    â”‚                                                                        â”‚
    â”‚ WHEN TO SAVE:                                                          â”‚
    â”‚   - On ANY menu/setting change                                         â”‚
    â”‚   - Call saveState() immediately after state change                    â”‚
    â”‚                                                                        â”‚
    â”‚ VALIDATION RULE:                                                       â”‚
    â”‚   - Always validate saved values against current valid options         â”‚
    â”‚   - If saved value is invalid, fall back to default                    â”‚
    â”‚   - This prevents bugs when options change between versions            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 4: SINGLE SOURCE OF TRUTH (Configuration Objects)            â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - All configuration lives in JavaScript objects, NOT hardcoded HTML    â”‚
    â”‚ - Dropdowns are EMPTY in HTML, populated from config                   â”‚
    â”‚ - If you delete the config, NOTHING should work                        â”‚
    â”‚                                                                        â”‚
    â”‚ IN THIS FILE:                                                          â”‚
    â”‚   - LANGUAGE_CONFIG: All module paths, columns, native languages       â”‚
    â”‚   - VALID_MODES: List of valid mode options for validation             â”‚
    â”‚   - HTML dropdowns: Empty <select></select> elements                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ============================================================
    2. DATA STRUCTURE ARCHITECTURE
    ============================================================

    Our language learning data follows a hierarchical structure:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         DATA HIERARCHY                                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                                        â”‚
    â”‚   LANGUAGE (Spanish, Chinese, English)                                 â”‚
    â”‚       â”‚                                                                â”‚
    â”‚       â””â”€â”€ ACT (Learning Stage - e.g., "Foundation", "Daily Life")      â”‚
    â”‚             â”‚                                                          â”‚
    â”‚             â””â”€â”€ WORDPACK (Vocabulary Set - e.g., "Greetings")          â”‚
    â”‚                   â”‚                                                    â”‚
    â”‚                   â”œâ”€â”€ META (Pack metadata: number, titles)             â”‚
    â”‚                   â”‚                                                    â”‚
    â”‚                   â””â”€â”€ WORDS (Array of word arrays)                     â”‚
    â”‚                         â”‚                                              â”‚
    â”‚                         â””â”€â”€ WORD (Array of translations by column)     â”‚
    â”‚                                                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    OBFUSCATED MODULE STRUCTURE:
    Each .js module exports a dictionary of wordpacks:

    {
      "p{act}_{pack}_{name}": {
        "meta": {
          "wordpack": 1,                    // Pack number (integer)
          "english": "Greetings & Goodbyes", // Pack title in English
          "chinese": "é—®å€™è¯­",                // Pack title in Chinese
          "spanish": "Saludos y Despedidas", // Pack title in Spanish
          ... // Other language translations as supported
        },
        "words": [
          ["word1_col0", "word1_col1", "word1_col2", ...],  // Each word = array
          ["word2_col0", "word2_col1", "word2_col2", ...],
          ["word3_col0", "word3_col1", "word3_col2", ...]
        ]
      },
      "p{act}_{pack}_{name}": { ... },
      ...
    }

    CRITICAL: Column 0 is ALWAYS the target language being learned!

    ============================================================
    3. STATE PERSISTENCE (localStorage) - IMPLEMENTATION
    ============================================================

    Every game MUST implement these functions:

    const STORAGE_KEY = 'uniqueGameNameState';  // Unique per game

    function saveState() {
      const stateToSave = {
        language: state.currentLanguage,
        act: state.currentAct,
        pack: state.currentPack,
        nativeLanguage: state.currentNativeLanguage,
        // ... all other user settings
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    }

    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        return saved ? JSON.parse(saved) : null;
      } catch (e) {
        console.error('Failed to load state:', e);
        return null;
      }
    }

    function restoreSavedState() {
      const saved = loadState();
      if (!saved) return;

      // ALWAYS validate before restoring!
      if (saved.language && VALID_LANGUAGES.includes(saved.language)) {
        state.currentLanguage = saved.language;
      }
      // ... validate and restore other settings
    }

    ============================================================
    4. DRY PATTERNS - EXAMPLES IN THIS FILE
    ============================================================

    PATTERN 1: Encapsulated Helper Functions
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PROBLEM: Same 5 lines of code in 2+ places
    SOLUTION: Extract to named function, call from both places

    Example: autoSelectFirstActAndPack()
    - Used in: initialize(), setupLanguageRadioButtons()
    - Benefit: Change logic in ONE place

    PATTERN 2: Configuration-Driven Loops
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PROBLEM: 3 separate functions doing almost the same thing
    SOLUTION: One function with config array

    Example: setupModeCheckboxes()
    - Config: [{ id, stateKey, statesToClear }, ...]
    - One loop handles all checkboxes identically
    - Add new checkbox = add to config array

    PATTERN 3: Callback Parameters
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PROBLEM: Same action with different follow-up
    SOLUTION: Function takes callback parameter

    Example: showSuccessStamp(onComplete)
    - Stamp + sound + delay always happen together
    - What happens AFTER varies
    - Pass the variation as callback

    ============================================================
    5. KEY FEATURES IN THIS FILE
    ============================================================

    Search for "KEY FEATURE:" to find all documented features:

    1. Global State Management - Single source of truth for UI state
    2. State Persistence (localStorage) - Save/restore user settings
    3. Module Decoding - 3-layer obfuscation (base64 + zlib + reverse)
    4. Auto-Select First Act/Pack - DRY encapsulated function
    5. Language Selection - Switch between target languages
    6. Mode Checkboxes - DRY config-driven setup
    7. Speech Recognition - Pronunciation practice with scoring
    8. Multiple Choice Generation - Act-wide pool, duplicate filtering
    9. Typing Practice - Character-by-character with accent tolerance
    10. Vocabulary Table Display - Multi-mode rendering

    ============================================================
    6. COLUMN MAPPING BY LANGUAGE
    ============================================================

    SPANISH (5 columns):
      [0] = Spanish (TARGET - language being learned)
      [1] = English
      [2] = Chinese
      [3] = Pinyin
      [4] = Portuguese

    CHINESE (12 columns):
      [0] = Chinese (TARGET - language being learned)
      [1] = Pinyin
      [2] = English
      [3] = Spanish
      [4] = French
      [5] = Portuguese
      [6] = Vietnamese
      [7] = Thai
      [8] = Khmer
      [9] = Indonesian
      [10] = Malay
      [11] = Filipino

    ENGLISH (5 columns):
      [0] = English (TARGET - language being learned)
      [1] = Chinese
      [2] = Pinyin
      [3] = Spanish
      [4] = Portuguese

    ============================================================
    7. HOW TO USE THIS TEMPLATE
    ============================================================

    To create a new game based on this template:

    1. Copy this file as your starting point
    2. Change STORAGE_KEY to unique value for your game
    3. Keep all KEY FEATURE implementations
    4. Keep all DRY helper functions
    5. Keep localStorage save/restore pattern
    6. Add your game-specific features with KEY FEATURE comments
    7. Follow the same documentation style

    CHECKLIST FOR NEW GAMES:
    â–¡ Unique STORAGE_KEY defined
    â–¡ saveState() called on every setting change
    â–¡ loadState() called during initialization
    â–¡ Saved values validated against valid options
    â–¡ All KEY FEATURES documented with comment blocks
    â–¡ No copy-pasted code (use encapsulated functions)
    â–¡ Configuration objects as single source of truth
    â–¡ Empty HTML dropdowns, populated from JS config

    ============================================================
  -->

  <!--
    ============================================================
    PAKO.JS DEPENDENCY - Required for decompressing obfuscated modules
    ============================================================
    Our obfuscated modules use zlib compression (via pako library).
    This CDN script provides the pako.inflate() function for decompression.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>

  <h1>Wordpack Data Structure Debugger</h1>
  <p>Technical reference for language learning game data architecture</p>

  <hr>

  <!--
    ============================================================
    LANGUAGE SELECTION - Radio Buttons
    ============================================================
    Choose which target language's wordpacks to load.
    Default: Spanish
  -->
  <h2>1. Select Target Language</h2>
  <p>Which language are you learning?</p>
  <label>
    <input type="radio" name="language" value="Spanish" checked>
    Spanish
  </label>
  <label>
    <input type="radio" name="language" value="Chinese">
    Chinese
  </label>
  <label>
    <input type="radio" name="language" value="English">
    English
  </label>

  <hr>

  <!--
    ============================================================
    ACT SELECTION - Dropdown
    ============================================================
    Acts are learning stages. Each language has different numbers of acts:
    - Spanish: 7 acts
    - Chinese: 5 acts
    - English: 5 acts
  -->
  <h2>2. Select Act (Learning Stage)</h2>
  <p>Acts are grouped learning stages containing multiple wordpacks.</p>
  <select id="actSelect">
  </select>

  <hr>

  <!--
    ============================================================
    WORDPACK SELECTION - Dropdown
    ============================================================
    Each act contains multiple wordpacks (vocabulary sets).
    This dropdown populates based on the selected act.
  -->
  <h2>3. Select Wordpack</h2>
  <p>Individual vocabulary set within the selected act.</p>
  <select id="packSelect">
  </select>

  <hr>

  <!--
    ============================================================
    NATIVE LANGUAGE SELECTION - "I Speak" Dropdown
    ============================================================
    This determines which column to display in the right column of the table.
    Column 0 (left) is always the target language being learned.
    Column N (right) is the native language the user speaks.

    Available options depend on the target language's column structure.
  -->
  <h2>4. Select Your Native Language (I Speak)</h2>
  <p>Which language do you speak? This determines the translation column shown.</p>
  <select id="nativeLanguageSelect">
  </select>

  <hr>

  <!--
    ============================================================
    VOCABULARY TABLE - With Optional Multiple Choice Mode
    ============================================================
    Displays the selected wordpack's vocabulary.

    BASIC MODE (Default):
    - 2 columns: Target language (column 0) and Native language (selected)

    MULTIPLE CHOICE MODE (Checkbox enabled):
    - 6 columns total:
      1. Target language (correct answer, column 0)
      2. Native language translation (column N)
      3-6. Four wrong answers (randomly selected from ENTIRE ACT, ~2,500 words)

    WRONG ANSWER POOL:
    Wrong answers are now pulled from ALL wordpacks in the current act,
    not just the current wordpack. This provides:
    - Greater variety (2,500 options vs 50)
    - Less predictable patterns
    - Better simulation of real game mechanics
    - Zero performance cost (all data already loaded in memory)

    DUPLICATE FILTERING:
    Uses normalized string comparison (lowercase, no spaces/symbols)
    to avoid showing essentially identical words:
    - "hola" vs "Hola" (case difference) - filtered
    - "hello friend" vs "hellofriend" (spacing) - filtered
    - "hello!" vs "hello" (punctuation) - filtered

    This demonstrates the CORE LOGIC for generating multiple choice questions
    used in language learning games. Different game mechanics require different
    numbers of choices:
    - Temple Run style: 3 choices (1 correct + 2 wrong)
    - Quiz games: 4 choices (1 correct + 3 wrong)
    - This demo: 6 choices (1 correct + 4 wrong) to show extensibility

    The algorithm works for ANY target language (Spanish, Chinese, English, etc.)
    and ANY future language packs we add to the system.
  -->
  <h2>5. Vocabulary Table</h2>
  <p><strong>Pack Title:</strong> <span id="packTitle">Select a wordpack to view</span></p>

  <!--
    MULTIPLE CHOICE MODE CHECKBOX
    When enabled, adds 4 columns of wrong answers randomly selected from
    ALL wordpacks in the current act (~2,500 words). This shows how game
    mechanics generate distractors with variety and duplicate filtering.
  -->
  <p>
    <label>
      <input type="checkbox" id="multipleChoiceMode">
      Multiple Choice Mode (adds 4 wrong answer columns from entire act - game mechanics demo)
    </label>
  </p>

  <!--
    TYPING MODE CHECKBOX
    When enabled, adds 3 columns for interactive typing practice:
    - Column 3: Typing input box with masked placeholders (X for each letter)
    - Column 4: Wrong letters attempted (crossed out display)
    - Column 5: Wrong attempt count

    This demonstrates the CORE TYPING MECHANIC used in language learning games
    like SimpleFlashCards.html. The mechanic includes:
    - Character-by-character input validation
    - Accent-insensitive comparison (Ã¡ = a, Ã± = n, etc.)
    - Case-insensitive matching
    - Satisfying typing sound on every keypress (correct or wrong)
    - Automatic space handling (spaces ignored, auto-advanced)
    - Wrong letter tracking for feedback

    IMPROVEMENTS OVER SimpleFlashCards.html:
    - Simpler state management (per-row instead of global)
    - More modular code structure (easier to copy to other games)
    - Cleaner normalization logic
    - Better commented for human/LLM understanding
  -->
  <p>
    <label>
      <input type="checkbox" id="typingMode">
      Typing Mode (adds typing practice columns - game mechanics demo)
    </label>
  </p>

  <!--
    PRONUNCIATION MODE CHECKBOX
    When enabled, adds 2 columns for speech recognition practice:
    - Column 3: Record button (ğŸ¤) to capture user's pronunciation
    - Column 4: Percentage correct (similarity score using Levenshtein distance)

    CORE LOGIC:
    - Web Speech API for speech recognition
    - Levenshtein distance for fuzzy string matching
    - Language-specific recognition (es-ES, zh-CN, en-US)
    - Works best in Chrome/Edge browsers
  -->
  <p>
    <label>
      <input type="checkbox" id="pronunciationMode">
      Pronunciation Mode (adds record button and accuracy percentage - speech recognition demo)
    </label>
  </p>

  <table border="1" cellpadding="8" cellspacing="0">
    <thead>
      <tr id="tableHeaderRow">
        <th id="col1Header">I am learning</th>
        <th id="col2Header">I speak</th>
      </tr>
    </thead>
    <tbody id="vocabularyTable">
      <tr>
        <td colspan="2">Loading data...</td>
      </tr>
    </tbody>
  </table>

  <hr>

  <!--
    ============================================================
    DEBUG INFORMATION
    ============================================================
    Shows technical details about loaded data for debugging purposes.
  -->
  <h2>6. Debug Information</h2>
  <pre id="debugInfo">Initializing...</pre>

  <!--
    ============================================================
    JAVASCRIPT MODULE - Main Logic
    ============================================================
    This section contains all the JavaScript logic for:
    1. Decoding obfuscated modules (3-layer: base64 + zlib + string reversal)
    2. Loading language data automatically on page load
    3. Populating dropdowns dynamically
    4. Displaying vocabulary in 2-column table
    5. Handling user interactions (language/act/pack/native language changes)
  -->
  <script type="module">

    // ============================================================
    // KEY FEATURE: State Persistence (localStorage)
    // Core Objective: Save and restore ALL user settings across sessions
    // Key Behaviors:
    //   - Save state on EVERY setting change (language, act, pack, modes)
    //   - Restore state on page load with validation
    //   - Validate saved values against current valid options
    //   - Fall back to defaults if saved values are invalid
    // ============================================================

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ STORAGE_KEY - Unique identifier for this game's localStorage           â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ IMPORTANT: Each game MUST have a unique STORAGE_KEY!                   â”‚
      â”‚                                                                        â”‚
      â”‚ When creating a new game from this template:                           â”‚
      â”‚   1. Change this value to something unique (e.g., 'myNewGameState')    â”‚
      â”‚   2. This prevents different games from overwriting each other's data  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    const STORAGE_KEY = 'decoderTestState';

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ VALID OPTIONS - Used for validating saved state                        â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ These arrays define what values are acceptable for each setting.       â”‚
      â”‚ When restoring saved state, we check if the saved value is in these.   â”‚
      â”‚ If not, we fall back to the default value.                             â”‚
      â”‚                                                                        â”‚
      â”‚ WHY THIS MATTERS:                                                      â”‚
      â”‚ If you change valid options (e.g., add/remove a language), users with  â”‚
      â”‚ old saved state won't have invalid values restored.                    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    const VALID_LANGUAGES = ['Spanish', 'Chinese', 'English'];

    // ============================================================
    // CONFIGURATION: Language Module Paths and Column Structures
    // ============================================================

    /*
      This configuration maps each target language to:
      1. Module file paths (obfuscated .js files for each act)
      2. Column structure (what each column index represents)
      3. Available native languages (for "I speak" dropdown)
    */
    const LANGUAGE_CONFIG = {
      'Spanish': {
        modules: [
          { act: 1, name: 'Foundation', path: './SpanishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './SpanishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Daily Life', path: './SpanishWords/Jsmodules-js/act3-daily-life-js.js' },
          { act: 4, name: 'Expanding Expression', path: './SpanishWords/Jsmodules-js/act4-expanding-expression-js.js' },
          { act: 5, name: 'Intermediate Mastery', path: './SpanishWords/Jsmodules-js/act5-intermediate-mastery-js.js' },
          { act: 6, name: 'Advanced Constructs', path: './SpanishWords/Jsmodules-js/act6-advanced-constructs-js.js' },
          { act: 7, name: 'Mastery Fluency', path: './SpanishWords/Jsmodules-js/act7-mastery-fluency-js.js' }
        ],
        columns: ['Spanish', 'English', 'Chinese', 'Pinyin', 'Portuguese'],
        nativeLanguages: {
          'English': 1,
          'Chinese': 2,
          'Pinyin': 3,
          'Portuguese': 4
        }
      },
      'Chinese': {
        modules: [
          { act: 1, name: 'Foundation', path: './ChineseWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Development', path: './ChineseWords/Jsmodules-js/act2-development-js.js' },
          { act: 3, name: 'Expansion', path: './ChineseWords/Jsmodules-js/act3-expansion-js.js' },
          { act: 4, name: 'Mastery', path: './ChineseWords/Jsmodules-js/act4-mastery-js.js' },
          { act: 5, name: 'Refinement', path: './ChineseWords/Jsmodules-js/act5-refinement-js.js' }
        ],
        columns: ['Chinese', 'Pinyin', 'English', 'Spanish', 'French', 'Portuguese', 'Vietnamese', 'Thai', 'Khmer', 'Indonesian', 'Malay', 'Filipino'],
        nativeLanguages: {
          'English': 2,
          'Spanish': 3,
          'French': 4,
          'Portuguese': 5,
          'Vietnamese': 6,
          'Thai': 7,
          'Khmer': 8,
          'Indonesian': 9,
          'Malay': 10,
          'Filipino': 11
        }
      },
      'English': {
        modules: [
          { act: 1, name: 'Foundation', path: './EnglishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './EnglishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Everyday Life', path: './EnglishWords/Jsmodules-js/act3-everyday-life-js.js' },
          { act: 4, name: 'Expanding Horizons', path: './EnglishWords/Jsmodules-js/act4-expanding-horizons-js.js' },
          { act: 5, name: 'Advanced Mastery', path: './EnglishWords/Jsmodules-js/act5-advanced-mastery-js.js' }
        ],
        columns: ['English', 'Chinese', 'Pinyin', 'Spanish', 'Portuguese'],
        nativeLanguages: {
          'Chinese': 1,
          'Pinyin': 2,
          'Spanish': 3,
          'Portuguese': 4
        }
      }
    };

    // ============================================================
    // KEY FEATURE: Global State Management
    // Core Objective: Single source of truth for all UI state
    // Key Behaviors:
    //   - Tracks current language, act, pack selections
    //   - Tracks mode toggles (multiple choice, typing, pronunciation)
    //   - Per-word state for interactive modes (typing progress, scores)
    // ============================================================

    /*
      Global state object tracks:
      - currentLanguage: Which target language is selected
      - loadedData: Dictionary mapping act numbers to decoded wordpack data
      - currentAct: Currently selected act number
      - currentPack: Currently selected wordpack key
      - currentNativeLanguage: Column index for native language
      - multipleChoiceMode: Boolean flag for showing wrong answer columns
      - typingMode: Boolean flag for showing typing practice columns
      - typingStates: Map tracking typing state for each word (wordIndex -> state object)
      - pronunciationMode: Boolean flag for showing pronunciation practice columns
      - pronunciationStates: Map tracking pronunciation state for each word (wordIndex -> { score, heard, attempted })
    */
    let state = {
      currentLanguage: 'Spanish',  // Default language
      loadedData: {},               // { actNumber: { packKey: {meta, words}, ... } }
      currentAct: null,
      currentPack: null,
      currentNativeLanguage: 1,     // Default to English column (index 1 for Spanish)
      multipleChoiceMode: false,    // Default to basic 2-column mode
      typingMode: false,            // Default to typing mode off
      typingStates: new Map(),      // Per-word typing state { typed: Set(), wrongLetters: [], wrongCount: 0 }
      pronunciationMode: false,     // Default to pronunciation mode off
      pronunciationStates: new Map() // Per-word pronunciation state { score: null, heard: '', attempted: false }
    };

    // ============================================================
    // STATE PERSISTENCE FUNCTIONS (localStorage)
    // ============================================================

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ saveState() - Save ALL user-configurable settings to localStorage      â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ WHEN TO CALL:                                                          â”‚
      â”‚   - On language change                                                 â”‚
      â”‚   - On act change                                                      â”‚
      â”‚   - On pack change                                                     â”‚
      â”‚   - On native language change                                          â”‚
      â”‚   - On any mode toggle (multiple choice, typing, pronunciation)        â”‚
      â”‚                                                                        â”‚
      â”‚ WHAT WE SAVE:                                                          â”‚
      â”‚   - currentLanguage: Target language being learned                     â”‚
      â”‚   - currentAct: Selected act number                                    â”‚
      â”‚   - currentPack: Selected pack key                                     â”‚
      â”‚   - currentNativeLanguage: Column index for "I speak" language         â”‚
      â”‚   - multipleChoiceMode: Boolean for wrong answers mode                 â”‚
      â”‚   - typingMode: Boolean for typing practice mode                       â”‚
      â”‚   - pronunciationMode: Boolean for speech recognition mode             â”‚
      â”‚                                                                        â”‚
      â”‚ WHAT WE DON'T SAVE:                                                    â”‚
      â”‚   - loadedData: Too large, will be reloaded on page load               â”‚
      â”‚   - typingStates: Per-session progress, not persistent                 â”‚
      â”‚   - pronunciationStates: Per-session progress, not persistent          â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function saveState() {
      const stateToSave = {
        currentLanguage: state.currentLanguage,
        currentAct: state.currentAct,
        currentPack: state.currentPack,
        currentNativeLanguage: state.currentNativeLanguage,
        multipleChoiceMode: state.multipleChoiceMode,
        typingMode: state.typingMode,
        pronunciationMode: state.pronunciationMode
      };

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
      } catch (e) {
        console.error('Failed to save state to localStorage:', e);
      }
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ loadState() - Load saved state from localStorage                       â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ RETURNS:                                                               â”‚
      â”‚   - Parsed state object if found and valid JSON                        â”‚
      â”‚   - null if no saved state or invalid JSON                             â”‚
      â”‚                                                                        â”‚
      â”‚ NOTE: This just loads the raw data. Validation happens in              â”‚
      â”‚ restoreSavedState() to separate concerns.                              â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        return saved ? JSON.parse(saved) : null;
      } catch (e) {
        console.error('Failed to load state from localStorage:', e);
        return null;
      }
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ restoreSavedState() - Restore and VALIDATE saved state                 â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ CRITICAL: Always validate saved values before restoring!               â”‚
      â”‚                                                                        â”‚
      â”‚ WHY VALIDATE?                                                          â”‚
      â”‚   - User might have saved state from an older version                  â”‚
      â”‚   - Options might have changed (languages added/removed)               â”‚
      â”‚   - Corrupted data should not crash the app                            â”‚
      â”‚                                                                        â”‚
      â”‚ VALIDATION RULES:                                                      â”‚
      â”‚   - currentLanguage: Must be in VALID_LANGUAGES array                  â”‚
      â”‚   - currentAct: Must exist in loaded data (validated after load)       â”‚
      â”‚   - currentPack: Must exist in act data (validated after load)         â”‚
      â”‚   - currentNativeLanguage: Must be valid column for language           â”‚
      â”‚   - Mode booleans: Just need to be boolean type                        â”‚
      â”‚                                                                        â”‚
      â”‚ RETURNS: true if state was restored, false if no saved state           â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function restoreSavedState() {
      const saved = loadState();
      if (!saved) {
        console.log('No saved state found, using defaults');
        return false;
      }

      console.log('Restoring saved state:', saved);

      // Validate and restore language
      if (saved.currentLanguage && VALID_LANGUAGES.includes(saved.currentLanguage)) {
        state.currentLanguage = saved.currentLanguage;
      }

      // Validate and restore act (will be validated against loaded data later)
      if (saved.currentAct !== null && saved.currentAct !== undefined) {
        state.currentAct = saved.currentAct;
      }

      // Validate and restore pack (will be validated against act data later)
      if (saved.currentPack) {
        state.currentPack = saved.currentPack;
      }

      // Validate and restore native language column
      // Must be a valid column index for the current language
      if (saved.currentNativeLanguage !== null && saved.currentNativeLanguage !== undefined) {
        const config = LANGUAGE_CONFIG[state.currentLanguage];
        const validColumns = Object.values(config.nativeLanguages);
        if (validColumns.includes(saved.currentNativeLanguage)) {
          state.currentNativeLanguage = saved.currentNativeLanguage;
        } else {
          // Fall back to first available native language for this target language
          state.currentNativeLanguage = validColumns[0];
        }
      }

      // Restore mode booleans (simple validation: just check type)
      if (typeof saved.multipleChoiceMode === 'boolean') {
        state.multipleChoiceMode = saved.multipleChoiceMode;
      }
      if (typeof saved.typingMode === 'boolean') {
        state.typingMode = saved.typingMode;
      }
      if (typeof saved.pronunciationMode === 'boolean') {
        state.pronunciationMode = saved.pronunciationMode;
      }

      return true;
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ validateAndFixState() - Validate state against loaded data             â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ CALLED AFTER data is loaded to ensure act/pack are valid.              â”‚
      â”‚                                                                        â”‚
      â”‚ This is separate from restoreSavedState() because we can't validate    â”‚
      â”‚ act/pack until the data is loaded from the modules.                    â”‚
      â”‚                                                                        â”‚
      â”‚ VALIDATION:                                                            â”‚
      â”‚   - If saved act doesn't exist in loaded data â†’ use first act          â”‚
      â”‚   - If saved pack doesn't exist in act â†’ use first pack                â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function validateAndFixState() {
      // Validate act exists in loaded data
      if (state.currentAct !== null && !state.loadedData[state.currentAct]) {
        console.log(`Saved act ${state.currentAct} not found, falling back to first act`);
        state.currentAct = null;  // Will be set by autoSelectFirstActAndPack
      }

      // Validate pack exists in act data
      if (state.currentAct && state.currentPack) {
        const actData = state.loadedData[state.currentAct];
        if (actData && !actData[state.currentPack]) {
          console.log(`Saved pack ${state.currentPack} not found in act ${state.currentAct}, falling back to first pack`);
          state.currentPack = null;  // Will be set by autoSelectFirstActAndPack
        }
      }
    }

    // ============================================================
    // SPEECH RECOGNITION SETUP
    // ============================================================

    /*
      Web Speech API setup for pronunciation recognition.

      BROWSER SUPPORT:
      - Chrome: Full support (webkitSpeechRecognition)
      - Edge: Full support (SpeechRecognition)
      - Firefox: Partial support
      - Safari: Limited support

      CONFIGURATION:
      - continuous: false (single utterance recognition)
      - interimResults: false (only final results)
      - maxAlternatives: 5 (check multiple interpretations for best match)
      - lang: Dynamic based on target language
    */
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;
    let currentListeningWordIndex = null;  // Track which word is being recorded

    // Language code mapping for speech recognition
    const SPEECH_LANG_CODES = {
      'Spanish': 'es-ES',
      'Chinese': 'zh-CN',
      'English': 'en-US'
    };

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.maxAlternatives = 5;
      // Language will be set dynamically based on currentLanguage
    }

    // ============================================================
    // KEY FEATURE: Module Decoding (3-Layer Obfuscation)
    // Core Objective: Load and decode compressed wordpack data
    // Key Behaviors:
    //   - Base64 decode â†’ Zlib decompress â†’ String reverse
    //   - Returns parsed JSON with all wordpacks in an act
    //   - Single function handles all decoding logic (DRY)
    // ============================================================

    /*
      Our wordpack modules are obfuscated using 3 layers of protection:
      1. Base64 encoding - Allows safe transport as JavaScript string
      2. Zlib compression (via pako) - Reduces file size by ~60%
      3. String reversal - Simple salt to prevent casual JSON parsing

      This function reverses all 3 steps to extract the original JSON data.

      INPUT: URL path to obfuscated module (e.g., './SpanishWords/Jsmodules-js/act1-foundation-js.js')
      OUTPUT: JavaScript object containing all wordpacks in that act

      EXAMPLE OUTPUT STRUCTURE:
      {
        "p1_1_greetings__goodbyes": {
          meta: { wordpack: 1, english: "Greetings & Goodbyes", ... },
          words: [
            ["hola amigo", "hello friend (masculine)", "ä½ å¥½æœ‹å‹", "nÇ hÇo pÃ©ngyÇ’u", "olÃ¡ amigo"],
            ["hola amiga", "hello friend (feminine)", "ä½ å¥½æœ‹å‹", "nÇ hÇo pÃ©ngyÇ’u", "olÃ¡ amiga"],
            ...
          ]
        },
        "p1_2_another_pack": { ... },
        ...
      }
    */
    async function decodeObfuscatedModule(url) {
      try {
        // STEP 1: Import the obfuscated module
        // The module exports a single variable 'w' containing the base64 string
        const module = await import(url);
        const compressedB64 = module.w;

        // STEP 2: Decode base64 to binary
        // atob() converts base64 string to binary string
        // We then convert to Uint8Array for pako
        const compressedBinary = Uint8Array.from(atob(compressedB64), c => c.charCodeAt(0));

        // STEP 3: Decompress with pako (zlib decompression)
        // This inflates the compressed data back to original size
        const decompressedBinary = pako.inflate(compressedBinary);

        // STEP 4: Convert binary to UTF-8 string
        const reversedJson = new TextDecoder('utf-8').decode(decompressedBinary);

        // STEP 5: Reverse the string (undo the salt)
        // Original was reversed character-by-character
        const jsonStr = reversedJson.split('').reverse().join('');

        // STEP 6: Parse JSON to get the original JavaScript object
        const data = JSON.parse(jsonStr);

        return data;
      } catch (error) {
        console.error('Failed to decode module:', url, error);
        throw error;
      }
    }

    // ============================================================
    // KEY FEATURE: Auto-Select First Act and Pack (DRY ENCAPSULATION)
    // Core Objective: Automatically select first available act/pack
    // Key Behaviors:
    //   - Finds first act numerically
    //   - Selects first pack in that act
    //   - Updates UI dropdowns and displays vocabulary
    //   - Used by: initialize(), setupLanguageRadioButtons()
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      This logic was duplicated in initialize() and setupLanguageRadioButtons().
      Now defined ONCE and called from both places.

      "If I needed to change this behavior, how many places would I need to update?"
      Answer: 1 (this function)
    */
    function autoSelectFirstActAndPack() {
      if (!state.loadedData || Object.keys(state.loadedData).length === 0) {
        return;
      }

      // Find first act numerically
      const firstAct = Math.min(...Object.keys(state.loadedData).map(Number));
      state.currentAct = firstAct;
      document.getElementById('actSelect').value = firstAct;

      // Populate pack dropdown for first act
      populatePackDropdown();

      // Auto-select first pack
      const firstActData = state.loadedData[firstAct];
      if (firstActData) {
        const firstPackKey = Object.keys(firstActData)[0];
        state.currentPack = firstPackKey;
        document.getElementById('packSelect').value = firstPackKey;

        // Display vocabulary
        displayVocabulary();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist auto-selected act/pack to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      }
    }

    // ============================================================
    // INITIALIZATION: Load Data on Page Load
    // ============================================================

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ initialize() - Main initialization function                            â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ WORKFLOW (with state persistence):                                     â”‚
      â”‚   1. Restore saved state from localStorage (if any)                    â”‚
      â”‚   2. Load data for restored language (or default Spanish)              â”‚
      â”‚   3. Validate restored state against loaded data                       â”‚
      â”‚   4. Setup UI event listeners                                          â”‚
      â”‚   5. Sync UI to reflect restored state                                 â”‚
      â”‚   6. Auto-select first act/pack if needed                              â”‚
      â”‚   7. Display vocabulary                                                â”‚
      â”‚                                                                        â”‚
      â”‚ KEY PRINCIPLE: User returns to EXACTLY where they left off             â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    async function initialize() {
      updateDebugInfo('Initializing...');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 1: Restore saved state from localStorage
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This sets state.currentLanguage, state.currentAct, state.currentPack,
      // state.currentNativeLanguage, and mode flags if they were saved.
      const hadSavedState = restoreSavedState();

      updateDebugInfo(`Loading ${state.currentLanguage} data...`);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 2: Load data for the restored language (or default)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      await loadLanguageData(state.currentLanguage);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 3: Validate restored state against loaded data
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This ensures saved act/pack still exist in the loaded data.
      // If not, they'll be set to null and auto-selected below.
      if (hadSavedState) {
        validateAndFixState();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 4: Setup UI event listeners
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      setupLanguageRadioButtons();
      setupModeCheckboxes();  // ENCAPSULATED: Single function for all mode checkboxes
      populateActDropdown();
      populateNativeLanguageDropdown();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 5: Sync UI to reflect restored state
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // The UI elements need to be updated to match the restored state
      syncUIToState();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 6: Auto-select or restore act/pack
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (state.currentAct && state.currentPack) {
        // We have valid restored state - just update dropdowns and display
        document.getElementById('actSelect').value = state.currentAct;
        populatePackDropdown();
        document.getElementById('packSelect').value = state.currentPack;
        displayVocabulary();
      } else {
        // No valid saved state - auto-select first act and pack (ENCAPSULATED - DRY)
        autoSelectFirstActAndPack();
      }

      updateDebugInfo('Initialization complete. Ready to use.');
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ syncUIToState() - Update all UI elements to match current state        â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ ENCAPSULATED FUNCTION (DRY PRINCIPLE)                                  â”‚
      â”‚ This function syncs ALL UI elements to match the current state.        â”‚
      â”‚ Called during initialization to reflect restored localStorage state.   â”‚
      â”‚                                                                        â”‚
      â”‚ WHAT IT SYNCS:                                                         â”‚
      â”‚   - Language radio buttons                                             â”‚
      â”‚   - Mode checkboxes (multiple choice, typing, pronunciation)           â”‚
      â”‚   - Native language dropdown                                           â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function syncUIToState() {
      // Sync language radio buttons
      const languageRadios = document.querySelectorAll('input[name="language"]');
      languageRadios.forEach(radio => {
        radio.checked = (radio.value === state.currentLanguage);
      });

      // Sync mode checkboxes
      document.getElementById('multipleChoiceMode').checked = state.multipleChoiceMode;
      document.getElementById('typingMode').checked = state.typingMode;
      document.getElementById('pronunciationMode').checked = state.pronunciationMode;

      // Sync native language dropdown
      const nativeSelect = document.getElementById('nativeLanguageSelect');
      if (nativeSelect) {
        nativeSelect.value = state.currentNativeLanguage;
      }
    }

    // ============================================================
    // LOAD LANGUAGE DATA: Fetches and Decodes All Acts
    // ============================================================

    /*
      Loads all act modules for the specified language.

      INPUT: languageName (string) - 'Spanish', 'Chinese', or 'English'
      OUTPUT: Populates state.loadedData with decoded wordpacks

      PROCESS:
      1. Get module list from LANGUAGE_CONFIG
      2. Loop through each act module
      3. Decode the obfuscated module
      4. Store in state.loadedData[actNumber]
    */
    async function loadLanguageData(languageName) {
      updateDebugInfo(`Loading ${languageName} data...`);

      const config = LANGUAGE_CONFIG[languageName];
      state.loadedData = {};  // Clear previous data

      // Load each act module
      for (const moduleInfo of config.modules) {
        updateDebugInfo(`Loading Act ${moduleInfo.act}: ${moduleInfo.name}...`);

        try {
          const actData = await decodeObfuscatedModule(moduleInfo.path);
          state.loadedData[moduleInfo.act] = actData;
          updateDebugInfo(`âœ“ Act ${moduleInfo.act} loaded (${Object.keys(actData).length} packs)`);
        } catch (error) {
          updateDebugInfo(`âœ— Failed to load Act ${moduleInfo.act}: ${error.message}`);
        }
      }

      updateDebugInfo(`${languageName} data loading complete.`);
    }

    // ============================================================
    // KEY FEATURE: Language Selection (Radio Buttons)
    // Core Objective: Switch between target languages (Spanish/Chinese/English)
    // Key Behaviors:
    //   - Reloads all act data for selected language
    //   - Resets native language to first available option
    //   - Auto-selects first act/pack via encapsulated function (DRY)
    // ============================================================

    /*
      Attaches change event listeners to language radio buttons.
      When user changes language, reload all data for that language.

      STATE PERSISTENCE: Calls saveState() after language change.
    */
    function setupLanguageRadioButtons() {
      const radios = document.querySelectorAll('input[name="language"]');
      radios.forEach(radio => {
        radio.addEventListener('change', async (e) => {
          const newLanguage = e.target.value;
          state.currentLanguage = newLanguage;
          state.currentAct = null;
          state.currentPack = null;

          // Reset native language to first available option
          const nativeLanguages = LANGUAGE_CONFIG[newLanguage].nativeLanguages;
          state.currentNativeLanguage = Object.values(nativeLanguages)[0];

          // Reload data for new language
          await loadLanguageData(newLanguage);

          // Update UI
          populateActDropdown();
          populateNativeLanguageDropdown();

          // Auto-select first act and pack (ENCAPSULATED - DRY)
          // Previously this was 15+ lines of duplicated code
          autoSelectFirstActAndPack();

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SAVE STATE: Persist language change to localStorage
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          saveState();
        });
      });
    }

    // ============================================================
    // KEY FEATURE: Mode Checkboxes (DRY ENCAPSULATION)
    // Core Objective: Toggle display modes (multiple choice, typing, pronunciation)
    // Key Behaviors:
    //   - Each checkbox toggles a state flag
    //   - Some modes require state reset (typing, pronunciation)
    //   - All modes refresh vocabulary display on change
    //   - Single configuration-driven function (DRY)
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      Previously we had THREE separate functions:
      - setupMultipleChoiceCheckbox()
      - setupTypingModeCheckbox()
      - setupPronunciationModeCheckbox()

      All followed the same pattern:
      1. Get checkbox by ID
      2. Add change listener
      3. Update state property
      4. (Optionally) Clear some states
      5. Refresh display

      Now we define this ONCE with a configuration array.
      "If I needed to change the checkbox behavior, how many places would I need to update?"
      Answer: 1 (this function)
    */
    function setupModeCheckboxes() {
      // Configuration array: [checkboxId, stateKey, statesToClear]
      const checkboxConfig = [
        { id: 'multipleChoiceMode', stateKey: 'multipleChoiceMode', statesToClear: [] },
        { id: 'typingMode', stateKey: 'typingMode', statesToClear: ['typingStates'] },
        { id: 'pronunciationMode', stateKey: 'pronunciationMode', statesToClear: ['pronunciationStates'] }
      ];

      checkboxConfig.forEach(({ id, stateKey, statesToClear }) => {
        const checkbox = document.getElementById(id);
        if (!checkbox) return;

        checkbox.addEventListener('change', (e) => {
          // Update the state flag
          state[stateKey] = e.target.checked;

          // Clear associated states if specified
          statesToClear.forEach(stateMapKey => {
            if (state[stateMapKey] && typeof state[stateMapKey].clear === 'function') {
              state[stateMapKey].clear();
            }
          });

          // Refresh table with new mode
          displayVocabulary();

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SAVE STATE: Persist mode toggle to localStorage
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          saveState();
        });
      });
    }

    // ============================================================
    // KEY FEATURE: Speech Recognition (Pronunciation Practice)
    // Core Objective: Allow users to practice pronunciation with feedback
    // Key Behaviors:
    //   - Uses Web Speech API for speech-to-text
    //   - Calculates similarity using Levenshtein distance
    //   - Visual feedback (ğŸ”´ recording, ğŸ¤ idle)
    //   - Reset state encapsulated for DRY
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      Reset listening state appears in 3 places: onresult, onerror, onend
      Now defined ONCE and called from all places.
    */
    function resetListeningState(recordButton) {
      isListening = false;
      currentListeningWordIndex = null;
      if (recordButton) {
        recordButton.textContent = 'ğŸ¤';
      }
    }

    /*
      Starts speech recognition for a specific word in the vocabulary table.

      PROCESS:
      1. Check if speech recognition is available
      2. Set recognition language based on target language
      3. Start listening
      4. On result: Calculate similarity, update state, refresh display
      5. On error: Handle gracefully (no-speech, permission denied)

      PARAMETERS:
      - wordIndex: Index of word in the pack (for state tracking)
      - correctWord: The expected word (target language)
      - recordButton: The button element to update visual state

      VISUAL FEEDBACK:
      - Button shows "ğŸ”´" while recording
      - Button shows "ğŸ¤" when idle (via resetListeningState - DRY)
    */
    function startListeningForPronunciation(wordIndex, correctWord, recordButton) {
      if (!recognition) {
        alert('Speech recognition is not supported in your browser. Try Chrome or Edge.');
        return;
      }

      if (isListening) return;

      isListening = true;
      currentListeningWordIndex = wordIndex;
      recognition.lang = SPEECH_LANG_CODES[state.currentLanguage] || 'en-US';
      recordButton.textContent = 'ğŸ”´';

      recognition.onresult = (event) => {
        const results = event.results[0];
        let bestMatch = results[0].transcript;
        let bestScore = 0;

        for (let i = 0; i < results.length; i++) {
          const transcript = results[i].transcript;
          const score = calculateSimilarity(correctWord, transcript);
          if (score > bestScore) {
            bestScore = score;
            bestMatch = transcript;
          }
        }

        state.pronunciationStates.set(wordIndex, {
          score: bestScore,
          heard: bestMatch,
          attempted: true
        });

        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);
        updatePronunciationDisplay(wordIndex, recordButton);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);

        if (event.error === 'no-speech') {
          state.pronunciationStates.set(wordIndex, {
            score: 0,
            heard: '(no speech detected)',
            attempted: true
          });
          updatePronunciationDisplay(wordIndex, recordButton);
        } else if (event.error === 'not-allowed') {
          alert('Microphone access denied. Please allow microphone access to use this feature.');
        }
      };

      recognition.onend = () => {
        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);
      };

      recognition.start();
    }

    // ============================================================
    // UPDATE PRONUNCIATION DISPLAY: Show Score in Table Cell
    // ============================================================

    /*
      Updates the score column for a word after pronunciation attempt.

      PARAMETERS:
      - wordIndex: Index of word in pack
      - recordButton: The button element (to find the row)
    */
    function updatePronunciationDisplay(wordIndex, recordButton) {
      const pronState = state.pronunciationStates.get(wordIndex);
      if (!pronState) return;

      const row = recordButton.closest('tr');
      if (!row) return;

      // Score cell is the last cell in the row when pronunciation mode is on
      const scoreCell = row.cells[row.cells.length - 1];
      if (scoreCell) {
        scoreCell.textContent = `${pronState.score}%`;
        scoreCell.title = `Heard: "${pronState.heard}"`;
      }
    }

    // ============================================================
    // AUDIO CONTEXT: For Typing Sound Generation
    // ============================================================

    /*
      Creates and returns the Web Audio API context for sound generation.
      This is used for the satisfying typing/scribble sound.
    */
    let audioContext = null;

    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // ============================================================
    // TYPING SOUND: Mechanical Click (Improved from SimpleFlashCards)
    // ============================================================

    /*
      Plays a satisfying mechanical keyboard click sound on every keypress.
      This sound plays for BOTH correct and wrong keypress (instant feedback).

      SOUND CHARACTERISTICS:
      - Very short duration (0.015-0.025 seconds) for crisp click
      - High frequency (2000-3500 Hz) for mechanical feel
      - Random variation in frequency and volume for natural typing feel
      - Sharp decay envelope for crisp, defined click

      USAGE IN GAMES:
      This sound provides immediate tactile feedback that makes typing feel
      satisfying and responsive. It's crucial for engagement - even wrong
      keypresses should "feel good" to maintain flow state.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Slightly cleaner filter chain
      - Better commented for understanding
    */
    function playTypingSound() {
      const ctx = getAudioContext();

      // Very short duration for crisp mechanical click
      const duration = 0.015 + Math.random() * 0.01;  // 0.015-0.025 seconds
      const bufferSize = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      // Generate sharp click noise with very fast decay
      for (let i = 0; i < bufferSize; i++) {
        const envelope = Math.pow(1 - i/bufferSize, 8);  // Very sharp decay
        const noise = (Math.random() * 2 - 1);
        data[i] = noise * envelope;
      }

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // High frequency bandpass for mechanical click (2000-3500 Hz)
      const bp1 = ctx.createBiquadFilter();
      bp1.type = 'bandpass';
      bp1.frequency.value = 2000 + Math.random() * 1500;  // Random variation
      bp1.Q.value = 4.0;  // High Q for sharp, defined click

      // Mid frequency for body (1000-1500 Hz)
      const bp2 = ctx.createBiquadFilter();
      bp2.type = 'bandpass';
      bp2.frequency.value = 1000 + Math.random() * 500;
      bp2.Q.value = 2.5;

      // Remove low mud
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 400;

      // Moderate volume for satisfying click
      const gain = ctx.createGain();
      gain.gain.value = 0.35 + Math.random() * 0.1;  // 0.35-0.45 with random variation

      // Connect audio chain
      source.connect(hp);
      hp.connect(bp1);
      bp1.connect(bp2);
      bp2.connect(gain);
      gain.connect(ctx.destination);

      source.start();
    }

    // ============================================================
    // LEVENSHTEIN DISTANCE: For Pronunciation Similarity
    // ============================================================

    /*
      Calculates the Levenshtein (edit) distance between two strings.
      This is the minimum number of single-character edits (insertions,
      deletions, or substitutions) required to change one string into another.

      ALGORITHM: Dynamic Programming approach
      - Time complexity: O(m * n) where m and n are string lengths
      - Space complexity: O(m * n) for the DP table

      EXAMPLE:
      - "hola" vs "hola" = 0 (identical)
      - "hola" vs "hole" = 1 (one substitution)
      - "hola" vs "hol" = 1 (one deletion)
      - "hola" vs "holaa" = 1 (one insertion)

      INPUT: Two strings to compare
      OUTPUT: Integer distance (0 = identical, higher = more different)
    */
    function levenshteinDistance(str1, str2) {
      const m = str1.length;
      const n = str2.length;

      // Create DP table
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

      // Initialize base cases
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;

      // Fill DP table
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (str1[i - 1] === str2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];  // No edit needed
          } else {
            dp[i][j] = 1 + Math.min(
              dp[i - 1][j],     // Deletion
              dp[i][j - 1],     // Insertion
              dp[i - 1][j - 1]  // Substitution
            );
          }
        }
      }

      return dp[m][n];
    }

    // ============================================================
    // SIMILARITY PERCENTAGE: Convert Distance to Percentage
    // ============================================================

    /*
      Converts Levenshtein distance to a percentage similarity score.

      FORMULA: ((maxLen - distance) / maxLen) * 100
      - Perfect match = 100%
      - Completely different = 0%

      NORMALIZATION:
      - Both strings are lowercased for comparison
      - Trimmed of whitespace

      EXAMPLES:
      - "hola" vs "hola" = 100%
      - "hola" vs "hole" = 75% (3 of 4 chars match concept)
      - "hello" vs "hola" = 40% (2 edits on length 5)

      INPUT: expected (correct answer), heard (speech recognition result)
      OUTPUT: Integer percentage 0-100
    */
    function calculateSimilarity(expected, heard) {
      const exp = expected.toLowerCase().trim();
      const hrd = heard.toLowerCase().trim();

      if (exp === hrd) return 100;
      if (hrd.length === 0) return 0;

      const distance = levenshteinDistance(exp, hrd);
      const maxLen = Math.max(exp.length, hrd.length);
      const similarity = Math.max(0, ((maxLen - distance) / maxLen) * 100);

      return Math.round(similarity);
    }

    // ============================================================
    // CHARACTER NORMALIZATION: For Typing Comparison
    // ============================================================

    /*
      Normalizes a character for typing comparison.

      NORMALIZATION RULES:
      1. Convert to lowercase
      2. Remove accents/diacritics (Ã¡ â†’ a, Ã± â†’ n, Ã¼ â†’ u, etc.)

      EXAMPLES:
      - 'Ã' â†’ 'a'
      - 'Ã±' â†’ 'n'
      - 'Ãœ' â†’ 'u'
      - 'Ã‰' â†’ 'e'

      WHY THIS MATTERS FOR GAMES:
      Most English keyboards don't have accent keys, so learners type
      'hola' instead of 'hÃ³la'. We want to accept their answer as correct.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Same logic, but more clearly documented
      - Explains the "why" for future game developers

      INPUT: Single character string
      OUTPUT: Normalized single character (lowercase, no accents)
    */
    function normalizeCharForTyping(char) {
      return char
        .normalize('NFD')                    // Decompose accents (Ã¡ â†’ a + Â´)
        .replace(/[\u0300-\u036f]/g, '')    // Remove accent marks
        .toLowerCase();                      // Convert to lowercase
    }

    // ============================================================
    // POPULATE ACT DROPDOWN: Based on Loaded Data
    // ============================================================

    /*
      Populates the act dropdown with available acts for current language.

      PROCESS:
      1. Get acts from state.loadedData
      2. Get act names from LANGUAGE_CONFIG
      3. Create option elements
      4. Add change event listener
    */
    function populateActDropdown() {
      const actSelect = document.getElementById('actSelect');
      actSelect.innerHTML = '';

      const acts = Object.keys(state.loadedData).map(Number).sort((a, b) => a - b);
      const config = LANGUAGE_CONFIG[state.currentLanguage];

      acts.forEach(actNum => {
        const moduleInfo = config.modules.find(m => m.act === actNum);
        const option = document.createElement('option');
        option.value = actNum;
        option.textContent = `Act ${actNum}: ${moduleInfo.name}`;
        actSelect.appendChild(option);
      });

      // Event listener for act change
      actSelect.addEventListener('change', (e) => {
        state.currentAct = parseInt(e.target.value);
        state.currentPack = null;
        populatePackDropdown();
        displayVocabulary();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist act change to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      });
    }

    // ============================================================
    // POPULATE PACK DROPDOWN: Based on Selected Act
    // ============================================================

    /*
      Populates the pack dropdown with wordpacks from selected act.

      PROCESS:
      1. Get pack keys from state.loadedData[currentAct]
      2. Extract pack metadata (title in English)
      3. Create option elements
      4. Add change event listener
    */
    function populatePackDropdown() {
      const packSelect = document.getElementById('packSelect');

      if (!state.currentAct) {
        packSelect.innerHTML = '';
        return;
      }

      packSelect.innerHTML = '';

      const actData = state.loadedData[state.currentAct];
      if (!actData) return;

      // Get all pack keys and sort by wordpack number
      const packKeys = Object.keys(actData);
      packKeys.sort((a, b) => {
        const numA = actData[a].meta.wordpack;
        const numB = actData[b].meta.wordpack;
        return numA - numB;
      });

      packKeys.forEach(packKey => {
        const pack = actData[packKey];
        const option = document.createElement('option');
        option.value = packKey;
        option.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;
        packSelect.appendChild(option);
      });

      // Event listener for pack change
      packSelect.addEventListener('change', (e) => {
        state.currentPack = e.target.value;
        displayVocabulary();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist pack change to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      });
    }

    // ============================================================
    // POPULATE NATIVE LANGUAGE DROPDOWN: Based on Current Language
    // ============================================================

    /*
      Populates the "I speak" dropdown with available native languages.
      Available options depend on the column structure of target language.

      EXAMPLE:
      If learning Spanish, can choose: English, Chinese, Pinyin, Portuguese
      If learning Chinese, can choose: English, Spanish, French, Portuguese, etc.
    */
    function populateNativeLanguageDropdown() {
      const nativeSelect = document.getElementById('nativeLanguageSelect');
      nativeSelect.innerHTML = '';

      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const nativeLanguages = config.nativeLanguages;

      Object.entries(nativeLanguages).forEach(([langName, columnIndex]) => {
        const option = document.createElement('option');
        option.value = columnIndex;
        option.textContent = langName;
        if (columnIndex === state.currentNativeLanguage) {
          option.selected = true;
        }
        nativeSelect.appendChild(option);
      });

      // Event listener for native language change
      nativeSelect.addEventListener('change', (e) => {
        state.currentNativeLanguage = parseInt(e.target.value);
        displayVocabulary();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist native language change to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      });
    }

    // ============================================================
    // STRING NORMALIZATION: For Duplicate Detection
    // ============================================================

    /*
      Normalizes strings for comparison to detect duplicates across wordpacks.

      NORMALIZATION PROCESS:
      1. Convert to lowercase
      2. Remove all spaces
      3. Remove all symbols/punctuation

      EXAMPLES:
      - "Hola Amigo" â†’ "holaamigo"
      - "hello, friend!" â†’ "hellofriend"
      - "ä½ å¥½ æœ‹å‹" â†’ "ä½ å¥½æœ‹å‹"

      This catches duplicates that may appear with slight variations:
      - "hola" and "Hola" (case difference)
      - "hello friend" and "hellofriend" (spacing difference)
      - "hello!" and "hello" (punctuation difference)

      INPUT: String to normalize
      OUTPUT: Normalized string (lowercase, no spaces, no symbols)
    */
    function normalizeString(str) {
      return str
        .toLowerCase()
        .replace(/[\s\.,!?;:'"()\[\]{}\-_]/g, '');  // Remove spaces and common symbols
    }

    // ============================================================
    // KEY FEATURE: Multiple Choice Wrong Answers (Act-Wide Pool)
    // Core Objective: Generate diverse, non-duplicate wrong answers
    // Key Behaviors:
    //   - Pulls from ENTIRE ACT (~2,500 words) not just current pack
    //   - Filters duplicates via normalized string comparison
    //   - Uses Fisher-Yates shuffle for uniform randomness
    //   - Works for ANY language (Spanish, Chinese, English)
    // ============================================================

    /*
      Generates random wrong answers for multiple choice mode.

      UPDATED ALGORITHM (Act-Wide Selection):
      Instead of pulling from just the current wordpack (50 words),
      we now pull from the ENTIRE ACT (all wordpacks, ~2,500 words).

      BENEFITS:
      âœ“ More variety (2,500 options vs 50)
      âœ“ Less predictable for players
      âœ“ Better for advanced learners
      âœ“ No additional performance cost (data already in memory)

      PROCESS:
      1. Collect all words from all packs in the current act
      2. Filter out the correct answer (exact match)
      3. Filter out normalized duplicates (case/space/symbol variations)
      4. Shuffle remaining pool using Fisher-Yates
      5. Take first K words as wrong answers (K=4 in this demo)

      EXAMPLE:
      - Act 1 has 50 packs with 50 words each = 2,500 total words
      - Current correct answer: "hola amigo"
      - Normalized: "holaamigo"
      - Filter out: "hola amigo", "Hola Amigo", "hola-amigo" (all normalize to same)
      - Remaining pool: ~2,499 words
      - Randomly select 4 from this pool

      DUPLICATE DETECTION:
      We use normalized string comparison to avoid showing essentially
      the same word with minor variations:
      - "hello" vs "Hello" (different case)
      - "hello friend" vs "hellofriend" (different spacing)
      - "hello!" vs "hello" (different punctuation)

      GAME USAGE:
      Different games need different numbers of wrong answers:
      - Temple Run (3-lane runner): Need 2 wrong answers (3 total choices)
      - Quiz game (4 options): Need 3 wrong answers (4 total choices)
      - This demo: 4 wrong answers to show extensibility

      This algorithm works for ANY language (Spanish, Chinese, English, etc.)
      because it always uses column 0 (target language) from the words array.

      INPUT:
        - actData: Dictionary of all wordpacks in the current act
        - correctAnswer: The correct answer string (to filter out)
        - count: Number of wrong answers to generate (default 4)

      OUTPUT:
        - Array of wrong answer strings from column 0 (target language)
    */
    function generateWrongAnswers(actData, correctAnswer, count = 4) {
      // STEP 1: Normalize the correct answer for comparison
      const normalizedCorrect = normalizeString(correctAnswer);

      // STEP 2: Collect all words from all packs in the act
      const allWords = [];

      // Loop through each pack in the act
      Object.keys(actData).forEach(packKey => {
        const pack = actData[packKey];

        // Loop through each word in this pack
        pack.words.forEach(word => {
          const targetLanguageWord = word[0];  // Column 0 is always target language

          // Filter out the correct answer and normalized duplicates
          if (targetLanguageWord !== correctAnswer) {
            const normalizedWord = normalizeString(targetLanguageWord);

            // Only add if normalized version is different from correct answer
            if (normalizedWord !== normalizedCorrect) {
              allWords.push(targetLanguageWord);
            }
          }
        });
      });

      // STEP 3: Shuffle using Fisher-Yates algorithm for uniform randomness
      for (let i = allWords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
      }

      // STEP 4: Take first 'count' words (or fewer if pool is small)
      const wrongAnswers = allWords.slice(0, Math.min(count, allWords.length));

      return wrongAnswers;
    }

    // ============================================================
    // KEY FEATURE: Typing Practice (Character-by-Character Input)
    // Core Objective: Let users practice spelling with instant feedback
    // Key Behaviors:
    //   - Accent-insensitive comparison (Ã¡ = a, Ã± = n)
    //   - Auto-skip spaces
    //   - Track wrong letters with visual feedback
    //   - Satisfying click sound on every keypress
    //   - Per-row state (not global) - more modular than SimpleFlashCards
    // ============================================================

    /*
      Handles typing input for a specific word in the vocabulary table.
      This is the CORE TYPING MECHANIC that can be reused in any language game.

      TYPING ALGORITHM (IMPROVED over SimpleFlashCards.html):
      1. Get or initialize typing state for this word
      2. Find next position to type (first untyped non-space character)
      3. Normalize both the typed key and target character (remove accents, lowercase)
      4. Compare:
         - If match: Mark position as typed, play sound
         - If mismatch: Track wrong letter, increment counter, play sound
      5. Update the display (shows Xâ†’letter progressively)

      STATE MANAGEMENT (PER-ROW):
      Each word has its own typing state stored in state.typingStates Map:
      {
        typed: Set(),          // Set of character positions successfully typed
        wrongLetters: [],      // Array of wrong letters attempted
        wrongCount: 0          // Total wrong attempts
      }

      KEY IMPROVEMENTS OVER SimpleFlashCards.html:
      - Per-row state instead of global state (more modular)
      - Simpler state structure (easier to understand)
      - Inline in table (no separate card flipping)
      - Better for debugging/testing multiple words at once

      PARAMETERS:
      - wordIndex: Index of the word in the pack (used as state key)
      - correctWord: The correct answer string (target language)
      - key: The key that was pressed
      - inputElement: The input element to update

      RETURNS: Nothing (updates state and DOM directly)
    */
    function handleTypingInput(wordIndex, correctWord, key, inputElement) {
      // STEP 1: Get or create typing state for this word
      if (!state.typingStates.has(wordIndex)) {
        state.typingStates.set(wordIndex, {
          typed: new Set(),
          wrongLetters: [],
          wrongCount: 0
        });
      }

      const typingState = state.typingStates.get(wordIndex);
      const chars = correctWord.split('');

      // STEP 2: Find next unfilled position (skip already typed and spaces)
      let nextPos = 0;
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] === ' ') {
          typingState.typed.add(i);  // Auto-mark spaces as typed
          continue;
        }
        if (!typingState.typed.has(i)) {
          nextPos = i;
          break;
        }
        if (i === chars.length - 1) {
          // Already completed
          return;
        }
      }

      // STEP 3: Normalize characters for comparison (remove accents, lowercase)
      const normalizedKey = normalizeCharForTyping(key);
      const normalizedTarget = normalizeCharForTyping(chars[nextPos]);

      // STEP 4: Play sound for ANY keypress (instant feedback)
      playTypingSound();

      // STEP 5: Check if correct
      if (normalizedKey === normalizedTarget) {
        // CORRECT! Mark position as typed
        typingState.typed.add(nextPos);
      } else {
        // WRONG! Track the wrong letter and increment counter
        typingState.wrongLetters.push(key.toLowerCase());
        typingState.wrongCount++;
      }

      // STEP 6: Update display to show progress
      updateTypingDisplay(wordIndex, correctWord, inputElement);
    }

    // ============================================================
    // UPDATE TYPING DISPLAY: Show Progress in Input Box
    // ============================================================

    /*
      Updates the typing input box to show current progress.

      DISPLAY FORMAT:
      - Untyped characters: Shown as 'X'
      - Typed characters: Shown as actual letter
      - Spaces: Shown as space (auto-typed)

      EXAMPLE PROGRESSION for "hola amigo":
      Initial:  "XXXX XXXXX"
      After 'h': "hXXX XXXXX"
      After 'o': "hoXX XXXXX"
      After 'l': "holX XXXXX"
      After 'a': "hola XXXXX"
      After 'a': "hola aXXXX"
      ... etc ...
      Final:    "hola amigo"

      PARAMETERS:
      - wordIndex: Index of word (to get state)
      - correctWord: The correct answer
      - inputElement: The input element to update
    */
    function updateTypingDisplay(wordIndex, correctWord, inputElement) {
      const typingState = state.typingStates.get(wordIndex);
      if (!typingState) return;

      const chars = correctWord.split('');
      const display = chars.map((char, i) => {
        if (typingState.typed.has(i)) {
          return char;  // Show actual character if typed
        } else {
          return char === ' ' ? ' ' : 'X';  // Show X for untyped, preserve spaces
        }
      }).join('');

      inputElement.value = display;

      // Also update the wrong letters and count columns
      const row = inputElement.closest('tr');
      if (row) {
        const wrongLettersCell = row.cells[row.cells.length - 2];  // Second to last column
        const wrongCountCell = row.cells[row.cells.length - 1];     // Last column

        if (wrongLettersCell) {
          // Display wrong letters with strikethrough
          wrongLettersCell.innerHTML = typingState.wrongLetters
            .map(letter => `<del>${letter}</del>`)
            .join(' ');
        }

        if (wrongCountCell) {
          wrongCountCell.textContent = typingState.wrongCount;
        }
      }
    }

    // ============================================================
    // KEY FEATURE: Vocabulary Table Display (Multi-Mode)
    // Core Objective: Render vocabulary with optional practice modes
    // Key Behaviors:
    //   - Dynamic column count based on enabled modes
    //   - Supports: basic, multiple choice, typing, pronunciation
    //   - Modes can be combined (columns stack)
    //   - Headers update dynamically to match active modes
    // ============================================================

    /*
      Displays vocabulary for the selected wordpack.

      TABLE MODES:

      BASIC MODE (all modes off):
      - 2 columns: Target language (column 0) and Native language (selected)

      MULTIPLE CHOICE MODE (multipleChoiceMode = true):
      - 6 columns: Target language, Native language, + 4 wrong answers
      - Wrong answers are randomly selected from ALL packs in current act
      - Duplicate filtering applied (normalized string comparison)

      TYPING MODE (typingMode = true):
      - 5 columns: Target language, Native language, Typing input, Wrong letters, Wrong count
      - Interactive typing practice with instant feedback

      PRONUNCIATION MODE (pronunciationMode = true):
      - 4 columns: Target language, Native language, Record button, Score percentage
      - Speech recognition using Web Speech API
      - Levenshtein distance for fuzzy string matching

      MODES CAN BE COMBINED:
      - Multiple modes can be enabled simultaneously
      - Columns are added in order: base â†’ multiple choice â†’ typing â†’ pronunciation

      PROCESS:
      1. Get selected wordpack from state.loadedData
      2. Check which modes are enabled
      3. Update table headers accordingly
      4. Loop through words array
      5. For each word:
         - Display word[0] in column 1 (target language - correct answer)
         - Display word[nativeLanguageIndex] in column 2 (translation)
         - If multiple choice mode: Generate and display 4 wrong answers
         - If typing mode: Add typing input box and tracking columns
         - If pronunciation mode: Add record button and score columns
    */
    function displayVocabulary() {
      const tableBody = document.getElementById('vocabularyTable');
      const packTitleEl = document.getElementById('packTitle');
      const tableHeaderRow = document.getElementById('tableHeaderRow');

      // Clear table
      tableBody.innerHTML = '';

      // Calculate colspan based on active modes
      let totalColumns = 2;  // Base: target language + native language
      if (state.multipleChoiceMode) totalColumns += 4;  // Add 4 wrong answer columns
      if (state.typingMode) totalColumns += 3;  // Add typing input + wrong letters + wrong count
      if (state.pronunciationMode) totalColumns += 2;  // Add record button + percentage score

      // Validate selection
      if (!state.currentAct || !state.currentPack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Please select an act and wordpack</td></tr>`;
        packTitleEl.textContent = 'No pack selected';
        return;
      }

      // Get wordpack data
      const actData = state.loadedData[state.currentAct];
      if (!actData) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Act data not loaded</td></tr>`;
        return;
      }

      const pack = actData[state.currentPack];
      if (!pack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Pack not found</td></tr>`;
        return;
      }

      // Update pack title
      packTitleEl.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;

      // Get language names
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const targetLanguage = config.columns[0];  // Column 0 is always target language
      const nativeLanguage = config.columns[state.currentNativeLanguage];

      // ============================================================
      // UPDATE TABLE HEADERS: Based on Mode
      // ============================================================
      /*
        Build headers dynamically based on enabled modes:
        - Base: Target language + Native language (2 columns)
        - Multiple Choice: + 4 wrong answer columns
        - Typing: + Typing input + Wrong letters + Wrong count (3 columns)
      */
      let headers = [];

      // Base columns (always present)
      if (state.multipleChoiceMode) {
        headers.push(`<th>Correct Answer (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.typingMode) {
        headers.push(`<th>Target Word (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.pronunciationMode) {
        headers.push(`<th>Say This (${targetLanguage})</th>`);
        headers.push(`<th>Meaning (${nativeLanguage})</th>`);
      } else {
        headers.push(`<th>I am learning (${targetLanguage})</th>`);
        headers.push(`<th>I speak (${nativeLanguage})</th>`);
      }

      // Multiple choice columns (if enabled)
      if (state.multipleChoiceMode) {
        headers.push('<th>Wrong Answer 1</th>');
        headers.push('<th>Wrong Answer 2</th>');
        headers.push('<th>Wrong Answer 3</th>');
        headers.push('<th>Wrong Answer 4</th>');
      }

      // Typing mode columns (if enabled)
      if (state.typingMode) {
        headers.push('<th>Type Here (X = letter)</th>');
        headers.push('<th>Wrong Letters</th>');
        headers.push('<th>Wrong Count</th>');
      }

      // Pronunciation mode columns (if enabled)
      if (state.pronunciationMode) {
        headers.push('<th>Record ğŸ¤</th>');
        headers.push('<th>Score %</th>');
      }

      tableHeaderRow.innerHTML = headers.join('\n');

      // ============================================================
      // POPULATE TABLE ROWS: Generate vocabulary with optional wrong answers
      // ============================================================
      pack.words.forEach((word, index) => {
        const row = document.createElement('tr');

        // COLUMN 1: Target language (correct answer, column 0 from words array)
        const cell1 = document.createElement('td');
        cell1.textContent = word[0];
        row.appendChild(cell1);

        // COLUMN 2: Native language translation (selected column from words array)
        const cell2 = document.createElement('td');
        cell2.textContent = word[state.currentNativeLanguage];
        row.appendChild(cell2);

        // COLUMNS 3-6: Wrong answers (only in multiple choice mode)
        if (state.multipleChoiceMode) {
          /*
            Generate 4 random wrong answers from ALL wordpacks in the current act.
            - Current correct answer: word[0] (target language, column 0)
            - Pool: All words from all packs in the current act (~2,500 words)
            - Filtering: Exclude correct answer and normalized duplicates
            - Each wrong answer is from column 0 (target language)
          */
          const correctAnswer = word[0];
          const wrongAnswers = generateWrongAnswers(actData, correctAnswer, 4);

          // Add each wrong answer as a table cell
          wrongAnswers.forEach(wrongAnswer => {
            const wrongCell = document.createElement('td');
            wrongCell.textContent = wrongAnswer;
            row.appendChild(wrongCell);
          });

          // Handle edge case: If act has fewer than 5 words total,
          // we might have fewer than 4 wrong answers. Fill remaining cells.
          const wrongAnswerCount = wrongAnswers.length;
          for (let i = wrongAnswerCount; i < 4; i++) {
            const emptyCell = document.createElement('td');
            emptyCell.textContent = '(Not enough words in act)';
            row.appendChild(emptyCell);
          }
        }

        // TYPING MODE COLUMNS: Input box + Wrong letters + Wrong count
        if (state.typingMode) {
          /*
            Add typing practice columns for this word:
            1. Typing input box (initialized with "XXXX XXXXX" format)
            2. Wrong letters column (displays struck-through wrong attempts)
            3. Wrong count column (displays total wrong attempts)
          */
          const correctWord = word[0];

          // COLUMN: Typing input box
          const typingCell = document.createElement('td');
          const typingInput = document.createElement('input');
          typingInput.type = 'text';
          typingInput.readOnly = true;  // Prevent direct editing
          typingInput.style.width = '100%';
          typingInput.style.fontFamily = 'monospace';
          typingInput.style.fontSize = '1em';
          typingInput.style.padding = '4px';

          // Initialize display with X's for each letter (preserve spaces)
          const initialDisplay = correctWord.split('').map(char => char === ' ' ? ' ' : 'X').join('');
          typingInput.value = initialDisplay;

          // Add keypress listener to this specific input
          typingInput.addEventListener('keydown', (e) => {
            // Only handle single character keys (not arrow keys, backspace, etc.)
            if (e.key.length === 1) {
              e.preventDefault();  // Prevent default input behavior
              handleTypingInput(index, correctWord, e.key, typingInput);
            }
          });

          // Make input focusable by clicking
          typingInput.addEventListener('click', () => {
            typingInput.focus();
          });

          typingCell.appendChild(typingInput);
          row.appendChild(typingCell);

          // COLUMN: Wrong letters (initially empty)
          const wrongLettersCell = document.createElement('td');
          wrongLettersCell.style.fontFamily = 'monospace';
          row.appendChild(wrongLettersCell);

          // COLUMN: Wrong count (initially 0)
          const wrongCountCell = document.createElement('td');
          wrongCountCell.textContent = '0';
          wrongCountCell.style.textAlign = 'center';
          row.appendChild(wrongCountCell);
        }

        // PRONUNCIATION MODE COLUMNS: Record button + Score percentage
        if (state.pronunciationMode) {
          const correctWord = word[0];

          // COLUMN: Record button
          const recordCell = document.createElement('td');
          const recordButton = document.createElement('button');
          recordButton.textContent = 'ğŸ¤';
          recordButton.addEventListener('click', () => {
            startListeningForPronunciation(index, correctWord, recordButton);
          });
          recordCell.appendChild(recordButton);
          row.appendChild(recordCell);

          // COLUMN: Score percentage
          const scoreCell = document.createElement('td');
          const pronState = state.pronunciationStates.get(index);
          if (pronState && pronState.attempted) {
            scoreCell.textContent = `${pronState.score}%`;
            scoreCell.title = `Heard: "${pronState.heard}"`;
          } else {
            scoreCell.textContent = '-';
          }
          row.appendChild(scoreCell);
        }

        tableBody.appendChild(row);
      });

      // Update debug info with active modes
      let modeParts = [];
      if (state.multipleChoiceMode) modeParts.push('Multiple Choice (act-wide pool)');
      if (state.typingMode) modeParts.push('Typing Practice');
      if (state.pronunciationMode) modeParts.push('Pronunciation Practice');
      const modeText = modeParts.length > 0 ? modeParts.join(' + ') : 'Basic (2 columns)';

      // Count total words in act for debug info
      let totalActWords = 0;
      Object.keys(actData).forEach(packKey => {
        totalActWords += actData[packKey].words.length;
      });

      updateDebugInfo(`Displaying Pack ${pack.meta.wordpack}: ${pack.meta.english}\n` +
                      `Words in this pack: ${pack.words.length}\n` +
                      `Total words in Act ${state.currentAct}: ${totalActWords}\n` +
                      `Mode: ${modeText}\n` +
                      `Total columns: ${totalColumns}\n` +
                      `Target language: ${targetLanguage} (column 0)\n` +
                      `Native language: ${nativeLanguage} (column ${state.currentNativeLanguage})`);
    }

    // ============================================================
    // UPDATE DEBUG INFO: Display Technical Details
    // ============================================================

    /*
      Updates the debug information section with current state and messages.
      Useful for developers/LLMs to understand what's happening.

      INCLUDES: localStorage status to help debug state persistence.
    */
    function updateDebugInfo(message) {
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toLocaleTimeString();

      // Check localStorage status
      let localStorageStatus = 'Unknown';
      let savedStatePreview = 'None';
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          localStorageStatus = 'Available (has saved state)';
          const parsed = JSON.parse(saved);
          savedStatePreview = `Language: ${parsed.currentLanguage}, Act: ${parsed.currentAct}, Pack: ${parsed.currentPack ? parsed.currentPack.substring(0, 20) + '...' : 'None'}`;
        } else {
          localStorageStatus = 'Available (no saved state)';
        }
      } catch (e) {
        localStorageStatus = `Error: ${e.message}`;
      }

      debugInfo.textContent = `[${timestamp}] ${message}\n\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `CURRENT STATE (in memory):\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `- Language: ${state.currentLanguage}\n` +
        `- Act: ${state.currentAct || 'None'}\n` +
        `- Pack: ${state.currentPack || 'None'}\n` +
        `- Native Language Column: ${state.currentNativeLanguage}\n` +
        `- Multiple Choice Mode: ${state.multipleChoiceMode ? 'Enabled' : 'Disabled'}\n` +
        `- Typing Mode: ${state.typingMode ? 'Enabled' : 'Disabled'}\n` +
        `- Pronunciation Mode: ${state.pronunciationMode ? 'Enabled' : 'Disabled'}\n` +
        `- Active Typing States: ${state.typingStates.size}\n` +
        `- Active Pronunciation States: ${state.pronunciationStates.size}\n` +
        `\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `PERSISTENCE (localStorage):\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `- Storage Key: ${STORAGE_KEY}\n` +
        `- Status: ${localStorageStatus}\n` +
        `- Saved: ${savedStatePreview}\n` +
        `\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `SYSTEM:\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `- Speech Recognition: ${recognition ? 'Available' : 'Not Available'}\n` +
        `- Loaded Acts: ${Object.keys(state.loadedData).join(', ') || 'None'}`;
    }

    // ============================================================
    // AUTO-RUN ON PAGE LOAD
    // ============================================================

    /*
      Automatically initialize when DOM is ready.
      This removes the need for a "Run Test" button.
    */
    window.addEventListener('DOMContentLoaded', initialize);

  </script>

</body>
</html>
