<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wordpack Data Structure Debugger</title>

  <!--
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                                              â•‘
    â•‘   ğŸ® LANGUAGE LEARNING GAME - REFERENCE TEMPLATE IMPLEMENTATION ğŸ®           â•‘
    â•‘                                                                              â•‘
    â•‘   This file serves as the CANONICAL REFERENCE for all language learning     â•‘
    â•‘   games in this project. It demonstrates 100% compliance with our design    â•‘
    â•‘   principles and should be used as a template for building new games.       â•‘
    â•‘                                                                              â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    ============================================================
    TABLE OF CONTENTS
    ============================================================
    1. DESIGN PRINCIPLES OVERVIEW
    2. DATA STRUCTURE ARCHITECTURE
    3. STATE PERSISTENCE (localStorage)
    4. DRY (Don't Repeat Yourself) PATTERNS
    5. KEY FEATURES DOCUMENTATION
    6. COLUMN MAPPING BY LANGUAGE
    7. HOW TO USE THIS TEMPLATE

    ============================================================
    1. DESIGN PRINCIPLES OVERVIEW
    ============================================================

    This project follows strict design principles to ensure maintainability,
    consistency, and ease of development. ALL games must follow these rules:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 1: KEY FEATURES ARE SACRED                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - Every important feature MUST have a KEY FEATURE comment block        â”‚
    â”‚ - KEY FEATURES document: Core Objective + Key Behaviors                â”‚
    â”‚ - KEY FEATURES can NEVER be removed without explicit user request      â”‚
    â”‚ - Code can change, but the FEATURE must be preserved                   â”‚
    â”‚                                                                        â”‚
    â”‚ FORMAT:                                                                â”‚
    â”‚   // ============================================================     â”‚
    â”‚   // KEY FEATURE: [High-level description]                            â”‚
    â”‚   // Core Objective: [Why this feature exists]                        â”‚
    â”‚   // Key Behaviors:                                                   â”‚
    â”‚   //   - [Behavior 1 that must be preserved]                          â”‚
    â”‚   //   - [Behavior 2 that must be preserved]                          â”‚
    â”‚   // ============================================================     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 2: DRY (Don't Repeat Yourself) - ENCAPSULATION               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - NEVER copy-paste the same code in multiple places                    â”‚
    â”‚ - If something happens together, put it in ONE function                â”‚
    â”‚ - Ask: "If I needed to change this, how many places would I update?"   â”‚
    â”‚ - If answer > 1, you need to encapsulate                               â”‚
    â”‚                                                                        â”‚
    â”‚ EXAMPLES IN THIS FILE:                                                 â”‚
    â”‚   - autoSelectFirstActAndPack(): Called from 2 places                  â”‚
    â”‚   - setupModeCheckboxes(): Config-driven, not 3 separate functions     â”‚
    â”‚   - resetListeningState(): Used in 3 event handlers                    â”‚
    â”‚   - normalizeCharForTyping(): Single function for accent removal       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 3: STATE PERSISTENCE (localStorage) - MANDATORY              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - ALL user-configurable settings MUST be saved to localStorage         â”‚
    â”‚ - On page load, restore saved state (or use sensible defaults)         â”‚
    â”‚ - User should return to EXACTLY where they left off                    â”‚
    â”‚ - Validate saved values against current valid options                  â”‚
    â”‚                                                                        â”‚
    â”‚ WHAT MUST BE SAVED:                                                    â”‚
    â”‚   - Language selection (Spanish, Chinese, English)                     â”‚
    â”‚   - Act selection                                                      â”‚
    â”‚   - Pack selection                                                     â”‚
    â”‚   - Native language ("I speak") selection                              â”‚
    â”‚   - Mode toggles (multiple choice, typing, pronunciation)              â”‚
    â”‚   - Any other user preference                                          â”‚
    â”‚                                                                        â”‚
    â”‚ WHEN TO SAVE:                                                          â”‚
    â”‚   - On ANY menu/setting change                                         â”‚
    â”‚   - Call saveState() immediately after state change                    â”‚
    â”‚                                                                        â”‚
    â”‚ VALIDATION RULE:                                                       â”‚
    â”‚   - Always validate saved values against current valid options         â”‚
    â”‚   - If saved value is invalid, fall back to default                    â”‚
    â”‚   - This prevents bugs when options change between versions            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 4: SINGLE SOURCE OF TRUTH (Configuration Objects)            â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ - All configuration lives in JavaScript objects, NOT hardcoded HTML    â”‚
    â”‚ - Dropdowns are EMPTY in HTML, populated from config                   â”‚
    â”‚ - If you delete the config, NOTHING should work                        â”‚
    â”‚                                                                        â”‚
    â”‚ IN THIS FILE:                                                          â”‚
    â”‚   - LANGUAGE_CONFIG: All module paths, columns, native languages       â”‚
    â”‚   - VALID_MODES: List of valid mode options for validation             â”‚
    â”‚   - HTML dropdowns: Empty <select></select> elements                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ============================================================
    2. DATA STRUCTURE ARCHITECTURE
    ============================================================

    Our language learning data follows a hierarchical structure:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         DATA HIERARCHY                                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                                        â”‚
    â”‚   LANGUAGE (Spanish, Chinese, English)                                 â”‚
    â”‚       â”‚                                                                â”‚
    â”‚       â””â”€â”€ ACT (Learning Stage - e.g., "Foundation", "Daily Life")      â”‚
    â”‚             â”‚                                                          â”‚
    â”‚             â””â”€â”€ WORDPACK (Vocabulary Set - e.g., "Greetings")          â”‚
    â”‚                   â”‚                                                    â”‚
    â”‚                   â”œâ”€â”€ META (Pack metadata: number, titles)             â”‚
    â”‚                   â”‚                                                    â”‚
    â”‚                   â””â”€â”€ WORDS (Array of word arrays)                     â”‚
    â”‚                         â”‚                                              â”‚
    â”‚                         â””â”€â”€ WORD (Array of translations by column)     â”‚
    â”‚                                                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    OBFUSCATED MODULE STRUCTURE (NEW - with baseWords/exampleWords separation):
    Each .js module exports a dictionary of wordpacks:

    {
      "p{act}_{pack}_{name}": {
        "meta": {
          "wordpack": 1,                    // Pack number (integer)
          "english": "Greetings & Goodbyes", // Pack title in English
          "chinese": "é—®å€™è¯­",                // Pack title in Chinese
          "spanish": "Saludos y Despedidas", // Pack title in Spanish
          ... // Other language translations as supported
        },
        "baseWords": [
          ["base1_col0", "base1_col1", "base1_col2", ...],  // Core vocabulary
          ["base2_col0", "base2_col1", "base2_col2", ...],
          ["base3_col0", "base3_col1", "base3_col2", ...]
        ],
        "exampleWords": [
          ["example1_col0", "example1_col1", "example1_col2", ...],  // Usage examples
          ["example2_col0", "example2_col1", "example2_col2", ...],
          ["example3_col0", "example3_col1", "example3_col2", ...]
        ]
      },
      "p{act}_{pack}_{name}": { ... },
      ...
    }

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                    ğŸ¯ CRITICAL ARCHITECTURE DESIGN ğŸ¯                    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                                          â”‚
    â”‚  WHY WE SEPARATE baseWords AND exampleWords:                            â”‚
    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
    â”‚                                                                          â”‚
    â”‚  Learning Pedagogy: Core vocabulary (base words) should be learned      â”‚
    â”‚  BEFORE contextual examples. This separation allows:                    â”‚
    â”‚                                                                          â”‚
    â”‚  1. BASE WORDS FIRST: Essential vocabulary without context              â”‚
    â”‚     Example: ["hola", "adiÃ³s", "gracias"]                              â”‚
    â”‚                                                                          â”‚
    â”‚  2. EXAMPLES SECOND: Real-world usage with context                      â”‚
    â”‚     Example: ["hola amigo", "adiÃ³s mi amor", "muchas gracias"]         â”‚
    â”‚                                                                          â”‚
    â”‚  3. CONTROLLED RANDOMIZATION:                                           â”‚
    â”‚     - Shuffle baseWords internally â†’ random order within base words    â”‚
    â”‚     - Shuffle exampleWords internally â†’ random order within examples   â”‚
    â”‚     - Concatenate: [shuffled_base] + [shuffled_examples]               â”‚
    â”‚     - Result: Base vocabulary ALWAYS appears before examples,           â”‚
    â”‚       but both sections are randomized for variety                      â”‚
    â”‚                                                                          â”‚
    â”‚  This prevents learners from seeing "hola amigo" before learning "hola" â”‚
    â”‚  while still providing randomization within each category.              â”‚
    â”‚                                                                          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    CRITICAL: Column 0 is ALWAYS the target language being learned!

    ============================================================
    3. STATE PERSISTENCE (localStorage) - IMPLEMENTATION
    ============================================================

    Every game MUST implement these functions:

    const STORAGE_KEY = 'uniqueGameNameState';  // Unique per game

    function saveState() {
      const stateToSave = {
        language: state.currentLanguage,
        act: state.currentAct,
        pack: state.currentPack,
        nativeLanguage: state.currentNativeLanguage,
        // ... all other user settings
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
    }

    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        return saved ? JSON.parse(saved) : null;
      } catch (e) {
        console.error('Failed to load state:', e);
        return null;
      }
    }

    function restoreSavedState() {
      const saved = loadState();
      if (!saved) return;

      // ALWAYS validate before restoring!
      if (saved.language && VALID_LANGUAGES.includes(saved.language)) {
        state.currentLanguage = saved.language;
      }
      // ... validate and restore other settings
    }

    ============================================================
    4. DRY PATTERNS - EXAMPLES IN THIS FILE
    ============================================================

    PATTERN 1: Encapsulated Helper Functions
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PROBLEM: Same 5 lines of code in 2+ places
    SOLUTION: Extract to named function, call from both places

    Example: autoSelectFirstActAndPack()
    - Used in: initialize(), setupLanguageRadioButtons()
    - Benefit: Change logic in ONE place

    PATTERN 2: Configuration-Driven Loops
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PROBLEM: 3 separate functions doing almost the same thing
    SOLUTION: One function with config array

    Example: setupModeCheckboxes()
    - Config: [{ id, stateKey, statesToClear }, ...]
    - One loop handles all checkboxes identically
    - Add new checkbox = add to config array

    PATTERN 3: Callback Parameters
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    PROBLEM: Same action with different follow-up
    SOLUTION: Function takes callback parameter

    Example: showSuccessStamp(onComplete)
    - Stamp + sound + delay always happen together
    - What happens AFTER varies
    - Pass the variation as callback

    ============================================================
    5. KEY FEATURES IN THIS FILE
    ============================================================

    Search for "KEY FEATURE:" to find all documented features:

    1. Global State Management - Single source of truth for UI state
    2. State Persistence (localStorage) - Save/restore user settings
    3. Module Decoding - 3-layer obfuscation (base64 + zlib + reverse)
    4. Auto-Select First Act/Pack - DRY encapsulated function
    5. Language Selection - Switch between target languages
    6. Mode Checkboxes - DRY config-driven setup
    7. Speech Recognition - Pronunciation practice with scoring
    8. Multiple Choice Generation - Act-wide pool, duplicate filtering
    9. Typing Practice - Character-by-character with accent tolerance
    10. Vocabulary Table Display - Multi-mode rendering
    11. Flashcard Mode - ANTI-DECOUPLING DEMONSTRATION (front/back always linked)

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ PRINCIPLE 5: ANTI-DECOUPLING (Critical for Flashcard Games)            â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Related data must be stored as properties of the SAME object,          â”‚
    â”‚ never in separate arrays that could get out of sync.                   â”‚
    â”‚                                                                        â”‚
    â”‚ âŒ WRONG (Decoupled - leads to bugs):                                  â”‚
    â”‚    const fronts = ["hola", "adiÃ³s"];                                   â”‚
    â”‚    const backs = ["hello", "goodbye"];                                 â”‚
    â”‚    // Problem: Arrays can get out of sync!                             â”‚
    â”‚                                                                        â”‚
    â”‚ âœ… RIGHT (Anti-decoupled - always safe):                               â”‚
    â”‚    const cards = [                                                     â”‚
    â”‚      { front: "hola", back: "hello" },                                 â”‚
    â”‚      { front: "adiÃ³s", back: "goodbye" }                               â”‚
    â”‚    ];                                                                  â”‚
    â”‚    // Benefit: front and back are ALWAYS linked!                       â”‚
    â”‚                                                                        â”‚
    â”‚ See "Flashcard Mode" for a live demonstration.                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ============================================================
    6. COLUMN MAPPING BY LANGUAGE
    ============================================================

    SPANISH (5 columns):
      [0] = Spanish (TARGET - language being learned)
      [1] = English
      [2] = Chinese
      [3] = Pinyin
      [4] = Portuguese

    CHINESE (12 columns):
      [0] = Chinese (TARGET - language being learned)
      [1] = Pinyin
      [2] = English
      [3] = Spanish
      [4] = French
      [5] = Portuguese
      [6] = Vietnamese
      [7] = Thai
      [8] = Khmer
      [9] = Indonesian
      [10] = Malay
      [11] = Filipino

    ENGLISH (5 columns):
      [0] = English (TARGET - language being learned)
      [1] = Chinese
      [2] = Pinyin
      [3] = Spanish
      [4] = Portuguese

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ CRITICAL: CHINESE + PINYIN INSEPARABILITY                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Notice that ALL three languages include Chinese AND Pinyin columns!    â”‚
    â”‚                                                                        â”‚
    â”‚ WHY: Chinese uses logograms (characters don't encode pronunciation)    â”‚
    â”‚      â†’ Pinyin MUST accompany Chinese whenever it appears               â”‚
    â”‚                                                                        â”‚
    â”‚ This applies whether Chinese is:                                       â”‚
    â”‚   - The target language (ChineseWords CSVs)                           â”‚
    â”‚   - A translation option (SpanishWords, EnglishWords CSVs)            â”‚
    â”‚                                                                        â”‚
    â”‚ EDGE CASE: Latin Abbreviations in Chinese Text                         â”‚
    â”‚ When Chinese contains Latin (ATM, DNA, WhatsApp, etc.):               â”‚
    â”‚   - Latin sequence â†’ same in pinyin (case insensitive)                â”‚
    â”‚   - Chinese characters â†’ pinyin syllables (1:1 mapping)               â”‚
    â”‚                                                                        â”‚
    â”‚ Examples:                                                              â”‚
    â”‚   Chinese: ATMæœº      â†’ Pinyin: ATM jÄ«                                â”‚
    â”‚   Chinese: DNAæµ‹è¯•     â†’ Pinyin: DNA cÃ¨ shÃ¬                            â”‚
    â”‚   Chinese: WhatsAppæ¶ˆæ¯ â†’ Pinyin: WhatsApp xiÄo xÄ«                    â”‚
    â”‚   Chinese: Tæ¤        â†’ Pinyin: T xÃ¹                                  â”‚
    â”‚                                                                        â”‚
    â”‚ Use "Show Edge Cases" checkbox below to filter for these examples.    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ============================================================
    7. HOW TO USE THIS TEMPLATE
    ============================================================

    To create a new game based on this template:

    1. Copy this file as your starting point
    2. Change STORAGE_KEY to unique value for your game
    3. Keep all KEY FEATURE implementations
    4. Keep all DRY helper functions
    5. Keep localStorage save/restore pattern
    6. Add your game-specific features with KEY FEATURE comments
    7. Follow the same documentation style

    CHECKLIST FOR NEW GAMES:
    â–¡ Unique STORAGE_KEY defined
    â–¡ saveState() called on every setting change
    â–¡ loadState() called during initialization
    â–¡ Saved values validated against valid options
    â–¡ All KEY FEATURES documented with comment blocks
    â–¡ No copy-pasted code (use encapsulated functions)
    â–¡ Configuration objects as single source of truth
    â–¡ Empty HTML dropdowns, populated from JS config

    ============================================================
  -->

  <!--
    ============================================================
    PAKO.JS DEPENDENCY - Required for decompressing obfuscated modules
    ============================================================
    Our obfuscated modules use zlib compression (via pako library).
    This CDN script provides the pako.inflate() function for decompression.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>

  <h1>Wordpack Data Structure Debugger</h1>
  <p>Technical reference for language learning game data architecture</p>

  <hr>

  <!--
    ============================================================
    LANGUAGE SELECTION - Radio Buttons
    ============================================================
    Choose which target language's wordpacks to load.
    Default: Spanish
  -->
  <h2>1. Select Target Language</h2>
  <p>Which language are you learning?</p>
  <label>
    <input type="radio" name="language" value="Spanish" checked>
    Spanish
  </label>
  <label>
    <input type="radio" name="language" value="Chinese">
    Chinese
  </label>
  <label>
    <input type="radio" name="language" value="English">
    English
  </label>

  <hr>

  <!--
    ============================================================
    ACT SELECTION - Dropdown
    ============================================================
    Acts are learning stages. Each language has different numbers of acts:
    - Spanish: 7 acts
    - Chinese: 5 acts
    - English: 5 acts
  -->
  <h2>2. Select Act (Learning Stage)</h2>
  <p>Acts are grouped learning stages containing multiple wordpacks.</p>
  <select id="actSelect">
  </select>

  <hr>

  <!--
    ============================================================
    WORDPACK SELECTION - Dropdown
    ============================================================
    Each act contains multiple wordpacks (vocabulary sets).
    This dropdown populates based on the selected act.
  -->
  <h2>3. Select Wordpack</h2>
  <p>Individual vocabulary set within the selected act.</p>
  <select id="packSelect">
  </select>

  <hr>

  <!--
    ============================================================
    NATIVE LANGUAGE SELECTION - "I Speak" Dropdown
    ============================================================
    This determines which column to display in the right column of the table.
    Column 0 (left) is always the target language being learned.
    Column N (right) is the native language the user speaks.

    Available options depend on the target language's column structure.
  -->
  <h2>4. Select Your Native Language (I Speak)</h2>
  <p>Which language do you speak? This determines the translation column shown.</p>
  <select id="nativeLanguageSelect">
  </select>

  <hr>

  <!--
    ============================================================
    VOCABULARY TABLE - With Optional Multiple Choice Mode
    ============================================================
    Displays the selected wordpack's vocabulary.

    BASIC MODE (Default):
    - 2 columns: Target language (column 0) and Native language (selected)

    MULTIPLE CHOICE MODE (Checkbox enabled):
    - 6 columns total:
      1. Target language (correct answer, column 0)
      2. Native language translation (column N)
      3-6. Four wrong answers (randomly selected from ENTIRE ACT, ~2,500 words)

    WRONG ANSWER POOL:
    Wrong answers are now pulled from ALL wordpacks in the current act,
    not just the current wordpack. This provides:
    - Greater variety (2,500 options vs 50)
    - Less predictable patterns
    - Better simulation of real game mechanics
    - Zero performance cost (all data already loaded in memory)

    DUPLICATE FILTERING:
    Uses normalized string comparison (lowercase, no spaces/symbols)
    to avoid showing essentially identical words:
    - "hola" vs "Hola" (case difference) - filtered
    - "hello friend" vs "hellofriend" (spacing) - filtered
    - "hello!" vs "hello" (punctuation) - filtered

    This demonstrates the CORE LOGIC for generating multiple choice questions
    used in language learning games. Different game mechanics require different
    numbers of choices:
    - Temple Run style: 3 choices (1 correct + 2 wrong)
    - Quiz games: 4 choices (1 correct + 3 wrong)
    - This demo: 6 choices (1 correct + 4 wrong) to show extensibility

    The algorithm works for ANY target language (Spanish, Chinese, English, etc.)
    and ANY future language packs we add to the system.
  -->
  <h2>5. Vocabulary Table</h2>
  <p><strong>Pack Title:</strong> <span id="packTitle">Select a wordpack to view</span></p>

  <!--
    MULTIPLE CHOICE MODE CHECKBOX
    When enabled, adds 4 columns of wrong answers randomly selected from
    ALL wordpacks in the current act (~2,500 words). This shows how game
    mechanics generate distractors with variety and duplicate filtering.
  -->
  <p>
    <label>
      <input type="checkbox" id="multipleChoiceMode">
      Multiple Choice Mode (adds 4 wrong answer columns from entire act - game mechanics demo)
    </label>
  </p>

  <!--
    TYPING MODE CHECKBOX
    When enabled, adds 3 columns for interactive typing practice:
    - Column 3: Typing input box with masked placeholders (X for each letter)
    - Column 4: Wrong letters attempted (crossed out display)
    - Column 5: Wrong attempt count

    This demonstrates the CORE TYPING MECHANIC used in language learning games
    like SimpleFlashCards.html. The mechanic includes:
    - Character-by-character input validation
    - Accent-insensitive comparison (Ã¡ = a, Ã± = n, etc.)
    - Case-insensitive matching
    - Satisfying typing sound on every keypress (correct or wrong)
    - Automatic space handling (spaces ignored, auto-advanced)
    - Wrong letter tracking for feedback

    IMPROVEMENTS OVER SimpleFlashCards.html:
    - Simpler state management (per-row instead of global)
    - More modular code structure (easier to copy to other games)
    - Cleaner normalization logic
    - Better commented for human/LLM understanding
  -->
  <p>
    <label>
      <input type="checkbox" id="typingMode">
      Typing Mode (adds typing practice columns - game mechanics demo)
    </label>
  </p>

  <!--
    PRONUNCIATION MODE CHECKBOX
    When enabled, adds 2 columns for speech recognition practice:
    - Column 3: Record button (ğŸ¤) to capture user's pronunciation
    - Column 4: Percentage correct (similarity score using Levenshtein distance)

    CORE LOGIC:
    - Web Speech API for speech recognition
    - Levenshtein distance for fuzzy string matching
    - Language-specific recognition (es-ES, zh-CN, en-US)
    - Works best in Chrome/Edge browsers
  -->
  <p>
    <label>
      <input type="checkbox" id="pronunciationMode">
      Pronunciation Mode (adds record button and accuracy percentage - speech recognition demo)
    </label>
  </p>

  <!--
    ============================================================
    CHINESE DISPLAY OPTIONS - Global Controls (Show Char / Show Pinyin)
    ============================================================
    These checkboxes control how Chinese text is displayed EVERYWHERE:
    - In the vocabulary table (column 0 when learning Chinese, or Chinese translation column)
    - In flashcard front (when target language is Chinese)
    - In multiple choice options (both correct and wrong answers when Chinese)
    - In any context where Chinese needs to be displayed

    WHY THIS MATTERS:
    Chinese learners need to see BOTH characters AND pinyin together,
    with pinyin positioned directly under each character. This allows
    the brain to associate each character with its pronunciation.

    ANTI-DECOUPLING APPLIED TO CHARACTERS:
    Just as flashcard front/back must be stored together, each Chinese
    character must be COUPLED with its pinyin syllable. We never store
    characters and pinyin in separate arrays - they're paired at the
    character level using the coupleChineseWithPinyin() function.

    VISIBILITY LOGIC:
    - This options panel is ONLY visible when Chinese is involved:
      * Learning Chinese (state.currentLanguage === 'Chinese')
      * OR native language includes Chinese/Pinyin translation
    - Controlled by updateChineseOptionsVisibility() function

    DEFAULT: Both checked (show characters AND pinyin)
  -->
  <div id="chineseDisplayOptions" style="display: none; margin: 10px 0; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 5px;">
    <strong>Chinese Display Options:</strong>
    <label style="margin-left: 15px;">
      <input type="checkbox" id="showChineseChars" checked>
      Show Characters (æ±‰å­—)
    </label>
    <label style="margin-left: 15px;">
      <input type="checkbox" id="showPinyin" checked>
      Show Pinyin (pÄ«nyÄ«n)
    </label>
    <span style="margin-left: 15px; color: #856404; font-size: 0.9em;">
      (Affects all Chinese text: table, flashcards, multiple choice)
    </span>
  </div>

  <!--
    ============================================================
    EDGE CASES FILTER - Show Latin Abbreviation Examples
    ============================================================
    When enabled, filters the vocabulary table to show ONLY words
    containing Latin abbreviations/brand names in Chinese text.

    This demonstrates the edge case handling in validate_pinyin.py:
    - ATMæœº â†’ ATM jÄ« (Latin block + Chinese character)
    - DNAæµ‹è¯• â†’ DNA cÃ¨ shÃ¬ (abbreviation + Chinese)
    - WhatsAppæ¶ˆæ¯ â†’ WhatsApp xiÄo xÄ« (brand name + Chinese)
    - Tæ¤ â†’ T xÃ¹ (single letter + Chinese)
    - la, los â†’ la, los (Spanish articles in Chinese column)

    WHY THIS IS USEFUL:
    - See real examples of edge cases in the actual data
    - Verify these are NOT validation errors (they're correct!)
    - Understand how Latin text mixes with Chinese in modern usage
    - Test the validator's Latin block matching logic
  -->
  <p id="edgeCaseFilterContainer" style="display: none;">
    <label>
      <input type="checkbox" id="showEdgeCasesOnly">
      <strong>Show Edge Cases Only</strong> (Filter for Latin abbreviations: ATM, DNA, WhatsApp, etc.)
    </label>
  </p>

  <!--
    ============================================================
    FLASHCARD MODE CHECKBOX
    ============================================================
    When enabled, shows a simple flashcard interface demonstrating
    the CRITICAL anti-decoupling principle:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ ANTI-DECOUPLING PRINCIPLE (CRITICAL FOR FLASHCARD GAMES)               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                                        â”‚
    â”‚ âŒ WRONG WAY (Decoupled - leads to bugs):                              â”‚
    â”‚    const fronts = ["hola", "adiÃ³s", "gracias"];                        â”‚
    â”‚    const backs  = ["hello", "goodbye", "thank you"];                   â”‚
    â”‚    // Problem: If arrays get out of sync, flipping shows WRONG answer  â”‚
    â”‚    // Bug: fronts[2] might display backs[1] if something shifts        â”‚
    â”‚                                                                        â”‚
    â”‚ âœ… RIGHT WAY (Anti-decoupled - front/back ALWAYS linked):              â”‚
    â”‚    const cards = [                                                     â”‚
    â”‚      { front: "hola",    back: "hello" },      // Card 0               â”‚
    â”‚      { front: "adiÃ³s",   back: "goodbye" },    // Card 1               â”‚
    â”‚      { front: "gracias", back: "thank you" }   // Card 2               â”‚
    â”‚    ];                                                                  â”‚
    â”‚    // Benefit: cards[i].front and cards[i].back are ALWAYS paired      â”‚
    â”‚    // Shuffling reorders cards but NEVER breaks the link               â”‚
    â”‚                                                                        â”‚
    â”‚ WHY THIS MATTERS:                                                      â”‚
    â”‚   - Flipping a card ALWAYS shows the correct translation               â”‚
    â”‚   - Shuffling the deck doesn't break anything                          â”‚
    â”‚   - Adding/removing cards can't cause misalignment                     â”‚
    â”‚   - The card is ONE OBJECT, not two separate arrays                    â”‚
    â”‚                                                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    This mode demonstrates the principle with a minimal, no-CSS implementation.
  -->
  <p>
    <label>
      <input type="checkbox" id="flashcardMode">
      Flashcard Mode (demonstrates anti-decoupling principle - front/back always linked)
    </label>
  </p>

  <!--
    ============================================================
    FLASHCARD DISPLAY AREA (Simple, No CSS)
    ============================================================
    This is intentionally unstyled to focus on the DATA STRUCTURE,
    not the visual presentation. The key teaching point is HOW
    front and back are stored as ONE object, not two arrays.
  -->
  <div id="flashcardArea" style="display: none; margin: 20px 0; padding: 20px; border: 2px solid #333; background: #f9f9f9;">
    <h3>Flashcard Demo (Anti-Decoupling Principle)</h3>
    <p><em>Front and back are properties of the SAME card object - they can never get out of sync.</em></p>

    <!-- Card display - simple border box -->
    <div id="flashcardDisplay" style="border: 3px solid #666; padding: 40px; margin: 20px 0; text-align: center; min-height: 150px; background: white; cursor: pointer;" onclick="window.flipCard()">
      <div id="flashcardContent" style="font-size: 24px;">Click to start</div>
      <div id="flashcardSide" style="font-size: 12px; color: #999; margin-top: 10px;">(click card to flip)</div>
    </div>

    <!-- Navigation buttons - plain HTML buttons -->
    <div style="text-align: center;">
      <button onclick="window.prevCard()" style="padding: 10px 20px; margin: 5px;">â† Previous</button>
      <button onclick="window.flipCard()" style="padding: 10px 20px; margin: 5px;">Flip Card</button>
      <button onclick="window.nextCard()" style="padding: 10px 20px; margin: 5px;">Next â†’</button>
      <button onclick="window.shuffleDeck()" style="padding: 10px 20px; margin: 5px;">ğŸ”€ Shuffle</button>
    </div>

    <!-- Card counter -->
    <p id="flashcardCounter" style="text-align: center; margin-top: 10px;">Card 0 of 0</p>

    <!-- Debug: Show current card object structure -->
    <details style="margin-top: 20px;">
      <summary style="cursor: pointer; font-weight: bold;">ğŸ” View Current Card Object (Anti-Decoupling Proof)</summary>
      <pre id="flashcardDebug" style="background: #eee; padding: 10px; overflow-x: auto; font-size: 12px;">
// No card loaded yet
      </pre>
      <p style="font-size: 12px; color: #666;">
        â†‘ Notice: <code>front</code> and <code>back</code> are properties of the SAME object.<br>
        They cannot get out of sync because they're not stored in separate arrays.
      </p>
    </details>
  </div>

  <table border="1" cellpadding="8" cellspacing="0">
    <thead>
      <tr id="tableHeaderRow">
        <th id="col1Header">I am learning</th>
        <th id="col2Header">I speak</th>
      </tr>
    </thead>
    <tbody id="vocabularyTable">
      <tr>
        <td colspan="2">Loading data...</td>
      </tr>
    </tbody>
  </table>

  <hr>

  <!--
    ============================================================
    DEBUG INFORMATION
    ============================================================
    Shows technical details about loaded data for debugging purposes.
  -->
  <h2>6. Debug Information</h2>
  <pre id="debugInfo">Initializing...</pre>

  <!--
    ============================================================
    JAVASCRIPT MODULE - Main Logic
    ============================================================
    This section contains all the JavaScript logic for:
    1. Decoding obfuscated modules (3-layer: base64 + zlib + string reversal)
    2. Loading language data automatically on page load
    3. Populating dropdowns dynamically
    4. Displaying vocabulary in 2-column table
    5. Handling user interactions (language/act/pack/native language changes)
  -->
  <script type="module">

    // ============================================================
    // KEY FEATURE: State Persistence (localStorage)
    // Core Objective: Save and restore ALL user settings across sessions
    // Key Behaviors:
    //   - Save state on EVERY setting change (language, act, pack, modes)
    //   - Restore state on page load with validation
    //   - Validate saved values against current valid options
    //   - Fall back to defaults if saved values are invalid
    // ============================================================

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ STORAGE_KEY - Unique identifier for this game's localStorage           â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ IMPORTANT: Each game MUST have a unique STORAGE_KEY!                   â”‚
      â”‚                                                                        â”‚
      â”‚ When creating a new game from this template:                           â”‚
      â”‚   1. Change this value to something unique (e.g., 'myNewGameState')    â”‚
      â”‚   2. This prevents different games from overwriting each other's data  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    const STORAGE_KEY = 'decoderTestState';

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ VALID OPTIONS - Used for validating saved state                        â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ These arrays define what values are acceptable for each setting.       â”‚
      â”‚ When restoring saved state, we check if the saved value is in these.   â”‚
      â”‚ If not, we fall back to the default value.                             â”‚
      â”‚                                                                        â”‚
      â”‚ WHY THIS MATTERS:                                                      â”‚
      â”‚ If you change valid options (e.g., add/remove a language), users with  â”‚
      â”‚ old saved state won't have invalid values restored.                    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    const VALID_LANGUAGES = ['Spanish', 'Chinese', 'English'];

    // ============================================================
    // CONFIGURATION: Language Module Paths and Column Structures
    // ============================================================

    /*
      This configuration maps each target language to:
      1. Module file paths (obfuscated .js files for each act)
      2. Column structure (what each column index represents)
      3. Available native languages (for "I speak" dropdown)
    */
    const LANGUAGE_CONFIG = {
      'Spanish': {
        modules: [
          { act: 1, name: 'Foundation', path: './SpanishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './SpanishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Daily Life', path: './SpanishWords/Jsmodules-js/act3-daily-life-js.js' },
          { act: 4, name: 'Expanding Expression', path: './SpanishWords/Jsmodules-js/act4-expanding-expression-js.js' },
          { act: 5, name: 'Intermediate Mastery', path: './SpanishWords/Jsmodules-js/act5-intermediate-mastery-js.js' },
          { act: 6, name: 'Advanced Constructs', path: './SpanishWords/Jsmodules-js/act6-advanced-constructs-js.js' },
          { act: 7, name: 'Mastery Fluency', path: './SpanishWords/Jsmodules-js/act7-mastery-fluency-js.js' }
        ],
        columns: ['Spanish', 'English', 'Chinese', 'Pinyin', 'Portuguese'],
        nativeLanguages: {
          'English': 1,
          'Chinese': 2,
          'Pinyin': 3,
          'Portuguese': 4
        }
      },
      'Chinese': {
        modules: [
          { act: 1, name: 'Foundation', path: './ChineseWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Development', path: './ChineseWords/Jsmodules-js/act2-development-js.js' },
          { act: 3, name: 'Expansion', path: './ChineseWords/Jsmodules-js/act3-expansion-js.js' },
          { act: 4, name: 'Mastery', path: './ChineseWords/Jsmodules-js/act4-mastery-js.js' },
          { act: 5, name: 'Refinement', path: './ChineseWords/Jsmodules-js/act5-refinement-js.js' }
        ],
        columns: ['Chinese', 'Pinyin', 'English', 'Spanish', 'French', 'Portuguese', 'Vietnamese', 'Thai', 'Khmer', 'Indonesian', 'Malay', 'Filipino'],
        nativeLanguages: {
          'English': 2,
          'Spanish': 3,
          'French': 4,
          'Portuguese': 5,
          'Vietnamese': 6,
          'Thai': 7,
          'Khmer': 8,
          'Indonesian': 9,
          'Malay': 10,
          'Filipino': 11
        }
      },
      'English': {
        modules: [
          { act: 1, name: 'Foundation', path: './EnglishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './EnglishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Everyday Life', path: './EnglishWords/Jsmodules-js/act3-everyday-life-js.js' },
          { act: 4, name: 'Expanding Horizons', path: './EnglishWords/Jsmodules-js/act4-expanding-horizons-js.js' },
          { act: 5, name: 'Advanced Mastery', path: './EnglishWords/Jsmodules-js/act5-advanced-mastery-js.js' }
        ],
        columns: ['English', 'Chinese', 'Pinyin', 'Spanish', 'Portuguese'],
        nativeLanguages: {
          'Chinese': 1,
          'Pinyin': 2,
          'Spanish': 3,
          'Portuguese': 4
        }
      }
    };

    // ============================================================
    // KEY FEATURE: Global State Management
    // Core Objective: Single source of truth for all UI state
    // Key Behaviors:
    //   - Tracks current language, act, pack selections
    //   - Tracks mode toggles (multiple choice, typing, pronunciation)
    //   - Per-word state for interactive modes (typing progress, scores)
    // ============================================================

    /*
      Global state object tracks:
      - currentLanguage: Which target language is selected
      - loadedData: Dictionary mapping act numbers to decoded wordpack data
      - currentAct: Currently selected act number
      - currentPack: Currently selected wordpack key
      - currentNativeLanguage: Column index for native language
      - multipleChoiceMode: Boolean flag for showing wrong answer columns
      - typingMode: Boolean flag for showing typing practice columns
      - typingStates: Map tracking typing state for each word (wordIndex -> state object)
      - pronunciationMode: Boolean flag for showing pronunciation practice columns
      - pronunciationStates: Map tracking pronunciation state for each word (wordIndex -> { score, heard, attempted })
      - showChineseChars: Boolean flag for showing Chinese characters (global)
      - showPinyin: Boolean flag for showing pinyin under characters (global)
    */
    let state = {
      currentLanguage: 'Spanish',  // Default language
      loadedData: {},               // { actNumber: { packKey: {meta, words}, ... } }
      loadedActMeta: {},            // { actNumber: { actName, translations, wordColumns, ... } } - from __actMeta
      currentAct: null,
      currentPack: null,
      currentNativeLanguage: 1,     // Default to English column (index 1 for Spanish)
      multipleChoiceMode: false,    // Default to basic 2-column mode
      typingMode: false,            // Default to typing mode off
      typingStates: new Map(),      // Per-word typing state { typed: Set(), wrongLetters: [], wrongCount: 0 }
      pronunciationMode: false,     // Default to pronunciation mode off
      pronunciationStates: new Map(), // Per-word pronunciation state { score: null, heard: '', attempted: false }
      flashcardMode: false,         // Default to flashcard mode off
      flashcardDeck: [],            // Anti-decoupled deck: [{front, back, id}, ...] - NEVER separate arrays!
      flashcardIndex: 0,            // Current card index in flashcardDeck
      flashcardShowingFront: true,  // true = showing front, false = showing back
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CHINESE DISPLAY OPTIONS (Global - affects ALL Chinese text rendering)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      showChineseChars: true,       // Show Chinese characters (æ±‰å­—) - default ON
      showPinyin: true              // Show pinyin under each character - default ON
    };

    // ============================================================
    // STATE PERSISTENCE FUNCTIONS (localStorage)
    // ============================================================

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ saveState() - Save ALL user-configurable settings to localStorage      â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ WHEN TO CALL:                                                          â”‚
      â”‚   - On language change                                                 â”‚
      â”‚   - On act change                                                      â”‚
      â”‚   - On pack change                                                     â”‚
      â”‚   - On native language change                                          â”‚
      â”‚   - On any mode toggle (multiple choice, typing, pronunciation)        â”‚
      â”‚                                                                        â”‚
      â”‚ WHAT WE SAVE:                                                          â”‚
      â”‚   - currentLanguage: Target language being learned                     â”‚
      â”‚   - currentAct: Selected act number                                    â”‚
      â”‚   - currentPack: Selected pack key                                     â”‚
      â”‚   - currentNativeLanguage: Column index for "I speak" language         â”‚
      â”‚   - multipleChoiceMode: Boolean for wrong answers mode                 â”‚
      â”‚   - typingMode: Boolean for typing practice mode                       â”‚
      â”‚   - pronunciationMode: Boolean for speech recognition mode             â”‚
      â”‚                                                                        â”‚
      â”‚ WHAT WE DON'T SAVE:                                                    â”‚
      â”‚   - loadedData: Too large, will be reloaded on page load               â”‚
      â”‚   - typingStates: Per-session progress, not persistent                 â”‚
      â”‚   - pronunciationStates: Per-session progress, not persistent          â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function saveState() {
      const stateToSave = {
        currentLanguage: state.currentLanguage,
        currentAct: state.currentAct,
        currentPack: state.currentPack,
        currentNativeLanguage: state.currentNativeLanguage,
        multipleChoiceMode: state.multipleChoiceMode,
        typingMode: state.typingMode,
        pronunciationMode: state.pronunciationMode,
        flashcardMode: state.flashcardMode,
        // Chinese display options (saved so user preference persists)
        showChineseChars: state.showChineseChars,
        showPinyin: state.showPinyin
      };

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
      } catch (e) {
        console.error('Failed to save state to localStorage:', e);
      }
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ loadState() - Load saved state from localStorage                       â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ RETURNS:                                                               â”‚
      â”‚   - Parsed state object if found and valid JSON                        â”‚
      â”‚   - null if no saved state or invalid JSON                             â”‚
      â”‚                                                                        â”‚
      â”‚ NOTE: This just loads the raw data. Validation happens in              â”‚
      â”‚ restoreSavedState() to separate concerns.                              â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        return saved ? JSON.parse(saved) : null;
      } catch (e) {
        console.error('Failed to load state from localStorage:', e);
        return null;
      }
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ restoreSavedState() - Restore and VALIDATE saved state                 â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ CRITICAL: Always validate saved values before restoring!               â”‚
      â”‚                                                                        â”‚
      â”‚ WHY VALIDATE?                                                          â”‚
      â”‚   - User might have saved state from an older version                  â”‚
      â”‚   - Options might have changed (languages added/removed)               â”‚
      â”‚   - Corrupted data should not crash the app                            â”‚
      â”‚                                                                        â”‚
      â”‚ VALIDATION RULES:                                                      â”‚
      â”‚   - currentLanguage: Must be in VALID_LANGUAGES array                  â”‚
      â”‚   - currentAct: Must exist in loaded data (validated after load)       â”‚
      â”‚   - currentPack: Must exist in act data (validated after load)         â”‚
      â”‚   - currentNativeLanguage: Must be valid column for language           â”‚
      â”‚   - Mode booleans: Just need to be boolean type                        â”‚
      â”‚                                                                        â”‚
      â”‚ RETURNS: true if state was restored, false if no saved state           â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function restoreSavedState() {
      const saved = loadState();
      if (!saved) {
        console.log('No saved state found, using defaults');
        return false;
      }

      console.log('Restoring saved state:', saved);

      // Validate and restore language
      if (saved.currentLanguage && VALID_LANGUAGES.includes(saved.currentLanguage)) {
        state.currentLanguage = saved.currentLanguage;
      }

      // Validate and restore act (will be validated against loaded data later)
      if (saved.currentAct !== null && saved.currentAct !== undefined) {
        state.currentAct = saved.currentAct;
      }

      // Validate and restore pack (will be validated against act data later)
      if (saved.currentPack) {
        state.currentPack = saved.currentPack;
      }

      // Validate and restore native language column
      // Must be a valid column index for the current language
      if (saved.currentNativeLanguage !== null && saved.currentNativeLanguage !== undefined) {
        const config = LANGUAGE_CONFIG[state.currentLanguage];
        const validColumns = Object.values(config.nativeLanguages);
        if (validColumns.includes(saved.currentNativeLanguage)) {
          state.currentNativeLanguage = saved.currentNativeLanguage;
        } else {
          // Fall back to first available native language for this target language
          state.currentNativeLanguage = validColumns[0];
        }
      }

      // Restore mode booleans (simple validation: just check type)
      if (typeof saved.multipleChoiceMode === 'boolean') {
        state.multipleChoiceMode = saved.multipleChoiceMode;
      }
      if (typeof saved.typingMode === 'boolean') {
        state.typingMode = saved.typingMode;
      }
      if (typeof saved.pronunciationMode === 'boolean') {
        state.pronunciationMode = saved.pronunciationMode;
      }
      if (typeof saved.flashcardMode === 'boolean') {
        state.flashcardMode = saved.flashcardMode;
      }

      // Restore Chinese display options (both default to true if not saved)
      if (typeof saved.showChineseChars === 'boolean') {
        state.showChineseChars = saved.showChineseChars;
      }
      if (typeof saved.showPinyin === 'boolean') {
        state.showPinyin = saved.showPinyin;
      }

      return true;
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ validateAndFixState() - Validate state against loaded data             â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ CALLED AFTER data is loaded to ensure act/pack are valid.              â”‚
      â”‚                                                                        â”‚
      â”‚ This is separate from restoreSavedState() because we can't validate    â”‚
      â”‚ act/pack until the data is loaded from the modules.                    â”‚
      â”‚                                                                        â”‚
      â”‚ VALIDATION:                                                            â”‚
      â”‚   - If saved act doesn't exist in loaded data â†’ use first act          â”‚
      â”‚   - If saved pack doesn't exist in act â†’ use first pack                â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function validateAndFixState() {
      // Validate act exists in loaded data
      if (state.currentAct !== null && !state.loadedData[state.currentAct]) {
        console.log(`Saved act ${state.currentAct} not found, falling back to first act`);
        state.currentAct = null;  // Will be set by autoSelectFirstActAndPack
      }

      // Validate pack exists in act data
      if (state.currentAct && state.currentPack) {
        const actData = state.loadedData[state.currentAct];
        if (actData && !actData[state.currentPack]) {
          console.log(`Saved pack ${state.currentPack} not found in act ${state.currentAct}, falling back to first pack`);
          state.currentPack = null;  // Will be set by autoSelectFirstActAndPack
        }
      }
    }

    // ============================================================
    // SPEECH RECOGNITION SETUP
    // ============================================================

    /*
      Web Speech API setup for pronunciation recognition.

      BROWSER SUPPORT:
      - Chrome: Full support (webkitSpeechRecognition)
      - Edge: Full support (SpeechRecognition)
      - Firefox: Partial support
      - Safari: Limited support

      CONFIGURATION:
      - continuous: false (single utterance recognition)
      - interimResults: false (only final results)
      - maxAlternatives: 5 (check multiple interpretations for best match)
      - lang: Dynamic based on target language
    */
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;
    let currentListeningWordIndex = null;  // Track which word is being recorded

    // Language code mapping for speech recognition
    const SPEECH_LANG_CODES = {
      'Spanish': 'es-ES',
      'Chinese': 'zh-CN',
      'English': 'en-US'
    };

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.maxAlternatives = 5;
      // Language will be set dynamically based on currentLanguage
    }

    // ============================================================
    // KEY FEATURE: Module Decoding (3-Layer Obfuscation)
    // Core Objective: Load and decode compressed wordpack data
    // Key Behaviors:
    //   - Base64 decode â†’ Zlib decompress â†’ String reverse
    //   - Returns parsed JSON with all wordpacks in an act
    //   - Single function handles all decoding logic (DRY)
    // ============================================================

    /*
      Our wordpack modules are obfuscated using 3 layers of protection:
      1. Base64 encoding - Allows safe transport as JavaScript string
      2. Zlib compression (via pako) - Reduces file size by ~60%
      3. String reversal - Simple salt to prevent casual JSON parsing

      This function reverses all 3 steps to extract the original JSON data.

      INPUT: URL path to obfuscated module (e.g., './SpanishWords/Jsmodules-js/act1-foundation-js.js')
      OUTPUT: JavaScript object containing all wordpacks in that act

      EXAMPLE OUTPUT STRUCTURE:
      {
        "p1_1_greetings__goodbyes": {
          meta: { wordpack: 1, english: "Greetings & Goodbyes", ... },
          words: [
            ["hola amigo", "hello friend (masculine)", "ä½ å¥½æœ‹å‹", "nÇ hÇo pÃ©ngyÇ’u", "olÃ¡ amigo"],
            ["hola amiga", "hello friend (feminine)", "ä½ å¥½æœ‹å‹", "nÇ hÇo pÃ©ngyÇ’u", "olÃ¡ amiga"],
            ...
          ]
        },
        "p1_2_another_pack": { ... },
        ...
      }
    */
    async function decodeObfuscatedModule(url) {
      try {
        // STEP 1: Import the obfuscated module
        // The module exports a single variable 'w' containing the base64 string
        const module = await import(url);
        const compressedB64 = module.w;

        // STEP 2: Decode base64 to binary
        // atob() converts base64 string to binary string
        // We then convert to Uint8Array for pako
        const compressedBinary = Uint8Array.from(atob(compressedB64), c => c.charCodeAt(0));

        // STEP 3: Decompress with pako (zlib decompression)
        // This inflates the compressed data back to original size
        const decompressedBinary = pako.inflate(compressedBinary);

        // STEP 4: Convert binary to UTF-8 string
        const reversedJson = new TextDecoder('utf-8').decode(decompressedBinary);

        // STEP 5: Reverse the string (undo the salt)
        // Original was reversed character-by-character
        const jsonStr = reversedJson.split('').reverse().join('');

        // STEP 6: Parse JSON to get the original JavaScript object
        const data = JSON.parse(jsonStr);

        return data;
      } catch (error) {
        console.error('Failed to decode module:', url, error);
        throw error;
      }
    }

    // ============================================================
    // ============================================================
    // ğŸ¯ ARCHITECTURE: Combine and Shuffle Base/Example Words
    // ============================================================
    // ============================================================
    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚               ğŸ¯ CRITICAL LEARNING ARCHITECTURE ğŸ¯                       â”‚
      â”‚                                                                          â”‚
      â”‚  PURPOSE: Combine baseWords and exampleWords with controlled shuffling  â”‚
      â”‚                                                                          â”‚
      â”‚  WHY THIS MATTERS:                                                       â”‚
      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
      â”‚                                                                          â”‚
      â”‚  Educational Psychology: Learners should encounter CORE VOCABULARY      â”‚
      â”‚  before CONTEXTUAL EXAMPLES. This function ensures:                     â”‚
      â”‚                                                                          â”‚
      â”‚  1. BASE WORDS are shuffled internally (variety within basics)          â”‚
      â”‚  2. EXAMPLE WORDS are shuffled internally (variety within examples)     â”‚
      â”‚  3. BASE WORDS ALWAYS COME FIRST (pedagogical order preserved)          â”‚
      â”‚                                                                          â”‚
      â”‚  EXAMPLE OUTPUT:                                                         â”‚
      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
      â”‚                                                                          â”‚
      â”‚  Input baseWords:     ["hola", "adiÃ³s", "gracias"]                     â”‚
      â”‚  Input exampleWords:  ["hola amigo", "adiÃ³s amigos", "muchas gracias"] â”‚
      â”‚                                                                          â”‚
      â”‚  After shuffling baseWords:    ["gracias", "hola", "adiÃ³s"]            â”‚
      â”‚  After shuffling exampleWords: ["muchas gracias", "hola amigo", ...]   â”‚
      â”‚                                                                          â”‚
      â”‚  Final combined result:                                                  â”‚
      â”‚    ["gracias", "hola", "adiÃ³s", "muchas gracias", "hola amigo", ...]   â”‚
      â”‚     â””â”€â”€â”€â”€â”€â”€ base (shuffled) â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€ examples (shuffled) â”€â”€â”€â”€â”€â”˜   â”‚
      â”‚                                                                          â”‚
      â”‚  RESULT: User learns "hola" before "hola amigo", but order within      â”‚
      â”‚          each category is randomized for variety and engagement.        â”‚
      â”‚                                                                          â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

      INPUT: pack object with { baseWords: [...], exampleWords: [...] }
      OUTPUT: Array of objects with { word: [...], type: "Base Word" | "Example Word" }

      USAGE: Call this ONCE when loading a pack, store result as pack.words
    */
    function combineAndShuffleWords(pack) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 1: Extract base and example words (handle missing data gracefully)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const baseWords = pack.baseWords || [];
      const exampleWords = pack.exampleWords || [];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 2: Fisher-Yates Shuffle - used for BOTH base and example arrays
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This ensures proper randomization while keeping arrays separate
      function shuffleArray(array) {
        const shuffled = [...array];  // Create copy to avoid mutating original
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 3: Shuffle each section independently and TAG with type
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // We wrap each word array with metadata indicating if it's base or example.
      // This allows debugging to verify shuffling mechanism is working correctly.
      const shuffledBase = shuffleArray(baseWords).map(word => ({
        word: word,
        type: "Base Word"
      }));

      const shuffledExamples = shuffleArray(exampleWords).map(word => ({
        word: word,
        type: "Example Word"
      }));

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 4: Concatenate - BASE ALWAYS FIRST
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This is the CRITICAL step that preserves pedagogical order:
      // - Learners see core vocabulary first
      // - Then contextual examples build on that foundation
      // - But within each section, order is randomized for variety
      const combinedWords = [...shuffledBase, ...shuffledExamples];

      console.log(`[Architecture] Combined ${shuffledBase.length} base + ${shuffledExamples.length} examples = ${combinedWords.length} total words`);

      return combinedWords;
    }

    // ============================================================
    // KEY FEATURE: Auto-Select First Act and Pack (DRY ENCAPSULATION)
    // Core Objective: Automatically select first available act/pack
    // Key Behaviors:
    //   - Finds first act numerically
    //   - Selects first pack in that act
    //   - Updates UI dropdowns and displays vocabulary
    //   - Used by: initialize(), setupLanguageRadioButtons()
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      This logic was duplicated in initialize() and setupLanguageRadioButtons().
      Now defined ONCE and called from both places.

      "If I needed to change this behavior, how many places would I need to update?"
      Answer: 1 (this function)
    */
    function autoSelectFirstActAndPack() {
      if (!state.loadedData || Object.keys(state.loadedData).length === 0) {
        return;
      }

      // Find first act numerically
      const firstAct = Math.min(...Object.keys(state.loadedData).map(Number));
      state.currentAct = firstAct;
      document.getElementById('actSelect').value = firstAct;

      // Populate pack dropdown for first act
      populatePackDropdown();

      // Auto-select first pack
      const firstActData = state.loadedData[firstAct];
      if (firstActData) {
        const firstPackKey = Object.keys(firstActData)[0];
        state.currentPack = firstPackKey;
        document.getElementById('packSelect').value = firstPackKey;

        // Display vocabulary
        displayVocabulary();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist auto-selected act/pack to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      }
    }

    // ============================================================
    // INITIALIZATION: Load Data on Page Load
    // ============================================================

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ initialize() - Main initialization function                            â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ WORKFLOW (with state persistence):                                     â”‚
      â”‚   1. Restore saved state from localStorage (if any)                    â”‚
      â”‚   2. Load data for restored language (or default Spanish)              â”‚
      â”‚   3. Validate restored state against loaded data                       â”‚
      â”‚   4. Setup UI event listeners                                          â”‚
      â”‚   5. Sync UI to reflect restored state                                 â”‚
      â”‚   6. Auto-select first act/pack if needed                              â”‚
      â”‚   7. Display vocabulary                                                â”‚
      â”‚                                                                        â”‚
      â”‚ KEY PRINCIPLE: User returns to EXACTLY where they left off             â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    async function initialize() {
      updateDebugInfo('Initializing...');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 1: Restore saved state from localStorage
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This sets state.currentLanguage, state.currentAct, state.currentPack,
      // state.currentNativeLanguage, and mode flags if they were saved.
      const hadSavedState = restoreSavedState();

      updateDebugInfo(`Loading ${state.currentLanguage} data...`);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 2: Load data for the restored language (or default)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      await loadLanguageData(state.currentLanguage);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 3: Validate restored state against loaded data
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This ensures saved act/pack still exist in the loaded data.
      // If not, they'll be set to null and auto-selected below.
      if (hadSavedState) {
        validateAndFixState();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 4: Setup UI event listeners
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      setupLanguageRadioButtons();
      setupModeCheckboxes();  // ENCAPSULATED: Single function for all mode checkboxes
      setupChineseDisplayOptions();  // Chinese character + pinyin toggle handlers
      populateActDropdown();
      populateNativeLanguageDropdown();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 5: Sync UI to reflect restored state
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // The UI elements need to be updated to match the restored state
      syncUIToState();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEP 6: Auto-select or restore act/pack
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (state.currentAct && state.currentPack) {
        // We have valid restored state - just update dropdowns and display
        document.getElementById('actSelect').value = state.currentAct;
        populatePackDropdown();
        document.getElementById('packSelect').value = state.currentPack;
        displayVocabulary();
      } else {
        // No valid saved state - auto-select first act and pack (ENCAPSULATED - DRY)
        autoSelectFirstActAndPack();
      }

      updateDebugInfo('Initialization complete. Ready to use.');
    }

    /*
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ syncUIToState() - Update all UI elements to match current state        â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ ENCAPSULATED FUNCTION (DRY PRINCIPLE)                                  â”‚
      â”‚ This function syncs ALL UI elements to match the current state.        â”‚
      â”‚ Called during initialization to reflect restored localStorage state.   â”‚
      â”‚                                                                        â”‚
      â”‚ WHAT IT SYNCS:                                                         â”‚
      â”‚   - Language radio buttons                                             â”‚
      â”‚   - Mode checkboxes (multiple choice, typing, pronunciation)           â”‚
      â”‚   - Native language dropdown                                           â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    */
    function syncUIToState() {
      // Sync language radio buttons
      const languageRadios = document.querySelectorAll('input[name="language"]');
      languageRadios.forEach(radio => {
        radio.checked = (radio.value === state.currentLanguage);
      });

      // Sync mode checkboxes
      document.getElementById('multipleChoiceMode').checked = state.multipleChoiceMode;
      document.getElementById('typingMode').checked = state.typingMode;
      document.getElementById('pronunciationMode').checked = state.pronunciationMode;
      document.getElementById('flashcardMode').checked = state.flashcardMode;

      // Show/hide flashcard area based on mode
      const flashcardArea = document.getElementById('flashcardArea');
      if (flashcardArea) {
        flashcardArea.style.display = state.flashcardMode ? 'block' : 'none';
      }

      // Sync native language dropdown
      const nativeSelect = document.getElementById('nativeLanguageSelect');
      if (nativeSelect) {
        nativeSelect.value = state.currentNativeLanguage;
      }

      // Sync Chinese display options checkboxes
      const charsCheckbox = document.getElementById('showChineseChars');
      const pinyinCheckbox = document.getElementById('showPinyin');
      if (charsCheckbox) charsCheckbox.checked = state.showChineseChars;
      if (pinyinCheckbox) pinyinCheckbox.checked = state.showPinyin;

      // Show/hide Chinese options panel based on language context
      updateChineseOptionsVisibility();
    }

    // ============================================================
    // LOAD LANGUAGE DATA: Fetches and Decodes All Acts
    // ============================================================

    /*
      Loads all act modules for the specified language.

      INPUT: languageName (string) - 'Spanish', 'Chinese', or 'English'
      OUTPUT: Populates state.loadedData with decoded wordpacks

      PROCESS:
      1. Get module list from LANGUAGE_CONFIG
      2. Loop through each act module
      3. Decode the obfuscated module
      4. Store in state.loadedData[actNumber]
    */
    async function loadLanguageData(languageName) {
      updateDebugInfo(`Loading ${languageName} data...`);

      const config = LANGUAGE_CONFIG[languageName];
      state.loadedData = {};      // Clear previous data
      state.loadedActMeta = {};   // Clear previous metadata

      // Load each act module
      for (const moduleInfo of config.modules) {
        updateDebugInfo(`Loading Act ${moduleInfo.act}: ${moduleInfo.name}...`);

        try {
          const actData = await decodeObfuscatedModule(moduleInfo.path);

          // Extract and store __actMeta (contains actName, translations, wordColumns, etc.)
          // This is the same pattern as ChineseFlashcardTypingGame.html
          if (actData.__actMeta) {
            state.loadedActMeta[moduleInfo.act] = actData.__actMeta;
            console.log(`Act ${moduleInfo.act} metadata:`, actData.__actMeta.actName);
          }

          // Store only pack data (exclude __actMeta)
          const packsOnly = { ...actData };
          delete packsOnly.__actMeta;

          state.loadedData[moduleInfo.act] = packsOnly;
          updateDebugInfo(`âœ“ Act ${moduleInfo.act} loaded (${Object.keys(packsOnly).length} packs)`);
        } catch (error) {
          updateDebugInfo(`âœ— Failed to load Act ${moduleInfo.act}: ${error.message}`);
        }
      }

      updateDebugInfo(`${languageName} data loading complete.`);
    }

    // ============================================================
    // KEY FEATURE: Language Selection (Radio Buttons)
    // Core Objective: Switch between target languages (Spanish/Chinese/English)
    // Key Behaviors:
    //   - Reloads all act data for selected language
    //   - Resets native language to first available option
    //   - Auto-selects first act/pack via encapsulated function (DRY)
    // ============================================================

    /*
      Attaches change event listeners to language radio buttons.
      When user changes language, reload all data for that language.

      STATE PERSISTENCE: Calls saveState() after language change.
    */
    function setupLanguageRadioButtons() {
      const radios = document.querySelectorAll('input[name="language"]');
      radios.forEach(radio => {
        radio.addEventListener('change', async (e) => {
          const newLanguage = e.target.value;
          state.currentLanguage = newLanguage;
          state.currentAct = null;
          state.currentPack = null;

          // Reload data for new language (this populates state.loadedActMeta)
          await loadLanguageData(newLanguage);

          // Reset native language to first available option from loaded metadata
          // NO FALLBACK - if modules didn't load, we have no valid options
          const firstActMeta = Object.values(state.loadedActMeta)[0];
          if (firstActMeta && firstActMeta.translations) {
            const firstTranslation = Object.values(firstActMeta.translations)[0];
            state.currentNativeLanguage = firstTranslation.index;
          }
          // If no modules loaded, currentNativeLanguage stays at previous value
          // but dropdown will be empty anyway

          // Update UI
          populateActDropdown();
          populateNativeLanguageDropdown();

          // Update Chinese display options visibility (show/hide based on language)
          updateChineseOptionsVisibility();

          // Auto-select first act and pack (ENCAPSULATED - DRY)
          // Previously this was 15+ lines of duplicated code
          autoSelectFirstActAndPack();

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SAVE STATE: Persist language change to localStorage
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          saveState();
        });
      });
    }

    // ============================================================
    // KEY FEATURE: Mode Checkboxes (DRY ENCAPSULATION)
    // Core Objective: Toggle display modes (multiple choice, typing, pronunciation)
    // Key Behaviors:
    //   - Each checkbox toggles a state flag
    //   - Some modes require state reset (typing, pronunciation)
    //   - All modes refresh vocabulary display on change
    //   - Single configuration-driven function (DRY)
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      Previously we had THREE separate functions:
      - setupMultipleChoiceCheckbox()
      - setupTypingModeCheckbox()
      - setupPronunciationModeCheckbox()

      All followed the same pattern:
      1. Get checkbox by ID
      2. Add change listener
      3. Update state property
      4. (Optionally) Clear some states
      5. Refresh display

      Now we define this ONCE with a configuration array.
      "If I needed to change the checkbox behavior, how many places would I need to update?"
      Answer: 1 (this function)
    */
    function setupModeCheckboxes() {
      // Configuration array: [checkboxId, stateKey, statesToClear, onChangeCallback]
      // The onChangeCallback is optional - used for modes that need extra logic
      const checkboxConfig = [
        { id: 'multipleChoiceMode', stateKey: 'multipleChoiceMode', statesToClear: [] },
        { id: 'typingMode', stateKey: 'typingMode', statesToClear: ['typingStates'] },
        { id: 'pronunciationMode', stateKey: 'pronunciationMode', statesToClear: ['pronunciationStates'] },
        { id: 'flashcardMode', stateKey: 'flashcardMode', statesToClear: [], onChangeCallback: handleFlashcardModeChange }
      ];

      checkboxConfig.forEach(({ id, stateKey, statesToClear, onChangeCallback }) => {
        const checkbox = document.getElementById(id);
        if (!checkbox) return;

        checkbox.addEventListener('change', (e) => {
          // Update the state flag
          state[stateKey] = e.target.checked;

          // Clear associated states if specified
          statesToClear.forEach(stateMapKey => {
            if (state[stateMapKey] && typeof state[stateMapKey].clear === 'function') {
              state[stateMapKey].clear();
            }
          });

          // Call optional callback for modes that need extra logic
          if (onChangeCallback) {
            onChangeCallback(e.target.checked);
          }

          // Refresh table with new mode
          displayVocabulary();

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SAVE STATE: Persist mode toggle to localStorage
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          saveState();
        });
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EDGE CASE FILTER: Event listener for "Show Edge Cases Only" checkbox
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const edgeCaseCheckbox = document.getElementById('showEdgeCasesOnly');
      if (edgeCaseCheckbox) {
        edgeCaseCheckbox.addEventListener('change', () => {
          // Just refresh the table display with the new filter
          displayVocabulary();
        });
      }
    }

    // ============================================================
    // KEY FEATURE: Speech Recognition (Pronunciation Practice)
    // Core Objective: Allow users to practice pronunciation with feedback
    // Key Behaviors:
    //   - Uses Web Speech API for speech-to-text
    //   - Calculates similarity using Levenshtein distance
    //   - Visual feedback (ğŸ”´ recording, ğŸ¤ idle)
    //   - Reset state encapsulated for DRY
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      Reset listening state appears in 3 places: onresult, onerror, onend
      Now defined ONCE and called from all places.
    */
    function resetListeningState(recordButton) {
      isListening = false;
      currentListeningWordIndex = null;
      if (recordButton) {
        recordButton.textContent = 'ğŸ¤';
      }
    }

    /*
      Starts speech recognition for a specific word in the vocabulary table.

      PROCESS:
      1. Check if speech recognition is available
      2. Set recognition language based on target language
      3. Start listening
      4. On result: Calculate similarity, update state, refresh display
      5. On error: Handle gracefully (no-speech, permission denied)

      PARAMETERS:
      - wordIndex: Index of word in the pack (for state tracking)
      - correctWord: The expected word (target language)
      - recordButton: The button element to update visual state

      VISUAL FEEDBACK:
      - Button shows "ğŸ”´" while recording
      - Button shows "ğŸ¤" when idle (via resetListeningState - DRY)
    */
    function startListeningForPronunciation(wordIndex, correctWord, recordButton) {
      if (!recognition) {
        alert('Speech recognition is not supported in your browser. Try Chrome or Edge.');
        return;
      }

      if (isListening) return;

      isListening = true;
      currentListeningWordIndex = wordIndex;
      recognition.lang = SPEECH_LANG_CODES[state.currentLanguage] || 'en-US';
      recordButton.textContent = 'ğŸ”´';

      recognition.onresult = (event) => {
        const results = event.results[0];
        let bestMatch = results[0].transcript;
        let bestScore = 0;

        for (let i = 0; i < results.length; i++) {
          const transcript = results[i].transcript;
          const score = calculateSimilarity(correctWord, transcript);
          if (score > bestScore) {
            bestScore = score;
            bestMatch = transcript;
          }
        }

        state.pronunciationStates.set(wordIndex, {
          score: bestScore,
          heard: bestMatch,
          attempted: true
        });

        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);
        updatePronunciationDisplay(wordIndex, recordButton);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);

        if (event.error === 'no-speech') {
          state.pronunciationStates.set(wordIndex, {
            score: 0,
            heard: '(no speech detected)',
            attempted: true
          });
          updatePronunciationDisplay(wordIndex, recordButton);
        } else if (event.error === 'not-allowed') {
          alert('Microphone access denied. Please allow microphone access to use this feature.');
        }
      };

      recognition.onend = () => {
        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);
      };

      recognition.start();
    }

    // ============================================================
    // UPDATE PRONUNCIATION DISPLAY: Show Score in Table Cell
    // ============================================================

    /*
      Updates the score column for a word after pronunciation attempt.

      PARAMETERS:
      - wordIndex: Index of word in pack
      - recordButton: The button element (to find the row)
    */
    function updatePronunciationDisplay(wordIndex, recordButton) {
      const pronState = state.pronunciationStates.get(wordIndex);
      if (!pronState) return;

      const row = recordButton.closest('tr');
      if (!row) return;

      // Score cell is the last cell in the row when pronunciation mode is on
      const scoreCell = row.cells[row.cells.length - 1];
      if (scoreCell) {
        scoreCell.textContent = `${pronState.score}%`;
        scoreCell.title = `Heard: "${pronState.heard}"`;
      }
    }

    // ============================================================
    // AUDIO CONTEXT: For Typing Sound Generation
    // ============================================================

    /*
      Creates and returns the Web Audio API context for sound generation.
      This is used for the satisfying typing/scribble sound.
    */
    let audioContext = null;

    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // ============================================================
    // TYPING SOUND: Mechanical Click (Improved from SimpleFlashCards)
    // ============================================================

    /*
      Plays a satisfying mechanical keyboard click sound on every keypress.
      This sound plays for BOTH correct and wrong keypress (instant feedback).

      SOUND CHARACTERISTICS:
      - Very short duration (0.015-0.025 seconds) for crisp click
      - High frequency (2000-3500 Hz) for mechanical feel
      - Random variation in frequency and volume for natural typing feel
      - Sharp decay envelope for crisp, defined click

      USAGE IN GAMES:
      This sound provides immediate tactile feedback that makes typing feel
      satisfying and responsive. It's crucial for engagement - even wrong
      keypresses should "feel good" to maintain flow state.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Slightly cleaner filter chain
      - Better commented for understanding
    */
    function playTypingSound() {
      const ctx = getAudioContext();

      // Very short duration for crisp mechanical click
      const duration = 0.015 + Math.random() * 0.01;  // 0.015-0.025 seconds
      const bufferSize = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      // Generate sharp click noise with very fast decay
      for (let i = 0; i < bufferSize; i++) {
        const envelope = Math.pow(1 - i/bufferSize, 8);  // Very sharp decay
        const noise = (Math.random() * 2 - 1);
        data[i] = noise * envelope;
      }

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // High frequency bandpass for mechanical click (2000-3500 Hz)
      const bp1 = ctx.createBiquadFilter();
      bp1.type = 'bandpass';
      bp1.frequency.value = 2000 + Math.random() * 1500;  // Random variation
      bp1.Q.value = 4.0;  // High Q for sharp, defined click

      // Mid frequency for body (1000-1500 Hz)
      const bp2 = ctx.createBiquadFilter();
      bp2.type = 'bandpass';
      bp2.frequency.value = 1000 + Math.random() * 500;
      bp2.Q.value = 2.5;

      // Remove low mud
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 400;

      // Moderate volume for satisfying click
      const gain = ctx.createGain();
      gain.gain.value = 0.35 + Math.random() * 0.1;  // 0.35-0.45 with random variation

      // Connect audio chain
      source.connect(hp);
      hp.connect(bp1);
      bp1.connect(bp2);
      bp2.connect(gain);
      gain.connect(ctx.destination);

      source.start();
    }

    // ============================================================
    // LEVENSHTEIN DISTANCE: For Pronunciation Similarity
    // ============================================================

    /*
      Calculates the Levenshtein (edit) distance between two strings.
      This is the minimum number of single-character edits (insertions,
      deletions, or substitutions) required to change one string into another.

      ALGORITHM: Dynamic Programming approach
      - Time complexity: O(m * n) where m and n are string lengths
      - Space complexity: O(m * n) for the DP table

      EXAMPLE:
      - "hola" vs "hola" = 0 (identical)
      - "hola" vs "hole" = 1 (one substitution)
      - "hola" vs "hol" = 1 (one deletion)
      - "hola" vs "holaa" = 1 (one insertion)

      INPUT: Two strings to compare
      OUTPUT: Integer distance (0 = identical, higher = more different)
    */
    function levenshteinDistance(str1, str2) {
      const m = str1.length;
      const n = str2.length;

      // Create DP table
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

      // Initialize base cases
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;

      // Fill DP table
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (str1[i - 1] === str2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];  // No edit needed
          } else {
            dp[i][j] = 1 + Math.min(
              dp[i - 1][j],     // Deletion
              dp[i][j - 1],     // Insertion
              dp[i - 1][j - 1]  // Substitution
            );
          }
        }
      }

      return dp[m][n];
    }

    // ============================================================
    // SIMILARITY PERCENTAGE: Convert Distance to Percentage
    // ============================================================

    /*
      Converts Levenshtein distance to a percentage similarity score.

      FORMULA: ((maxLen - distance) / maxLen) * 100
      - Perfect match = 100%
      - Completely different = 0%

      NORMALIZATION:
      - Both strings are lowercased for comparison
      - Trimmed of whitespace

      EXAMPLES:
      - "hola" vs "hola" = 100%
      - "hola" vs "hole" = 75% (3 of 4 chars match concept)
      - "hello" vs "hola" = 40% (2 edits on length 5)

      INPUT: expected (correct answer), heard (speech recognition result)
      OUTPUT: Integer percentage 0-100
    */
    function calculateSimilarity(expected, heard) {
      const exp = expected.toLowerCase().trim();
      const hrd = heard.toLowerCase().trim();

      if (exp === hrd) return 100;
      if (hrd.length === 0) return 0;

      const distance = levenshteinDistance(exp, hrd);
      const maxLen = Math.max(exp.length, hrd.length);
      const similarity = Math.max(0, ((maxLen - distance) / maxLen) * 100);

      return Math.round(similarity);
    }

    // ============================================================
    // CHARACTER NORMALIZATION: For Typing Comparison
    // ============================================================

    /*
      Normalizes a character for typing comparison.

      NORMALIZATION RULES:
      1. Convert to lowercase
      2. Remove accents/diacritics (Ã¡ â†’ a, Ã± â†’ n, Ã¼ â†’ u, etc.)

      EXAMPLES:
      - 'Ã' â†’ 'a'
      - 'Ã±' â†’ 'n'
      - 'Ãœ' â†’ 'u'
      - 'Ã‰' â†’ 'e'

      WHY THIS MATTERS FOR GAMES:
      Most English keyboards don't have accent keys, so learners type
      'hola' instead of 'hÃ³la'. We want to accept their answer as correct.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Same logic, but more clearly documented
      - Explains the "why" for future game developers

      INPUT: Single character string
      OUTPUT: Normalized single character (lowercase, no accents)
    */
    function normalizeCharForTyping(char) {
      return char
        .normalize('NFD')                    // Decompose accents (Ã¡ â†’ a + Â´)
        .replace(/[\u0300-\u036f]/g, '')    // Remove accent marks
        .toLowerCase();                      // Convert to lowercase
    }

    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘                                                                              â•‘
    // â•‘       CHINESE CHARACTER + PINYIN COUPLING SYSTEM                             â•‘
    // â•‘       (Anti-Decoupling Applied to Character Level)                           â•‘
    // â•‘                                                                              â•‘
    // â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
    // â•‘                                                                              â•‘
    // â•‘  PURPOSE:                                                                    â•‘
    // â•‘  Ensure each Chinese character is PERMANENTLY LINKED to its pinyin.         â•‘
    // â•‘  This is the SAME anti-decoupling principle as flashcard front/back,        â•‘
    // â•‘  but applied at the character level instead of card level.                  â•‘
    // â•‘                                                                              â•‘
    // â•‘  THE PROBLEM:                                                                â•‘
    // â•‘  Chinese: "å°çŒ«"     Pinyin: "xiÇo mÄo"                                      â•‘
    // â•‘  If stored separately, they can get out of sync:                            â•‘
    // â•‘    - Someone edits Chinese to "å°çŒ«å’ª" but forgets pinyin                   â•‘
    // â•‘    - Pinyin syllables don't match character count                           â•‘
    // â•‘    - User sees wrong pinyin under wrong character                           â•‘
    // â•‘                                                                              â•‘
    // â•‘  THE SOLUTION:                                                               â•‘
    // â•‘  Transform at load time into COUPLED objects:                               â•‘
    // â•‘  [                                                                           â•‘
    // â•‘    { char: "å°", pinyin: "xiÇo" },                                           â•‘
    // â•‘    { char: "çŒ«", pinyin: "mÄo" }                                             â•‘
    // â•‘  ]                                                                           â•‘
    // â•‘  Now they CANNOT get out of sync - they're properties of same object!       â•‘
    // â•‘                                                                              â•‘
    // â•‘  FUNCTIONS IN THIS SECTION:                                                  â•‘
    // â•‘  1. coupleChineseWithPinyin() - Creates the coupled array                   â•‘
    // â•‘  2. renderChineseWithPinyin() - Creates HTML with pinyin under chars        â•‘
    // â•‘  3. setupChineseDisplayOptions() - Handles checkbox events                  â•‘
    // â•‘  4. updateChineseOptionsVisibility() - Shows/hides options panel            â•‘
    // â•‘                                                                              â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // ============================================================
    // CHINESE COUPLING: Character + Pinyin Pairing
    // ============================================================

    /*
      coupleChineseWithPinyin() - Creates anti-decoupled character-pinyin pairs

      WHY THIS FUNCTION EXISTS:
      Our CSV and JS modules store Chinese and Pinyin as separate strings:
        - Chinese: "å°çŒ«" (column 0 for Chinese)
        - Pinyin:  "xiÇo mÄo" (column 1 for Chinese)

      This is fine for storage (human-readable), but DANGEROUS for display.
      If we split them separately, they could get out of sync.

      SOLUTION: Transform at load time into coupled objects.
      Each character is paired with its pinyin syllable IN THE SAME OBJECT.

      ALGORITHM:
      1. Split Chinese string into individual characters (using [...str])
      2. Split pinyin string by spaces into syllables
      3. Validate: character count MUST equal syllable count
      4. Zip together: char[i] pairs with syllable[i]
      5. Return array of {char, pinyin} objects

      ERROR HANDLING:
      - If counts don't match, log warning and pad with '?'
      - Never crash - always return something displayable
      - Validation helps catch data errors early

      EXAMPLE:
      INPUT:  coupleChineseWithPinyin("å°çŒ«", "xiÇo mÄo")
      OUTPUT: [{char: "å°", pinyin: "xiÇo"}, {char: "çŒ«", pinyin: "mÄo"}]

      INPUT:  coupleChineseWithPinyin("ä½ å¥½ä¸–ç•Œ", "nÇ hÇo shÃ¬ jiÃ¨")
      OUTPUT: [{char: "ä½ ", pinyin: "nÇ"}, {char: "å¥½", pinyin: "hÇo"},
               {char: "ä¸–", pinyin: "shÃ¬"}, {char: "ç•Œ", pinyin: "jiÃ¨"}]

      PARAMETERS:
        - chineseStr: String of Chinese characters (e.g., "å°çŒ«")
        - pinyinStr: Space-separated pinyin syllables (e.g., "xiÇo mÄo")

      RETURNS: Array of {char, pinyin} objects
    */
    function coupleChineseWithPinyin(chineseStr, pinyinStr) {
      // Handle empty/null inputs gracefully
      if (!chineseStr) return [];
      if (!pinyinStr) {
        // No pinyin available - return chars with empty pinyin
        return [...chineseStr].map(char => ({ char, pinyin: '' }));
      }

      // Split Chinese into individual characters
      // Using [...str] handles multi-byte Unicode correctly
      const chars = [...chineseStr];

      // Split pinyin by spaces into syllables
      const syllables = pinyinStr.trim().split(/\s+/);

      // Validate: character count should match syllable count
      // (Each Chinese character has exactly one pinyin syllable)
      if (chars.length !== syllables.length) {
        console.warn(
          `PINYIN MISMATCH: "${chineseStr}" has ${chars.length} chars ` +
          `but "${pinyinStr}" has ${syllables.length} syllables. ` +
          `Data may be corrupted.`
        );
      }

      // Create coupled array - each char paired with its syllable
      // Use '?' for missing syllables to make errors visible
      return chars.map((char, i) => ({
        char: char,
        pinyin: syllables[i] || '?'
      }));
    }

    // ============================================================
    // CHINESE RENDERING: Display Characters with Pinyin
    // ============================================================

    /*
      renderChineseWithPinyin() - Creates HTML element showing chars with pinyin

      WHAT IT RENDERS:
      For each character, creates a vertical stack:
        â”Œâ”€â”€â”€â”€â”€â”
        â”‚ å°  â”‚  â† Chinese character (larger font)
        â”‚xiÇo â”‚  â† Pinyin syllable (smaller font)
        â””â”€â”€â”€â”€â”€â”˜

      Multiple characters are displayed side-by-side:
        â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
        â”‚ å°  â”‚ çŒ«  â”‚
        â”‚xiÇo â”‚ mÄo â”‚
        â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

      DISPLAY OPTIONS (controlled by state.showChineseChars & state.showPinyin):
      - Both checked:     Show characters AND pinyin (default)
      - Only chars:       Show characters only (no pinyin)
      - Only pinyin:      Show pinyin only (no characters)
      - Neither checked:  Show empty (edge case)

      WHY USE HTML ELEMENTS INSTEAD OF TEXT?
      - Text can't position pinyin under each specific character
      - With elements, pinyin is vertically aligned under its character
      - CSS flexbox handles the horizontal layout automatically

      EXAMPLE OUTPUT HTML:
      <span class="chinese-coupled" style="display: inline-flex; gap: 2px;">
        <span class="char-group" style="display: flex; flex-direction: column; align-items: center;">
          <span class="chinese-char" style="font-size: 1.2em;">å°</span>
          <span class="pinyin" style="font-size: 0.7em; color: #666;">xiÇo</span>
        </span>
        <span class="char-group" style="...">
          <span class="chinese-char" style="...">çŒ«</span>
          <span class="pinyin" style="...">mÄo</span>
        </span>
      </span>

      PARAMETERS:
        - coupledArray: Array from coupleChineseWithPinyin() - [{char, pinyin}, ...]

      RETURNS: DOM element (span) ready to append to any container
    */
    function renderChineseWithPinyin(coupledArray) {
      // Create container for the whole word
      const container = document.createElement('span');
      container.className = 'chinese-coupled';
      container.style.cssText = 'display: inline-flex; gap: 2px; align-items: flex-end;';

      // Handle empty array
      if (!coupledArray || coupledArray.length === 0) {
        container.textContent = '';
        return container;
      }

      // Create a character group for each char-pinyin pair
      coupledArray.forEach(({ char, pinyin }) => {
        const charGroup = document.createElement('span');
        charGroup.className = 'char-group';
        charGroup.style.cssText = 'display: flex; flex-direction: column; align-items: center;';

        // Character element (top)
        if (state.showChineseChars) {
          const charSpan = document.createElement('span');
          charSpan.className = 'chinese-char';
          charSpan.style.cssText = 'font-size: 1.2em; line-height: 1.2;';
          charSpan.textContent = char;
          charGroup.appendChild(charSpan);
        }

        // Pinyin element (bottom)
        if (state.showPinyin) {
          const pinyinSpan = document.createElement('span');
          pinyinSpan.className = 'pinyin';
          pinyinSpan.style.cssText = 'font-size: 0.7em; color: #666; line-height: 1;';
          pinyinSpan.textContent = pinyin;
          charGroup.appendChild(pinyinSpan);
        }

        container.appendChild(charGroup);
      });

      return container;
    }

    /*
      renderChineseText() - High-level function to render Chinese with pinyin

      This is the MAIN ENTRY POINT for rendering Chinese text anywhere in the app.
      It handles the full pipeline: couple â†’ render.

      WHEN TO USE:
      - Displaying Chinese vocabulary in table (target language column)
      - Displaying Chinese translations (native language column when Chinese)
      - Flashcard front when learning Chinese
      - Multiple choice options when answers are Chinese
      - ANY place where Chinese text needs the char+pinyin display

      IMPORTANT: This function checks if we're dealing with Chinese.
      If not Chinese, it returns a simple text span (no coupling needed).

      PARAMETERS:
        - text: The Chinese text string (e.g., "å°çŒ«")
        - pinyin: The pinyin string (e.g., "xiÇo mÄo")
        - isChinese: Boolean flag - true if this is Chinese text

      RETURNS: DOM element (span) with appropriate rendering
    */
    function renderChineseText(text, pinyin, isChinese) {
      // If not Chinese, just return plain text
      if (!isChinese) {
        const span = document.createElement('span');
        span.textContent = text;
        return span;
      }

      // Chinese: couple and render
      const coupled = coupleChineseWithPinyin(text, pinyin);
      return renderChineseWithPinyin(coupled);
    }

    // ============================================================
    // CHINESE OPTIONS: Checkbox Setup and Visibility
    // ============================================================

    /*
      setupChineseDisplayOptions() - Initialize checkbox event handlers

      WHAT IT DOES:
      - Adds change listeners to showChineseChars and showPinyin checkboxes
      - When toggled: updates state, saves to localStorage, refreshes display

      WHY GLOBAL REFRESH?
      Chinese display affects multiple places:
      - Vocabulary table
      - Flashcard content
      - Multiple choice options
      All must update when display options change, hence full displayVocabulary() call.

      CALLED FROM: initialize()
    */
    function setupChineseDisplayOptions() {
      const charsCheckbox = document.getElementById('showChineseChars');
      const pinyinCheckbox = document.getElementById('showPinyin');

      if (charsCheckbox) {
        charsCheckbox.addEventListener('change', (e) => {
          state.showChineseChars = e.target.checked;
          displayVocabulary();  // Refresh all displays

          // Also refresh flashcard if visible
          if (state.flashcardMode) {
            updateFlashcardDisplay();
          }

          saveState();  // Persist preference
        });
      }

      if (pinyinCheckbox) {
        pinyinCheckbox.addEventListener('change', (e) => {
          state.showPinyin = e.target.checked;
          displayVocabulary();  // Refresh all displays

          // Also refresh flashcard if visible
          if (state.flashcardMode) {
            updateFlashcardDisplay();
          }

          saveState();  // Persist preference
        });
      }
    }

    /*
      updateChineseOptionsVisibility() - Show/hide Chinese options panel

      LOGIC:
      The Chinese display options panel should be visible when:
      1. Learning Chinese (state.currentLanguage === 'Chinese')
      2. OR when native language is Chinese/Pinyin (showing Chinese translations)

      CALLED FROM:
      - setupLanguageRadioButtons() when language changes
      - populateNativeLanguageDropdown() when native language changes
      - initialize() on page load
    */
    function updateChineseOptionsVisibility() {
      const optionsDiv = document.getElementById('chineseDisplayOptions');
      if (!optionsDiv) return;

      // Determine if Chinese is involved
      let showOptions = false;

      // Case 1: Learning Chinese
      if (state.currentLanguage === 'Chinese') {
        showOptions = true;
      }

      // Case 2: Native language is Chinese (translation column shows Chinese)
      // Check if the selected native language index corresponds to Chinese
      // For Spanish: column 2 is Chinese, column 3 is Pinyin
      // For English: columns vary
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      if (config && config.nativeLanguages) {
        const nativeEntries = Object.entries(config.nativeLanguages);
        for (const [name, colIndex] of nativeEntries) {
          if (colIndex === state.currentNativeLanguage) {
            // Check if this native language is Chinese-related
            if (name.toLowerCase().includes('chinese') || name.toLowerCase().includes('pinyin')) {
              showOptions = true;
            }
            break;
          }
        }
      }

      optionsDiv.style.display = showOptions ? 'block' : 'none';

      // Also update edge case filter visibility (same condition)
      const edgeFilterDiv = document.getElementById('edgeCaseFilterContainer');
      if (edgeFilterDiv) {
        edgeFilterDiv.style.display = showOptions ? 'block' : 'none';
      }
    }

    // ============================================================
    // POPULATE ACT DROPDOWN: Based on Loaded Data
    // ============================================================

    /*
      Populates the act dropdown with available acts for current language.

      PROCESS:
      1. Get acts from state.loadedData
      2. Get act names from LANGUAGE_CONFIG
      3. Create option elements
      4. Add change event listener
    */
    function populateActDropdown() {
      const actSelect = document.getElementById('actSelect');
      actSelect.innerHTML = '';

      const acts = Object.keys(state.loadedData).map(Number).sort((a, b) => a - b);

      acts.forEach(actNum => {
        // Use __actMeta from loaded module (same as ChineseFlashcardTypingGame.html)
        const actMeta = state.loadedActMeta[actNum];
        const actName = actMeta ? actMeta.actName : `Act ${actNum}`;
        const option = document.createElement('option');
        option.value = actNum;
        option.textContent = `Act ${actNum}: ${actName}`;
        actSelect.appendChild(option);
      });

      // Event listener for act change
      actSelect.addEventListener('change', (e) => {
        state.currentAct = parseInt(e.target.value);
        state.currentPack = null;
        populatePackDropdown();
        displayVocabulary();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist act change to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      });
    }

    // ============================================================
    // POPULATE PACK DROPDOWN: Based on Selected Act
    // ============================================================

    /*
      Populates the pack dropdown with wordpacks from selected act.

      PROCESS:
      1. Get pack keys from state.loadedData[currentAct]
      2. Extract pack metadata (title in English)
      3. Create option elements
      4. Add change event listener
    */
    function populatePackDropdown() {
      const packSelect = document.getElementById('packSelect');

      if (!state.currentAct) {
        packSelect.innerHTML = '';
        return;
      }

      packSelect.innerHTML = '';

      const actData = state.loadedData[state.currentAct];
      if (!actData) return;

      // Get all pack keys and sort by wordpack number
      const packKeys = Object.keys(actData);
      packKeys.sort((a, b) => {
        const numA = actData[a].meta.wordpack;
        const numB = actData[b].meta.wordpack;
        return numA - numB;
      });

      packKeys.forEach(packKey => {
        const pack = actData[packKey];
        const option = document.createElement('option');
        option.value = packKey;
        option.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;
        packSelect.appendChild(option);
      });

      // Event listener for pack change
      packSelect.addEventListener('change', (e) => {
        state.currentPack = e.target.value;
        displayVocabulary();

        // Re-initialize flashcard deck if flashcard mode is enabled
        if (state.flashcardMode) {
          initFlashcardDeck();
          updateFlashcardDisplay();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist pack change to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      });
    }

    // ============================================================
    // POPULATE NATIVE LANGUAGE DROPDOWN: Based on Current Language
    // ============================================================

    /*
      Populates the "I speak" dropdown with available native languages.
      Available options depend on the column structure of target language.

      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      ARCHITECTURE PRINCIPLE: NO HARDCODED DATA - MODULES ARE THE SOURCE OF TRUTH
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      If JS modules fail to load, this dropdown stays EMPTY.
      ALL options come from __actMeta.translations in loaded modules.
      There is NO fallback - without modules, the app is intentionally dead.
      This ensures we immediately know when modules aren't loading properly.
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      EXAMPLE:
      If learning Spanish, can choose: English, Chinese, Pinyin, Portuguese
      If learning Chinese, can choose: English, Spanish, French, Portuguese, etc.
    */
    function populateNativeLanguageDropdown() {
      const nativeSelect = document.getElementById('nativeLanguageSelect');
      nativeSelect.innerHTML = '';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Get translations ONLY from loaded __actMeta - NO FALLBACK
      // If modules didn't load, dropdown stays empty (this is intentional)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const firstActMeta = Object.values(state.loadedActMeta)[0];
      if (!firstActMeta || !firstActMeta.translations) {
        // No modules loaded = no options. This is correct behavior.
        console.warn('[populateNativeLanguageDropdown] No modules loaded - dropdown empty');
        return;
      }

      // Use translations from __actMeta - format: { english: { index: 2, display: "English" }, ... }
      Object.entries(firstActMeta.translations).forEach(([key, config]) => {
        const option = document.createElement('option');
        option.value = config.index;
        option.textContent = config.display;
        if (config.index === state.currentNativeLanguage) {
          option.selected = true;
        }
        nativeSelect.appendChild(option);
      });

      // Event listener for native language change
      nativeSelect.addEventListener('change', (e) => {
        state.currentNativeLanguage = parseInt(e.target.value);
        displayVocabulary();

        // Update Chinese display options visibility
        // (If user switches to Chinese translation, show the options)
        updateChineseOptionsVisibility();

        // Also refresh flashcard if visible (translation might be Chinese now)
        if (state.flashcardMode) {
          initFlashcardDeck();  // Rebuild deck with new native language
          updateFlashcardDisplay();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SAVE STATE: Persist native language change to localStorage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        saveState();
      });
    }

    // ============================================================
    // STRING NORMALIZATION: For Duplicate Detection
    // ============================================================

    /*
      Normalizes strings for comparison to detect duplicates across wordpacks.

      NORMALIZATION PROCESS:
      1. Convert to lowercase
      2. Remove all spaces
      3. Remove all symbols/punctuation

      EXAMPLES:
      - "Hola Amigo" â†’ "holaamigo"
      - "hello, friend!" â†’ "hellofriend"
      - "ä½ å¥½ æœ‹å‹" â†’ "ä½ å¥½æœ‹å‹"

      This catches duplicates that may appear with slight variations:
      - "hola" and "Hola" (case difference)
      - "hello friend" and "hellofriend" (spacing difference)
      - "hello!" and "hello" (punctuation difference)

      INPUT: String to normalize
      OUTPUT: Normalized string (lowercase, no spaces, no symbols)
    */
    function normalizeString(str) {
      return str
        .toLowerCase()
        .replace(/[\s\.,!?;:'"()\[\]{}\-_]/g, '');  // Remove spaces and common symbols
    }

    // ============================================================
    // KEY FEATURE: Multiple Choice Wrong Answers (Act-Wide Pool)
    // Core Objective: Generate diverse, non-duplicate wrong answers
    // Key Behaviors:
    //   - Pulls from ENTIRE ACT (~2,500 words) not just current pack
    //   - Filters duplicates via normalized string comparison
    //   - Uses Fisher-Yates shuffle for uniform randomness
    //   - Works for ANY language (Spanish, Chinese, English)
    // ============================================================

    /*
      Generates random wrong answers for multiple choice mode.

      UPDATED ALGORITHM (Act-Wide Selection):
      Instead of pulling from just the current wordpack (50 words),
      we now pull from the ENTIRE ACT (all wordpacks, ~2,500 words).

      BENEFITS:
      âœ“ More variety (2,500 options vs 50)
      âœ“ Less predictable for players
      âœ“ Better for advanced learners
      âœ“ No additional performance cost (data already in memory)

      PROCESS:
      1. Collect all words from all packs in the current act
      2. Filter out the correct answer (exact match)
      3. Filter out normalized duplicates (case/space/symbol variations)
      4. Shuffle remaining pool using Fisher-Yates
      5. Take first K words as wrong answers (K=4 in this demo)

      EXAMPLE:
      - Act 1 has 50 packs with 50 words each = 2,500 total words
      - Current correct answer: "hola amigo"
      - Normalized: "holaamigo"
      - Filter out: "hola amigo", "Hola Amigo", "hola-amigo" (all normalize to same)
      - Remaining pool: ~2,499 words
      - Randomly select 4 from this pool

      DUPLICATE DETECTION:
      We use normalized string comparison to avoid showing essentially
      the same word with minor variations:
      - "hello" vs "Hello" (different case)
      - "hello friend" vs "hellofriend" (different spacing)
      - "hello!" vs "hello" (different punctuation)

      GAME USAGE:
      Different games need different numbers of wrong answers:
      - Temple Run (3-lane runner): Need 2 wrong answers (3 total choices)
      - Quiz game (4 options): Need 3 wrong answers (4 total choices)
      - This demo: 4 wrong answers to show extensibility

      This algorithm works for ANY language (Spanish, Chinese, English, etc.)
      because it always uses column 0 (target language) from the words array.

      INPUT:
        - actData: Dictionary of all wordpacks in the current act
        - correctAnswer: The correct answer string (to filter out)
        - count: Number of wrong answers to generate (default 4)

      OUTPUT:
        - Array of wrong answer strings from column 0 (target language)
    */
    function generateWrongAnswers(actData, correctAnswer, count = 4) {
      // STEP 1: Normalize the correct answer for comparison
      const normalizedCorrect = normalizeString(correctAnswer);

      // STEP 2: Collect all words from all packs in the act
      const allWords = [];

      // Loop through each pack in the act
      Object.keys(actData).forEach(packKey => {
        const pack = actData[packKey];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ARCHITECTURE: Combine baseWords + exampleWords with shuffling
        // This creates a single array with base words first, both sections shuffled
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const words = combineAndShuffleWords(pack);

        // Loop through each word in this pack
        words.forEach(wordObj => {
          const word = wordObj.word;  // Extract word array from object
          const targetLanguageWord = word[0];  // Column 0 is always target language

          // Filter out the correct answer and normalized duplicates
          if (targetLanguageWord !== correctAnswer) {
            const normalizedWord = normalizeString(targetLanguageWord);

            // Only add if normalized version is different from correct answer
            if (normalizedWord !== normalizedCorrect) {
              allWords.push(targetLanguageWord);
            }
          }
        });
      });

      // STEP 3: Shuffle using Fisher-Yates algorithm for uniform randomness
      for (let i = allWords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
      }

      // STEP 4: Take first 'count' words (or fewer if pool is small)
      const wrongAnswers = allWords.slice(0, Math.min(count, allWords.length));

      return wrongAnswers;
    }

    // ============================================================
    // CHINESE WRONG ANSWERS: Include Pinyin for Coupled Display
    // ============================================================

    /*
      generateWrongAnswersWithPinyin() - Generate wrong answers for Chinese with pinyin

      SAME ALGORITHM as generateWrongAnswers(), but returns objects with BOTH
      the Chinese text AND the pinyin. This enables proper coupled rendering.

      WHY A SEPARATE FUNCTION?
      - generateWrongAnswers() returns simple strings (for Spanish, English)
      - Chinese needs BOTH text AND pinyin for each wrong answer
      - We could modify the original, but keeping separate maintains clarity
      - DRY is preserved: this function uses same filtering/shuffling logic

      INPUT:
        - actData: Dictionary of all wordpacks in the current act
        - correctAnswer: The correct answer string (Chinese characters, to filter out)
        - count: Number of wrong answers to generate (default 4)

      OUTPUT:
        - Array of objects: [{ text: "å°çŒ«", pinyin: "xiÇo mÄo" }, ...]
        - Each object has both the Chinese text and its pinyin coupled together
        - This enables renderChineseText() to display with pinyin underneath

      EXAMPLE:
      INPUT:  generateWrongAnswersWithPinyin(actData, "å¤§ç‹—", 2)
      OUTPUT: [
        { text: "å°çŒ«", pinyin: "xiÇo mÄo" },
        { text: "è€è™", pinyin: "lÇo hÇ”" }
      ]
    */
    function generateWrongAnswersWithPinyin(actData, correctAnswer, count = 4) {
      // STEP 1: Normalize the correct answer for comparison
      const normalizedCorrect = normalizeString(correctAnswer);

      // STEP 2: Collect all words WITH PINYIN from all packs in the act
      const allWords = [];

      // Loop through each pack in the act
      Object.keys(actData).forEach(packKey => {
        const pack = actData[packKey];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ARCHITECTURE: Combine baseWords + exampleWords with shuffling
        // This creates a single array with base words first, both sections shuffled
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const words = combineAndShuffleWords(pack);

        // Loop through each word in this pack
        words.forEach(wordObj => {
          const word = wordObj.word;  // Extract word array from object
          const chineseText = word[0];  // Column 0 is Chinese characters
          const pinyinText = word[1];   // Column 1 is Pinyin

          // Filter out the correct answer and normalized duplicates
          if (chineseText !== correctAnswer) {
            const normalizedWord = normalizeString(chineseText);

            // Only add if normalized version is different from correct answer
            if (normalizedWord !== normalizedCorrect) {
              // Store BOTH text and pinyin as coupled object
              allWords.push({
                text: chineseText,
                pinyin: pinyinText
              });
            }
          }
        });
      });

      // STEP 3: Shuffle using Fisher-Yates algorithm for uniform randomness
      for (let i = allWords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
      }

      // STEP 4: Take first 'count' words (or fewer if pool is small)
      const wrongAnswers = allWords.slice(0, Math.min(count, allWords.length));

      return wrongAnswers;
    }

    // ============================================================
    // KEY FEATURE: Typing Practice (Character-by-Character Input)
    // Core Objective: Let users practice spelling with instant feedback
    // Key Behaviors:
    //   - Accent-insensitive comparison (Ã¡ = a, Ã± = n)
    //   - Auto-skip spaces
    //   - Track wrong letters with visual feedback
    //   - Satisfying click sound on every keypress
    //   - Per-row state (not global) - more modular than SimpleFlashCards
    // ============================================================

    /*
      Handles typing input for a specific word in the vocabulary table.
      This is the CORE TYPING MECHANIC that can be reused in any language game.

      TYPING ALGORITHM (IMPROVED over SimpleFlashCards.html):
      1. Get or initialize typing state for this word
      2. Find next position to type (first untyped non-space character)
      3. Normalize both the typed key and target character (remove accents, lowercase)
      4. Compare:
         - If match: Mark position as typed, play sound
         - If mismatch: Track wrong letter, increment counter, play sound
      5. Update the display (shows Xâ†’letter progressively)

      STATE MANAGEMENT (PER-ROW):
      Each word has its own typing state stored in state.typingStates Map:
      {
        typed: Set(),          // Set of character positions successfully typed
        wrongLetters: [],      // Array of wrong letters attempted
        wrongCount: 0          // Total wrong attempts
      }

      KEY IMPROVEMENTS OVER SimpleFlashCards.html:
      - Per-row state instead of global state (more modular)
      - Simpler state structure (easier to understand)
      - Inline in table (no separate card flipping)
      - Better for debugging/testing multiple words at once

      PARAMETERS:
      - wordIndex: Index of the word in the pack (used as state key)
      - correctWord: The correct answer string (target language)
      - key: The key that was pressed
      - inputElement: The input element to update

      RETURNS: Nothing (updates state and DOM directly)
    */
    function handleTypingInput(wordIndex, correctWord, key, inputElement) {
      // STEP 1: Get or create typing state for this word
      if (!state.typingStates.has(wordIndex)) {
        state.typingStates.set(wordIndex, {
          typed: new Set(),
          wrongLetters: [],
          wrongCount: 0
        });
      }

      const typingState = state.typingStates.get(wordIndex);
      const chars = correctWord.split('');

      // STEP 2: Find next unfilled position (skip already typed and spaces)
      let nextPos = 0;
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] === ' ') {
          typingState.typed.add(i);  // Auto-mark spaces as typed
          continue;
        }
        if (!typingState.typed.has(i)) {
          nextPos = i;
          break;
        }
        if (i === chars.length - 1) {
          // Already completed
          return;
        }
      }

      // STEP 3: Normalize characters for comparison (remove accents, lowercase)
      const normalizedKey = normalizeCharForTyping(key);
      const normalizedTarget = normalizeCharForTyping(chars[nextPos]);

      // STEP 4: Play sound for ANY keypress (instant feedback)
      playTypingSound();

      // STEP 5: Check if correct
      if (normalizedKey === normalizedTarget) {
        // CORRECT! Mark position as typed
        typingState.typed.add(nextPos);
      } else {
        // WRONG! Track the wrong letter and increment counter
        typingState.wrongLetters.push(key.toLowerCase());
        typingState.wrongCount++;
      }

      // STEP 6: Update display to show progress
      updateTypingDisplay(wordIndex, correctWord, inputElement);
    }

    // ============================================================
    // UPDATE TYPING DISPLAY: Show Progress in Input Box
    // ============================================================

    /*
      Updates the typing input box to show current progress.

      DISPLAY FORMAT:
      - Untyped characters: Shown as 'X'
      - Typed characters: Shown as actual letter
      - Spaces: Shown as space (auto-typed)

      EXAMPLE PROGRESSION for "hola amigo":
      Initial:  "XXXX XXXXX"
      After 'h': "hXXX XXXXX"
      After 'o': "hoXX XXXXX"
      After 'l': "holX XXXXX"
      After 'a': "hola XXXXX"
      After 'a': "hola aXXXX"
      ... etc ...
      Final:    "hola amigo"

      PARAMETERS:
      - wordIndex: Index of word (to get state)
      - correctWord: The correct answer
      - inputElement: The input element to update
    */
    function updateTypingDisplay(wordIndex, correctWord, inputElement) {
      const typingState = state.typingStates.get(wordIndex);
      if (!typingState) return;

      const chars = correctWord.split('');
      const display = chars.map((char, i) => {
        if (typingState.typed.has(i)) {
          return char;  // Show actual character if typed
        } else {
          return char === ' ' ? ' ' : 'X';  // Show X for untyped, preserve spaces
        }
      }).join('');

      inputElement.value = display;

      // Also update the wrong letters and count columns
      const row = inputElement.closest('tr');
      if (row) {
        const wrongLettersCell = row.cells[row.cells.length - 2];  // Second to last column
        const wrongCountCell = row.cells[row.cells.length - 1];     // Last column

        if (wrongLettersCell) {
          // Display wrong letters with strikethrough
          wrongLettersCell.innerHTML = typingState.wrongLetters
            .map(letter => `<del>${letter}</del>`)
            .join(' ');
        }

        if (wrongCountCell) {
          wrongCountCell.textContent = typingState.wrongCount;
        }
      }
    }

    // ============================================================
    // KEY FEATURE: Vocabulary Table Display (Multi-Mode)
    // Core Objective: Render vocabulary with optional practice modes
    // Key Behaviors:
    //   - Dynamic column count based on enabled modes
    //   - Supports: basic, multiple choice, typing, pronunciation
    //   - Modes can be combined (columns stack)
    //   - Headers update dynamically to match active modes
    // ============================================================

    /*
      Displays vocabulary for the selected wordpack.

      TABLE MODES:

      BASIC MODE (all modes off):
      - 2 columns: Target language (column 0) and Native language (selected)

      MULTIPLE CHOICE MODE (multipleChoiceMode = true):
      - 6 columns: Target language, Native language, + 4 wrong answers
      - Wrong answers are randomly selected from ALL packs in current act
      - Duplicate filtering applied (normalized string comparison)

      TYPING MODE (typingMode = true):
      - 5 columns: Target language, Native language, Typing input, Wrong letters, Wrong count
      - Interactive typing practice with instant feedback

      PRONUNCIATION MODE (pronunciationMode = true):
      - 4 columns: Target language, Native language, Record button, Score percentage
      - Speech recognition using Web Speech API
      - Levenshtein distance for fuzzy string matching

      MODES CAN BE COMBINED:
      - Multiple modes can be enabled simultaneously
      - Columns are added in order: base â†’ multiple choice â†’ typing â†’ pronunciation

      PROCESS:
      1. Get selected wordpack from state.loadedData
      2. Check which modes are enabled
      3. Update table headers accordingly
      4. Loop through words array
      5. For each word:
         - Display word[0] in column 1 (target language - correct answer)
         - Display word[nativeLanguageIndex] in column 2 (translation)
         - If multiple choice mode: Generate and display 4 wrong answers
         - If typing mode: Add typing input box and tracking columns
         - If pronunciation mode: Add record button and score columns
    */

    // ============================================================
    // DISPLAY ALL EDGE CASES: Master toggle showing all packs
    // ============================================================
    /*
      When "Show Edge Cases Only" is checked, this function displays ALL words
      containing Latin abbreviations from ALL wordpacks across ALL acts.

      PURPOSE:
      - Demonstrate edge case handling in validate_pinyin.py
      - Show real examples: ATM, DNA, WhatsApp, Tæ¤, la, los, etc.
      - Help users understand Latin block matching logic

      PROCESS:
      1. Iterate through all acts in state.loadedData
      2. Iterate through all packs in each act
      3. Extract all words from each pack
      4. Filter for words containing Latin characters
      5. Display with pack source information (Pack #: Title)
    */
    function displayAllEdgeCases() {
      const tableBody = document.getElementById('vocabularyTable');
      const packTitleEl = document.getElementById('packTitle');
      const tableHeaderRow = document.getElementById('tableHeaderRow');

      // Update title
      packTitleEl.textContent = `Edge Cases - All Packs (${state.currentLanguage})`;

      // Get language names
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const targetLanguage = config.columns[0];
      const nativeLanguage = config.columns[state.currentNativeLanguage];

      // Setup headers with Pack Source column
      const headers = [
        `<th>Pack Source</th>`,
        `<th>Word (${targetLanguage})</th>`,
        `<th>Translation (${nativeLanguage})</th>`
      ];
      tableHeaderRow.innerHTML = headers.join('\n');

      // Determine if we're learning Chinese or if native language is Chinese
      const isLearningChinese = state.currentLanguage === 'Chinese';
      const nativeConfig = LANGUAGE_CONFIG[state.currentLanguage];
      let nativeIsChinese = false;
      let nativePinyinColumn = null;

      if (nativeConfig && nativeConfig.nativeLanguages) {
        const entries = Object.entries(nativeConfig.nativeLanguages);
        for (const [name, colIndex] of entries) {
          if (colIndex === state.currentNativeLanguage && name.toLowerCase().includes('chinese')) {
            nativeIsChinese = true;
            const pinyinEntry = entries.find(([n]) => n.toLowerCase().includes('pinyin'));
            if (pinyinEntry) {
              nativePinyinColumn = pinyinEntry[1];
            }
            break;
          }
        }
      }

      // Helper: Check if word contains Latin characters
      function hasLatinCharacters(wordArray) {
        for (let i = 0; i < wordArray.length; i++) {
          const text = wordArray[i] || '';
          if (/[A-Za-z]/.test(text)) {
            return true;
          }
        }
        return false;
      }

      // Collect all edge case words from all packs
      let edgeCaseWords = [];

      // Iterate through all acts
      for (const actKey in state.loadedData) {
        const actData = state.loadedData[actKey];

        // Iterate through all packs in this act
        for (const packKey in actData) {
          const pack = actData[packKey];

          // Combine base and example words
          const allWords = [];
          if (pack.baseWords) {
            pack.baseWords.forEach(w => allWords.push({ word: w, type: 'Base' }));
          }
          if (pack.exampleWords) {
            pack.exampleWords.forEach(w => allWords.push({ word: w, type: 'Example' }));
          }

          // Filter for words with Latin characters
          allWords.forEach(wordObj => {
            if (hasLatinCharacters(wordObj.word)) {
              edgeCaseWords.push({
                word: wordObj.word,
                type: wordObj.type,
                packNumber: pack.meta.wordpack,
                packTitle: pack.meta.english || pack.meta.chinese || 'Untitled'
              });
            }
          });
        }
      }

      // Display results
      if (edgeCaseWords.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="3">No edge cases found in this language</td></tr>';
        return;
      }

      // Sort by pack number
      edgeCaseWords.sort((a, b) => a.packNumber - b.packNumber);

      // Render each edge case
      edgeCaseWords.forEach(item => {
        const row = document.createElement('tr');

        // Column 1: Pack Source
        const packSourceCell = document.createElement('td');
        packSourceCell.textContent = `Pack ${item.packNumber}: ${item.packTitle}`;
        packSourceCell.style.fontSize = '0.9em';
        packSourceCell.style.color = '#666';
        row.appendChild(packSourceCell);

        // Column 2: Target language word
        const targetCell = document.createElement('td');
        if (isLearningChinese) {
          const chineseText = item.word[0];
          const pinyinText = item.word[1];
          const renderedElement = renderChineseText(chineseText, pinyinText, true);
          targetCell.appendChild(renderedElement);
        } else {
          targetCell.textContent = item.word[0];
        }
        row.appendChild(targetCell);

        // Column 3: Native language translation
        const translationCell = document.createElement('td');
        if (nativeIsChinese && nativePinyinColumn !== null) {
          const chineseText = item.word[state.currentNativeLanguage];
          const pinyinText = item.word[nativePinyinColumn];
          const renderedElement = renderChineseText(chineseText, pinyinText, true);
          translationCell.appendChild(renderedElement);
        } else {
          translationCell.textContent = item.word[state.currentNativeLanguage];
        }
        row.appendChild(translationCell);

        tableBody.appendChild(row);
      });

      // Add summary at the bottom
      const summaryRow = document.createElement('tr');
      summaryRow.style.fontWeight = 'bold';
      summaryRow.style.backgroundColor = '#f0f0f0';
      summaryRow.innerHTML = `<td colspan="3">Total edge cases found: ${edgeCaseWords.length}</td>`;
      tableBody.appendChild(summaryRow);
    }

    // ============================================================
    // DISPLAY VOCABULARY: Show current pack or all edge cases
    // ============================================================
    /*
      Main display function for vocabulary table.

      MODES:
      - Normal mode: Display current selected pack
      - Edge case mode: Display all edge cases from all packs (calls displayAllEdgeCases())

      FEATURES:
      - Multiple choice mode: Generate 4 wrong answers from act-wide pool
      - Typing mode: Add typing input, wrong letter tracking, wrong count
      - Pronunciation mode: Record button for speech recognition
      - Chinese rendering: Character + pinyin coupling with visibility toggles

      KEY FUNCTIONS CALLED:
      - combineAndShuffleWords(): Merges base/example words with shuffling
      - generateWrongAnswers(): Creates wrong answers for multiple choice
      - renderChineseText(): Handles Chinese character + pinyin display
      - Levenshtein distance for fuzzy string matching

      MODES CAN BE COMBINED:
      - Multiple modes can be enabled simultaneously
      - Columns are added in order: base â†’ multiple choice â†’ typing â†’ pronunciation

      PROCESS:
      1. Get selected wordpack from state.loadedData
      2. Check which modes are enabled
      3. Update table headers accordingly
      4. Loop through words array
      5. For each word:
         - Display word[0] in column 1 (target language - correct answer)
         - Display word[nativeLanguageIndex] in column 2 (translation)
         - If multiple choice mode: Generate and display 4 wrong answers
         - If typing mode: Add typing input box and tracking columns
         - If pronunciation mode: Add record button and score columns
    */
    function displayVocabulary() {
      const tableBody = document.getElementById('vocabularyTable');
      const packTitleEl = document.getElementById('packTitle');
      const tableHeaderRow = document.getElementById('tableHeaderRow');

      // Clear table
      tableBody.innerHTML = '';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EDGE CASE MASTER TOGGLE: Show ALL edge cases from ALL packs
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const showEdgeCasesOnly = document.getElementById('showEdgeCasesOnly')?.checked || false;

      if (showEdgeCasesOnly) {
        // MASTER MODE: Collect all edge cases from all packs across all acts
        displayAllEdgeCases();
        return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NORMAL MODE: Show current pack only
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Calculate colspan based on active modes
      let totalColumns = 3;  // Base: target language + native language + word type
      if (state.multipleChoiceMode) totalColumns += 4;  // Add 4 wrong answer columns
      if (state.typingMode) totalColumns += 3;  // Add typing input + wrong letters + wrong count
      if (state.pronunciationMode) totalColumns += 2;  // Add record button + percentage score

      // Validate selection
      if (!state.currentAct || !state.currentPack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Please select an act and wordpack</td></tr>`;
        packTitleEl.textContent = 'No pack selected';
        return;
      }

      // Get wordpack data
      const actData = state.loadedData[state.currentAct];
      if (!actData) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Act data not loaded</td></tr>`;
        return;
      }

      const pack = actData[state.currentPack];
      if (!pack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Pack not found</td></tr>`;
        return;
      }

      // Update pack title
      packTitleEl.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;

      // Get language names
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const targetLanguage = config.columns[0];  // Column 0 is always target language
      const nativeLanguage = config.columns[state.currentNativeLanguage];

      // ============================================================
      // UPDATE TABLE HEADERS: Based on Mode
      // ============================================================
      /*
        Build headers dynamically based on enabled modes:
        - Base: Target language + Native language (2 columns)
        - Multiple Choice: + 4 wrong answer columns
        - Typing: + Typing input + Wrong letters + Wrong count (3 columns)
      */
      let headers = [];

      // Base columns (always present)
      if (state.multipleChoiceMode) {
        headers.push(`<th>Correct Answer (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.typingMode) {
        headers.push(`<th>Target Word (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.pronunciationMode) {
        headers.push(`<th>Say This (${targetLanguage})</th>`);
        headers.push(`<th>Meaning (${nativeLanguage})</th>`);
      } else {
        headers.push(`<th>I am learning (${targetLanguage})</th>`);
        headers.push(`<th>I speak (${nativeLanguage})</th>`);
      }

      // Word Type column (ALWAYS present - for debugging shuffling mechanism)
      headers.push('<th>Word Type</th>');

      // Multiple choice columns (if enabled)
      if (state.multipleChoiceMode) {
        headers.push('<th>Wrong Answer 1</th>');
        headers.push('<th>Wrong Answer 2</th>');
        headers.push('<th>Wrong Answer 3</th>');
        headers.push('<th>Wrong Answer 4</th>');
      }

      // Typing mode columns (if enabled)
      if (state.typingMode) {
        headers.push('<th>Type Here (X = letter)</th>');
        headers.push('<th>Wrong Letters</th>');
        headers.push('<th>Wrong Count</th>');
      }

      // Pronunciation mode columns (if enabled)
      if (state.pronunciationMode) {
        headers.push('<th>Record ğŸ¤</th>');
        headers.push('<th>Score %</th>');
      }

      tableHeaderRow.innerHTML = headers.join('\n');

      // ============================================================
      // POPULATE TABLE ROWS: Generate vocabulary with optional wrong answers
      // ============================================================

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CHINESE RENDERING SETUP
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Determine if we need Chinese character+pinyin rendering for:
      // 1. Target language column (when learning Chinese)
      // 2. Native language column (when translation is Chinese)
      //
      // COLUMN MAPPING FOR CHINESE:
      // - Column 0: Chinese characters (æ±‰å­—)
      // - Column 1: Pinyin
      // - Column 2+: Other translations (English, Spanish, etc.)
      //
      // COLUMN MAPPING FOR SPANISH/ENGLISH (when showing Chinese translation):
      // - Spanish: Column 2 = Chinese, Column 3 = Pinyin
      // - English: Check config for Chinese column indices
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const isLearningChinese = state.currentLanguage === 'Chinese';

      // Determine if native language column shows Chinese (needs coupling)
      const nativeConfig = LANGUAGE_CONFIG[state.currentLanguage];
      let nativeIsChinese = false;
      let nativePinyinColumn = null;
      if (nativeConfig && nativeConfig.nativeLanguages) {
        const entries = Object.entries(nativeConfig.nativeLanguages);
        for (const [name, colIndex] of entries) {
          if (colIndex === state.currentNativeLanguage && name.toLowerCase().includes('chinese')) {
            nativeIsChinese = true;
            // Find pinyin column (usually the next one)
            const pinyinEntry = entries.find(([n]) => n.toLowerCase().includes('pinyin'));
            if (pinyinEntry) {
              nativePinyinColumn = pinyinEntry[1];
            }
            break;
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ARCHITECTURE: Combine baseWords + exampleWords with shuffling
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // This creates a single array with base words first, both sections shuffled.
      // Educational Psychology: Learners see core vocabulary before contextual examples.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const words = combineAndShuffleWords(pack);

      words.forEach((wordObj, index) => {
        // Extract word array and type from the combined object
        const word = wordObj.word;      // Word array: ["spanish", "english", "chinese", ...]
        const wordType = wordObj.type;  // Either "Base Word" or "Example Word"

        const row = document.createElement('tr');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLUMN 1: Target language (correct answer, column 0 from words array)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHINESE RENDERING: When learning Chinese, render with pinyin underneath
        // For Chinese: word[0] = characters, word[1] = pinyin
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const cell1 = document.createElement('td');
        if (isLearningChinese) {
          // Chinese: Use coupled rendering (characters + pinyin)
          const chineseText = word[0];
          const pinyinText = word[1];  // For Chinese, column 1 is always pinyin
          const renderedElement = renderChineseText(chineseText, pinyinText, true);
          cell1.appendChild(renderedElement);
        } else {
          // Not Chinese: plain text
          cell1.textContent = word[0];
        }
        row.appendChild(cell1);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLUMN 2: Native language translation (selected column from words array)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHINESE RENDERING: When native language is Chinese, render with pinyin
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const cell2 = document.createElement('td');
        if (nativeIsChinese && nativePinyinColumn !== null) {
          // Native language is Chinese: Use coupled rendering
          const chineseText = word[state.currentNativeLanguage];
          const pinyinText = word[nativePinyinColumn];
          const renderedElement = renderChineseText(chineseText, pinyinText, true);
          cell2.appendChild(renderedElement);
        } else {
          // Not Chinese: plain text
          cell2.textContent = word[state.currentNativeLanguage];
        }
        row.appendChild(cell2);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLUMN 3: Word Type (Base Word or Example Word)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // For debugging purposes: Verify shuffling mechanism is working correctly
        // Base words should appear first, followed by example words
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const cell3 = document.createElement('td');
        cell3.textContent = wordType;
        cell3.style.fontWeight = wordType === "Base Word" ? "bold" : "normal";
        cell3.style.color = wordType === "Base Word" ? "#2563eb" : "#059669";  // Blue for base, green for examples
        row.appendChild(cell3);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLUMNS 4-7: Wrong answers (only in multiple choice mode)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHINESE RENDERING: When learning Chinese, wrong answers need pinyin too
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (state.multipleChoiceMode) {
          /*
            Generate 4 random wrong answers from ALL wordpacks in the current act.
            - Current correct answer: word[0] (target language, column 0)
            - Pool: All words from all packs in the current act (~2,500 words)
            - Filtering: Exclude correct answer and normalized duplicates
            - Each wrong answer is from column 0 (target language)

            CHINESE MODE: We also need the pinyin for each wrong answer.
            generateWrongAnswersWithPinyin() returns objects with {text, pinyin}.
          */
          const correctAnswer = word[0];
          let wrongAnswers;

          if (isLearningChinese) {
            // Chinese: Generate wrong answers WITH pinyin
            wrongAnswers = generateWrongAnswersWithPinyin(actData, correctAnswer, 4);
          } else {
            // Other languages: Simple text array
            wrongAnswers = generateWrongAnswers(actData, correctAnswer, 4);
          }

          // Add each wrong answer as a table cell
          wrongAnswers.forEach(wrongAnswer => {
            const wrongCell = document.createElement('td');
            if (isLearningChinese && wrongAnswer.pinyin !== undefined) {
              // Chinese: Render with pinyin
              const renderedElement = renderChineseText(wrongAnswer.text, wrongAnswer.pinyin, true);
              wrongCell.appendChild(renderedElement);
            } else if (typeof wrongAnswer === 'string') {
              // Non-Chinese: Plain text
              wrongCell.textContent = wrongAnswer;
            } else {
              // Fallback for object without pinyin
              wrongCell.textContent = wrongAnswer.text || wrongAnswer;
            }
            row.appendChild(wrongCell);
          });

          // Handle edge case: If act has fewer than 5 words total,
          // we might have fewer than 4 wrong answers. Fill remaining cells.
          const wrongAnswerCount = wrongAnswers.length;
          for (let i = wrongAnswerCount; i < 4; i++) {
            const emptyCell = document.createElement('td');
            emptyCell.textContent = '(Not enough words in act)';
            row.appendChild(emptyCell);
          }
        }

        // TYPING MODE COLUMNS: Input box + Wrong letters + Wrong count
        if (state.typingMode) {
          /*
            Add typing practice columns for this word:
            1. Typing input box (initialized with "XXXX XXXXX" format)
            2. Wrong letters column (displays struck-through wrong attempts)
            3. Wrong count column (displays total wrong attempts)

            KEY FEATURE: For Chinese, type PINYIN (word[1]) instead of characters (word[0])
            - Ignores spaces (like Spanish/English typing modes)
            - Accepts any variant of accented letters (Ä, Ã¡, Ç, Ã  -> a)
          */
          // For Chinese: use pinyin (word[1]); for other languages: use target word (word[0])
          const correctWord = (state.currentLanguage === 'Chinese') ? word[1] : word[0];

          // COLUMN: Typing input box
          const typingCell = document.createElement('td');
          const typingInput = document.createElement('input');
          typingInput.type = 'text';
          typingInput.readOnly = true;  // Prevent direct editing
          typingInput.style.width = '100%';
          typingInput.style.fontFamily = 'monospace';
          typingInput.style.fontSize = '1em';
          typingInput.style.padding = '4px';

          // Initialize display with X's for each letter (preserve spaces)
          const initialDisplay = correctWord.split('').map(char => char === ' ' ? ' ' : 'X').join('');
          typingInput.value = initialDisplay;

          // Add keypress listener to this specific input
          typingInput.addEventListener('keydown', (e) => {
            // Only handle single character keys (not arrow keys, backspace, etc.)
            if (e.key.length === 1) {
              e.preventDefault();  // Prevent default input behavior
              handleTypingInput(index, correctWord, e.key, typingInput);
            }
          });

          // Make input focusable by clicking
          typingInput.addEventListener('click', () => {
            typingInput.focus();
          });

          typingCell.appendChild(typingInput);
          row.appendChild(typingCell);

          // COLUMN: Wrong letters (initially empty)
          const wrongLettersCell = document.createElement('td');
          wrongLettersCell.style.fontFamily = 'monospace';
          row.appendChild(wrongLettersCell);

          // COLUMN: Wrong count (initially 0)
          const wrongCountCell = document.createElement('td');
          wrongCountCell.textContent = '0';
          wrongCountCell.style.textAlign = 'center';
          row.appendChild(wrongCountCell);
        }

        // PRONUNCIATION MODE COLUMNS: Record button + Score percentage
        if (state.pronunciationMode) {
          const correctWord = word[0];

          // COLUMN: Record button
          const recordCell = document.createElement('td');
          const recordButton = document.createElement('button');
          recordButton.textContent = 'ğŸ¤';
          recordButton.addEventListener('click', () => {
            startListeningForPronunciation(index, correctWord, recordButton);
          });
          recordCell.appendChild(recordButton);
          row.appendChild(recordCell);

          // COLUMN: Score percentage
          const scoreCell = document.createElement('td');
          const pronState = state.pronunciationStates.get(index);
          if (pronState && pronState.attempted) {
            scoreCell.textContent = `${pronState.score}%`;
            scoreCell.title = `Heard: "${pronState.heard}"`;
          } else {
            scoreCell.textContent = '-';
          }
          row.appendChild(scoreCell);
        }

        tableBody.appendChild(row);
      });

      // Update debug info with active modes
      let modeParts = [];
      if (state.multipleChoiceMode) modeParts.push('Multiple Choice (act-wide pool)');
      if (state.typingMode) modeParts.push('Typing Practice');
      if (state.pronunciationMode) modeParts.push('Pronunciation Practice');
      const modeText = modeParts.length > 0 ? modeParts.join(' + ') : 'Basic (2 columns)';

      // Count total words in act for debug info
      let totalActWords = 0;
      Object.keys(actData).forEach(packKey => {
        const packWords = combineAndShuffleWords(actData[packKey]);
        totalActWords += packWords.length;
      });

      updateDebugInfo(`Displaying Pack ${pack.meta.wordpack}: ${pack.meta.english}\n` +
                      `Words in this pack: ${words.length}\n` +
                      `Total words in Act ${state.currentAct}: ${totalActWords}\n` +
                      `Mode: ${modeText}\n` +
                      `Total columns: ${totalColumns}\n` +
                      `Target language: ${targetLanguage} (column 0)\n` +
                      `Native language: ${nativeLanguage} (column ${state.currentNativeLanguage})`);
    }

    // ============================================================
    // UPDATE DEBUG INFO: Display Technical Details
    // ============================================================

    /*
      Updates the debug information section with current state and messages.
      Useful for developers/LLMs to understand what's happening.

      INCLUDES: localStorage status to help debug state persistence.
    */
    function updateDebugInfo(message) {
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toLocaleTimeString();

      // Check localStorage status
      let localStorageStatus = 'Unknown';
      let savedStatePreview = 'None';
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          localStorageStatus = 'Available (has saved state)';
          const parsed = JSON.parse(saved);
          savedStatePreview = `Language: ${parsed.currentLanguage}, Act: ${parsed.currentAct}, Pack: ${parsed.currentPack ? parsed.currentPack.substring(0, 20) + '...' : 'None'}`;
        } else {
          localStorageStatus = 'Available (no saved state)';
        }
      } catch (e) {
        localStorageStatus = `Error: ${e.message}`;
      }

      debugInfo.textContent = `[${timestamp}] ${message}\n\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `CURRENT STATE (in memory):\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `- Language: ${state.currentLanguage}\n` +
        `- Act: ${state.currentAct || 'None'}\n` +
        `- Pack: ${state.currentPack || 'None'}\n` +
        `- Native Language Column: ${state.currentNativeLanguage}\n` +
        `- Multiple Choice Mode: ${state.multipleChoiceMode ? 'Enabled' : 'Disabled'}\n` +
        `- Typing Mode: ${state.typingMode ? 'Enabled' : 'Disabled'}\n` +
        `- Pronunciation Mode: ${state.pronunciationMode ? 'Enabled' : 'Disabled'}\n` +
        `- Flashcard Mode: ${state.flashcardMode ? 'Enabled' : 'Disabled'}\n` +
        `- Active Typing States: ${state.typingStates.size}\n` +
        `- Active Pronunciation States: ${state.pronunciationStates.size}\n` +
        `- Flashcard Deck Size: ${state.flashcardDeck.length} cards\n` +
        `\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `PERSISTENCE (localStorage):\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `- Storage Key: ${STORAGE_KEY}\n` +
        `- Status: ${localStorageStatus}\n` +
        `- Saved: ${savedStatePreview}\n` +
        `\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `SYSTEM:\n` +
        `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
        `- Speech Recognition: ${recognition ? 'Available' : 'Not Available'}\n` +
        `- Loaded Acts: ${Object.keys(state.loadedData).join(', ') || 'None'}`;
    }

    // ============================================================
    // KEY FEATURE: Flashcard Mode (Anti-Decoupling Demonstration)
    // Core Objective: Teach the CRITICAL principle that front/back
    //                 must ALWAYS be stored as ONE object, never separate arrays
    // Key Behaviors:
    //   - Each card is { front, back, id } - properties of SAME object
    //   - Flipping shows the OTHER property of the SAME card
    //   - Shuffling reorders cards[] but NEVER breaks front/back link
    //   - Navigation changes currentIndex but card[i] is always intact
    // ============================================================

    /*
      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      â•‘                    ANTI-DECOUPLING PRINCIPLE                                 â•‘
      â•‘                    (THE MOST IMPORTANT CONCEPT)                              â•‘
      â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
      â•‘                                                                              â•‘
      â•‘  âŒ THE BUG-PRONE WAY (Decoupled - DO NOT DO THIS):                          â•‘
      â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â•‘
      â•‘  const fronts = ["hola", "adiÃ³s", "gracias"];                                â•‘
      â•‘  const backs  = ["hello", "goodbye", "thank you"];                           â•‘
      â•‘  let currentIndex = 0;                                                       â•‘
      â•‘                                                                              â•‘
      â•‘  function showFront() { display(fronts[currentIndex]); }                     â•‘
      â•‘  function showBack()  { display(backs[currentIndex]); }                      â•‘
      â•‘                                                                              â•‘
      â•‘  // PROBLEM: If fronts and backs get out of sync (different lengths,         â•‘
      â•‘  // different order after separate operations), flipping shows WRONG answer! â•‘
      â•‘  // This is a VERY common bug in flashcard apps.                             â•‘
      â•‘                                                                              â•‘
      â•‘  âœ… THE CORRECT WAY (Anti-Decoupled - ALWAYS DO THIS):                       â•‘
      â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â•‘
      â•‘  const cards = [                                                             â•‘
      â•‘    { front: "hola",    back: "hello" },                                      â•‘
      â•‘    { front: "adiÃ³s",   back: "goodbye" },                                    â•‘
      â•‘    { front: "gracias", back: "thank you" }                                   â•‘
      â•‘  ];                                                                          â•‘
      â•‘  let currentIndex = 0;                                                       â•‘
      â•‘                                                                              â•‘
      â•‘  function showFront() { display(cards[currentIndex].front); }                â•‘
      â•‘  function showBack()  { display(cards[currentIndex].back); }                 â•‘
      â•‘                                                                              â•‘
      â•‘  // BENEFIT: cards[i].front and cards[i].back are ALWAYS the same card!      â•‘
      â•‘  // They are properties of ONE object - they CANNOT get out of sync.         â•‘
      â•‘  // Shuffling reorders the cards[] array but each card stays intact.         â•‘
      â•‘                                                                              â•‘
      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    */

    /*
      handleFlashcardModeChange() - Called when flashcard checkbox is toggled
      Shows/hides the flashcard area and initializes deck if enabling
    */
    function handleFlashcardModeChange(enabled) {
      const flashcardArea = document.getElementById('flashcardArea');
      if (!flashcardArea) return;

      flashcardArea.style.display = enabled ? 'block' : 'none';

      if (enabled) {
        // Initialize flashcard deck from current wordpack
        initFlashcardDeck();
        updateFlashcardDisplay();
      }
    }

    /*
      initFlashcardDeck() - Creates the ANTI-DECOUPLED card array

      CRITICAL IMPLEMENTATION DETAIL:
      Each card is ONE OBJECT containing BOTH front and back.
      We NEVER store fronts and backs in separate arrays.

      CHINESE SUPPORT:
      When learning Chinese, we also store pinyin for the front (target language).
      This enables coupled character+pinyin rendering on the flashcard.

      INPUT: Uses state.currentPack to get words from current wordpack
      OUTPUT: Populates state.flashcardDeck with card objects
    */
    function initFlashcardDeck() {
      // Reset state
      state.flashcardDeck = [];
      state.flashcardIndex = 0;
      state.flashcardShowingFront = true;

      // Get current pack data
      if (!state.currentAct || !state.currentPack) return;
      const actData = state.loadedData[state.currentAct];
      if (!actData) return;
      const pack = actData[state.currentPack];
      if (!pack) return;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ARCHITECTURE: Combine baseWords + exampleWords with shuffling
      // This creates a single array with base words first, both sections shuffled
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const words = combineAndShuffleWords(pack);
      if (words.length === 0) return;

      // Get native language column index
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const nativeIndex = state.currentNativeLanguage;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CHINESE RENDERING SETUP FOR FLASHCARDS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const isLearningChinese = state.currentLanguage === 'Chinese';

      // Check if native language is Chinese (for back of card)
      let nativeIsChinese = false;
      let nativePinyinColumn = null;
      if (config && config.nativeLanguages) {
        const entries = Object.entries(config.nativeLanguages);
        for (const [name, colIndex] of entries) {
          if (colIndex === nativeIndex && name.toLowerCase().includes('chinese')) {
            nativeIsChinese = true;
            const pinyinEntry = entries.find(([n]) => n.toLowerCase().includes('pinyin'));
            if (pinyinEntry) nativePinyinColumn = pinyinEntry[1];
            break;
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ANTI-DECOUPLING: Create cards as SINGLE OBJECTS with front AND back
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Each card object contains BOTH the front (target language) and back
      // (native language translation). These are NEVER stored separately.
      // This is the KEY PRINCIPLE that prevents flip-mismatch bugs.
      //
      // CHINESE ADDITION: Also store pinyin for Chinese text to enable
      // coupled rendering (characters + pinyin together).
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      state.flashcardDeck = words.map((wordObj, index) => {
        const word = wordObj.word;  // Extract word array from object
        const type = wordObj.type;  // Extract type: "Base Word" or "Example Word"

        const card = {
          id: `card-${index}`,           // Unique identifier for this card
          front: word[0],                 // Target language (column 0) - FRONT of card
          back: word[nativeIndex],        // Native language translation - BACK of card
          type: type,                     // Word type for debugging shuffling mechanism
          // â†‘ NOTICE: front and back are PROPERTIES OF THE SAME OBJECT
          // They are linked forever. Shuffling moves the whole object.
        };

        // Add pinyin for Chinese front (when learning Chinese)
        if (isLearningChinese) {
          card.frontPinyin = word[1];  // Column 1 is pinyin for Chinese
          card.frontIsChinese = true;
        }

        // Add pinyin for Chinese back (when translation is Chinese)
        if (nativeIsChinese && nativePinyinColumn !== null) {
          card.backPinyin = word[nativePinyinColumn];
          card.backIsChinese = true;
        }

        return card;
      });

      console.log(`Initialized flashcard deck with ${state.flashcardDeck.length} cards (anti-decoupled)`);
    }

    /*
      updateFlashcardDisplay() - Updates the UI to show current card

      This function demonstrates that we ALWAYS access front and back
      from the SAME card object: cards[currentIndex].front or .back

      CHINESE SUPPORT:
      When front or back is Chinese, renders with pinyin underneath each character
      using the renderChineseText() function for coupled display.
    */
    function updateFlashcardDisplay() {
      const contentEl = document.getElementById('flashcardContent');
      const sideEl = document.getElementById('flashcardSide');
      const counterEl = document.getElementById('flashcardCounter');
      const debugEl = document.getElementById('flashcardDebug');

      if (!contentEl || state.flashcardDeck.length === 0) {
        if (contentEl) contentEl.textContent = 'No cards loaded. Select a wordpack first.';
        if (sideEl) sideEl.textContent = '';
        if (counterEl) counterEl.textContent = 'Card 0 of 0';
        return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ANTI-DECOUPLING IN ACTION: Access the SAME card object for both sides
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const currentCard = state.flashcardDeck[state.flashcardIndex];
      // â†‘ This is ONE object. currentCard.front and currentCard.back are ALWAYS
      //   the correct pair because they're properties of the SAME object.

      // Clear previous content
      contentEl.innerHTML = '';

      // Show front or back based on current side
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CHINESE RENDERING: Use coupled char+pinyin display when applicable
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (state.flashcardShowingFront) {
        // FRONT of card (target language)
        if (currentCard.frontIsChinese) {
          // Chinese: Use coupled rendering with pinyin
          const renderedElement = renderChineseText(currentCard.front, currentCard.frontPinyin, true);
          // Make flashcard content larger for better visibility
          renderedElement.style.fontSize = '2em';
          contentEl.appendChild(renderedElement);
        } else {
          // Non-Chinese: Plain text
          contentEl.textContent = currentCard.front;
        }
        sideEl.textContent = '(FRONT - Target Language) - click to see translation';
      } else {
        // BACK of card (translation/native language)
        if (currentCard.backIsChinese) {
          // Chinese translation: Use coupled rendering with pinyin
          const renderedElement = renderChineseText(currentCard.back, currentCard.backPinyin, true);
          renderedElement.style.fontSize = '2em';
          contentEl.appendChild(renderedElement);
        } else {
          // Non-Chinese: Plain text
          contentEl.textContent = currentCard.back;
        }
        sideEl.textContent = '(BACK - Translation) - click to flip back';
      }

      // Update counter with word type for debugging
      if (counterEl) {
        const typeColor = currentCard.type === "Base Word" ? "#2563eb" : "#059669";
        const typeWeight = currentCard.type === "Base Word" ? "bold" : "normal";
        counterEl.innerHTML = `Card ${state.flashcardIndex + 1} of ${state.flashcardDeck.length} | <span style="color: ${typeColor}; font-weight: ${typeWeight};">${currentCard.type}</span>`;
      }

      // Update debug view - show the ACTUAL card object structure
      if (debugEl) {
        debugEl.textContent = `// Current card object (index ${state.flashcardIndex}):
const currentCard = ${JSON.stringify(currentCard, null, 2)};

// Accessing front: currentCard.front = "${currentCard.front}"
// Accessing back:  currentCard.back  = "${currentCard.back}"
${currentCard.frontIsChinese ? `// frontPinyin: "${currentCard.frontPinyin}" (Chinese coupled rendering)` : ''}
${currentCard.backIsChinese ? `// backPinyin: "${currentCard.backPinyin}" (Chinese coupled rendering)` : ''}

// â†‘ NOTICE: Both come from the SAME object!
// They are LINKED - they cannot get out of sync.

// The deck is an array of these objects:
// state.flashcardDeck = [
//   { id: "card-0", front: "...", back: "...", frontPinyin?: "...", ... },
//   { id: "card-1", front: "...", back: "...", ... },
//   ...
// ]`;
      }
    }

    /*
      flipCard() - Toggle between front and back of CURRENT card

      ANTI-DECOUPLING BENEFIT:
      We're just changing which PROPERTY of the same object to display.
      The front and back are ALWAYS correct because they're on the same object.
    */
    function flipCard() {
      if (state.flashcardDeck.length === 0) return;

      state.flashcardShowingFront = !state.flashcardShowingFront;
      updateFlashcardDisplay();
    }
    // Expose to window for onclick handlers
    window.flipCard = flipCard;

    /*
      nextCard() - Move to next card in deck
    */
    function nextCard() {
      if (state.flashcardDeck.length === 0) return;

      state.flashcardIndex = (state.flashcardIndex + 1) % state.flashcardDeck.length;
      state.flashcardShowingFront = true;  // Always show front when navigating
      updateFlashcardDisplay();
    }
    window.nextCard = nextCard;

    /*
      prevCard() - Move to previous card in deck
    */
    function prevCard() {
      if (state.flashcardDeck.length === 0) return;

      state.flashcardIndex = (state.flashcardIndex - 1 + state.flashcardDeck.length) % state.flashcardDeck.length;
      state.flashcardShowingFront = true;
      updateFlashcardDisplay();
    }
    window.prevCard = prevCard;

    /*
      shuffleDeck() - Randomly reorder the cards using Fisher-Yates algorithm

      ANTI-DECOUPLING BENEFIT:
      When we shuffle, we're moving ENTIRE card objects, not just fronts or backs.
      Each card's front and back stay linked because they're properties of
      the same object that moves together.

      âŒ With decoupled arrays, you'd have to shuffle both arrays identically
         (same random seed, same swaps) - easy to get wrong!

      âœ… With anti-decoupled objects, shuffle just works - the whole card moves.
    */
    function shuffleDeck() {
      if (state.flashcardDeck.length === 0) return;

      // Fisher-Yates shuffle - moves ENTIRE card objects
      for (let i = state.flashcardDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        // Swap entire card objects - front and back stay linked!
        [state.flashcardDeck[i], state.flashcardDeck[j]] =
        [state.flashcardDeck[j], state.flashcardDeck[i]];
      }

      // Reset to first card
      state.flashcardIndex = 0;
      state.flashcardShowingFront = true;
      updateFlashcardDisplay();

      console.log('Deck shuffled. Cards reordered but front/back links preserved (anti-decoupling).');
    }
    window.shuffleDeck = shuffleDeck;

    // ============================================================
    // AUTO-RUN ON PAGE LOAD
    // ============================================================

    /*
      Automatically initialize when DOM is ready.
      This removes the need for a "Run Test" button.
    */
    window.addEventListener('DOMContentLoaded', initialize);

  </script>

</body>
</html>
