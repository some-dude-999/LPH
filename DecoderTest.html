<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wordpack Data Structure Debugger</title>

  <!--
    ============================================================
    PAKO.JS DEPENDENCY - Required for decompressing obfuscated modules
    ============================================================
    Our obfuscated modules use zlib compression (via pako library).
    This CDN script provides the pako.inflate() function for decompression.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>

  <!--
    ============================================================
    WORDPACK DATA STRUCTURE DEBUGGER
    ============================================================

    PURPOSE:
    This document serves as a technical reference and debugging tool for our
    language learning game's wordpack data structure. It demonstrates how to:
    - Load obfuscated JavaScript modules containing wordpack data
    - Extract and display vocabulary for language learning
    - Navigate through acts and packs
    - Map columns to different languages

    TARGET LANGUAGES WE TEACH:
    - Spanish (7 acts, 5 column structure)
    - Chinese (5 acts, 12 column structure)
    - English (5 acts, 5 column structure)

    DATA STRUCTURE OVERVIEW:
    Each language has multiple "acts" (learning stages), and each act contains
    multiple "wordpacks" (vocabulary sets).

    OBFUSCATED MODULE STRUCTURE:
    Each module exports a dictionary of wordpacks with this structure:

    {
      "p{act}_{pack}_{name}": {
        "meta": {
          "wordpack": 1,                    // Pack number (integer)
          "english": "Greetings & Goodbyes", // Pack title in English
          "chinese": "é—®å€™è¯­",                // Pack title in Chinese
          "spanish": "Saludos y Despedidas", // Pack title in Spanish
          ... // Other language translations as supported
        },
        "words": [
          ["word1_col1", "word1_col2", "word1_col3", ...],  // Each word is an array
          ["word2_col1", "word2_col2", "word2_col3", ...],
          ["word3_col1", "word3_col2", "word3_col3", ...]
        ]
      },
      "p{act}_{pack}_{name}": { ... },
      ...
    }

    COLUMN MAPPING BY LANGUAGE:
    The words array contains arrays where each index maps to a specific language:

    SPANISH (5 columns):
      [0] = Spanish (language being learned)
      [1] = English
      [2] = Chinese
      [3] = Pinyin
      [4] = Portuguese

    CHINESE (12 columns):
      [0] = Chinese (language being learned)
      [1] = Pinyin
      [2] = English
      [3] = Spanish
      [4] = French
      [5] = Portuguese
      [6] = Vietnamese
      [7] = Thai
      [8] = Khmer
      [9] = Indonesian
      [10] = Malay
      [11] = Filipino

    ENGLISH (5 columns):
      [0] = English (language being learned)
      [1] = Chinese
      [2] = Pinyin
      [3] = Spanish
      [4] = Portuguese

    HOW TO USE THIS DATA IN A GAME:
    1. Import the obfuscated module using decodeObfuscatedModule()
    2. Select a wordpack from the returned dictionary
    3. Access wordpack.meta for pack information
    4. Access wordpack.words for the vocabulary array
    5. Each word is wordpack.words[i], where i is the word index
    6. Each column is wordpack.words[i][columnIndex]
    7. Column 0 is always the language being learned
    8. Other columns provide translations in various languages

    ============================================================
  -->

  <h1>Wordpack Data Structure Debugger</h1>
  <p>Technical reference for language learning game data architecture</p>

  <hr>

  <!--
    ============================================================
    LANGUAGE SELECTION - Radio Buttons
    ============================================================
    Choose which target language's wordpacks to load.
    Default: Spanish
  -->
  <h2>1. Select Target Language</h2>
  <p>Which language are you learning?</p>
  <label>
    <input type="radio" name="language" value="Spanish" checked>
    Spanish
  </label>
  <label>
    <input type="radio" name="language" value="Chinese">
    Chinese
  </label>
  <label>
    <input type="radio" name="language" value="English">
    English
  </label>

  <hr>

  <!--
    ============================================================
    ACT SELECTION - Dropdown
    ============================================================
    Acts are learning stages. Each language has different numbers of acts:
    - Spanish: 7 acts
    - Chinese: 5 acts
    - English: 5 acts
  -->
  <h2>2. Select Act (Learning Stage)</h2>
  <p>Acts are grouped learning stages containing multiple wordpacks.</p>
  <select id="actSelect">
  </select>

  <hr>

  <!--
    ============================================================
    WORDPACK SELECTION - Dropdown
    ============================================================
    Each act contains multiple wordpacks (vocabulary sets).
    This dropdown populates based on the selected act.
  -->
  <h2>3. Select Wordpack</h2>
  <p>Individual vocabulary set within the selected act.</p>
  <select id="packSelect">
  </select>

  <hr>

  <!--
    ============================================================
    NATIVE LANGUAGE SELECTION - "I Speak" Dropdown
    ============================================================
    This determines which column to display in the right column of the table.
    Column 0 (left) is always the target language being learned.
    Column N (right) is the native language the user speaks.

    Available options depend on the target language's column structure.
  -->
  <h2>4. Select Your Native Language (I Speak)</h2>
  <p>Which language do you speak? This determines the translation column shown.</p>
  <select id="nativeLanguageSelect">
  </select>

  <hr>

  <!--
    ============================================================
    VOCABULARY TABLE - With Optional Multiple Choice Mode
    ============================================================
    Displays the selected wordpack's vocabulary.

    BASIC MODE (Default):
    - 2 columns: Target language (column 0) and Native language (selected)

    MULTIPLE CHOICE MODE (Checkbox enabled):
    - 6 columns total:
      1. Target language (correct answer, column 0)
      2. Native language translation (column N)
      3-6. Four wrong answers (randomly selected from ENTIRE ACT, ~2,500 words)

    WRONG ANSWER POOL:
    Wrong answers are now pulled from ALL wordpacks in the current act,
    not just the current wordpack. This provides:
    - Greater variety (2,500 options vs 50)
    - Less predictable patterns
    - Better simulation of real game mechanics
    - Zero performance cost (all data already loaded in memory)

    DUPLICATE FILTERING:
    Uses normalized string comparison (lowercase, no spaces/symbols)
    to avoid showing essentially identical words:
    - "hola" vs "Hola" (case difference) - filtered
    - "hello friend" vs "hellofriend" (spacing) - filtered
    - "hello!" vs "hello" (punctuation) - filtered

    This demonstrates the CORE LOGIC for generating multiple choice questions
    used in language learning games. Different game mechanics require different
    numbers of choices:
    - Temple Run style: 3 choices (1 correct + 2 wrong)
    - Quiz games: 4 choices (1 correct + 3 wrong)
    - This demo: 6 choices (1 correct + 4 wrong) to show extensibility

    The algorithm works for ANY target language (Spanish, Chinese, English, etc.)
    and ANY future language packs we add to the system.
  -->
  <h2>5. Vocabulary Table</h2>
  <p><strong>Pack Title:</strong> <span id="packTitle">Select a wordpack to view</span></p>

  <!--
    MULTIPLE CHOICE MODE CHECKBOX
    When enabled, adds 4 columns of wrong answers randomly selected from
    ALL wordpacks in the current act (~2,500 words). This shows how game
    mechanics generate distractors with variety and duplicate filtering.
  -->
  <p>
    <label>
      <input type="checkbox" id="multipleChoiceMode">
      Multiple Choice Mode (adds 4 wrong answer columns from entire act - game mechanics demo)
    </label>
  </p>

  <!--
    TYPING MODE CHECKBOX
    When enabled, adds 3 columns for interactive typing practice:
    - Column 3: Typing input box with masked placeholders (X for each letter)
    - Column 4: Wrong letters attempted (crossed out display)
    - Column 5: Wrong attempt count

    This demonstrates the CORE TYPING MECHANIC used in language learning games
    like SimpleFlashCards.html. The mechanic includes:
    - Character-by-character input validation
    - Accent-insensitive comparison (Ã¡ = a, Ã± = n, etc.)
    - Case-insensitive matching
    - Satisfying typing sound on every keypress (correct or wrong)
    - Automatic space handling (spaces ignored, auto-advanced)
    - Wrong letter tracking for feedback

    IMPROVEMENTS OVER SimpleFlashCards.html:
    - Simpler state management (per-row instead of global)
    - More modular code structure (easier to copy to other games)
    - Cleaner normalization logic
    - Better commented for human/LLM understanding
  -->
  <p>
    <label>
      <input type="checkbox" id="typingMode">
      Typing Mode (adds typing practice columns - game mechanics demo)
    </label>
  </p>

  <!--
    PRONUNCIATION MODE CHECKBOX
    When enabled, adds 2 columns for speech recognition practice:
    - Column 3: Record button (ðŸŽ¤) to capture user's pronunciation
    - Column 4: Percentage correct (similarity score using Levenshtein distance)

    CORE LOGIC:
    - Web Speech API for speech recognition
    - Levenshtein distance for fuzzy string matching
    - Language-specific recognition (es-ES, zh-CN, en-US)
    - Works best in Chrome/Edge browsers
  -->
  <p>
    <label>
      <input type="checkbox" id="pronunciationMode">
      Pronunciation Mode (adds record button and accuracy percentage - speech recognition demo)
    </label>
  </p>

  <table border="1" cellpadding="8" cellspacing="0">
    <thead>
      <tr id="tableHeaderRow">
        <th id="col1Header">I am learning</th>
        <th id="col2Header">I speak</th>
      </tr>
    </thead>
    <tbody id="vocabularyTable">
      <tr>
        <td colspan="2">Loading data...</td>
      </tr>
    </tbody>
  </table>

  <hr>

  <!--
    ============================================================
    DEBUG INFORMATION
    ============================================================
    Shows technical details about loaded data for debugging purposes.
  -->
  <h2>6. Debug Information</h2>
  <pre id="debugInfo">Initializing...</pre>

  <!--
    ============================================================
    JAVASCRIPT MODULE - Main Logic
    ============================================================
    This section contains all the JavaScript logic for:
    1. Decoding obfuscated modules (3-layer: base64 + zlib + string reversal)
    2. Loading language data automatically on page load
    3. Populating dropdowns dynamically
    4. Displaying vocabulary in 2-column table
    5. Handling user interactions (language/act/pack/native language changes)
  -->
  <script type="module">

    // ============================================================
    // CONFIGURATION: Language Module Paths and Column Structures
    // ============================================================

    /*
      This configuration maps each target language to:
      1. Module file paths (obfuscated .js files for each act)
      2. Column structure (what each column index represents)
      3. Available native languages (for "I speak" dropdown)
    */
    const LANGUAGE_CONFIG = {
      'Spanish': {
        modules: [
          { act: 1, name: 'Foundation', path: './SpanishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './SpanishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Daily Life', path: './SpanishWords/Jsmodules-js/act3-daily-life-js.js' },
          { act: 4, name: 'Expanding Expression', path: './SpanishWords/Jsmodules-js/act4-expanding-expression-js.js' },
          { act: 5, name: 'Intermediate Mastery', path: './SpanishWords/Jsmodules-js/act5-intermediate-mastery-js.js' },
          { act: 6, name: 'Advanced Constructs', path: './SpanishWords/Jsmodules-js/act6-advanced-constructs-js.js' },
          { act: 7, name: 'Mastery Fluency', path: './SpanishWords/Jsmodules-js/act7-mastery-fluency-js.js' }
        ],
        columns: ['Spanish', 'English', 'Chinese', 'Pinyin', 'Portuguese'],
        nativeLanguages: {
          'English': 1,
          'Chinese': 2,
          'Pinyin': 3,
          'Portuguese': 4
        }
      },
      'Chinese': {
        modules: [
          { act: 1, name: 'Foundation', path: './ChineseWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Development', path: './ChineseWords/Jsmodules-js/act2-development-js.js' },
          { act: 3, name: 'Expansion', path: './ChineseWords/Jsmodules-js/act3-expansion-js.js' },
          { act: 4, name: 'Mastery', path: './ChineseWords/Jsmodules-js/act4-mastery-js.js' },
          { act: 5, name: 'Refinement', path: './ChineseWords/Jsmodules-js/act5-refinement-js.js' }
        ],
        columns: ['Chinese', 'Pinyin', 'English', 'Spanish', 'French', 'Portuguese', 'Vietnamese', 'Thai', 'Khmer', 'Indonesian', 'Malay', 'Filipino'],
        nativeLanguages: {
          'English': 2,
          'Spanish': 3,
          'French': 4,
          'Portuguese': 5,
          'Vietnamese': 6,
          'Thai': 7,
          'Khmer': 8,
          'Indonesian': 9,
          'Malay': 10,
          'Filipino': 11
        }
      },
      'English': {
        modules: [
          { act: 1, name: 'Foundation', path: './EnglishWords/Jsmodules-js/act1-foundation-js.js' },
          { act: 2, name: 'Building Blocks', path: './EnglishWords/Jsmodules-js/act2-building-blocks-js.js' },
          { act: 3, name: 'Everyday Life', path: './EnglishWords/Jsmodules-js/act3-everyday-life-js.js' },
          { act: 4, name: 'Expanding Horizons', path: './EnglishWords/Jsmodules-js/act4-expanding-horizons-js.js' },
          { act: 5, name: 'Advanced Mastery', path: './EnglishWords/Jsmodules-js/act5-advanced-mastery-js.js' }
        ],
        columns: ['English', 'Chinese', 'Pinyin', 'Spanish', 'Portuguese'],
        nativeLanguages: {
          'Chinese': 1,
          'Pinyin': 2,
          'Spanish': 3,
          'Portuguese': 4
        }
      }
    };

    // ============================================================
    // KEY FEATURE: Global State Management
    // Core Objective: Single source of truth for all UI state
    // Key Behaviors:
    //   - Tracks current language, act, pack selections
    //   - Tracks mode toggles (multiple choice, typing, pronunciation)
    //   - Per-word state for interactive modes (typing progress, scores)
    // ============================================================

    /*
      Global state object tracks:
      - currentLanguage: Which target language is selected
      - loadedData: Dictionary mapping act numbers to decoded wordpack data
      - currentAct: Currently selected act number
      - currentPack: Currently selected wordpack key
      - currentNativeLanguage: Column index for native language
      - multipleChoiceMode: Boolean flag for showing wrong answer columns
      - typingMode: Boolean flag for showing typing practice columns
      - typingStates: Map tracking typing state for each word (wordIndex -> state object)
      - pronunciationMode: Boolean flag for showing pronunciation practice columns
      - pronunciationStates: Map tracking pronunciation state for each word (wordIndex -> { score, heard, attempted })
    */
    let state = {
      currentLanguage: 'Spanish',  // Default language
      loadedData: {},               // { actNumber: { packKey: {meta, words}, ... } }
      currentAct: null,
      currentPack: null,
      currentNativeLanguage: 1,     // Default to English column (index 1 for Spanish)
      multipleChoiceMode: false,    // Default to basic 2-column mode
      typingMode: false,            // Default to typing mode off
      typingStates: new Map(),      // Per-word typing state { typed: Set(), wrongLetters: [], wrongCount: 0 }
      pronunciationMode: false,     // Default to pronunciation mode off
      pronunciationStates: new Map() // Per-word pronunciation state { score: null, heard: '', attempted: false }
    };

    // ============================================================
    // SPEECH RECOGNITION SETUP
    // ============================================================

    /*
      Web Speech API setup for pronunciation recognition.

      BROWSER SUPPORT:
      - Chrome: Full support (webkitSpeechRecognition)
      - Edge: Full support (SpeechRecognition)
      - Firefox: Partial support
      - Safari: Limited support

      CONFIGURATION:
      - continuous: false (single utterance recognition)
      - interimResults: false (only final results)
      - maxAlternatives: 5 (check multiple interpretations for best match)
      - lang: Dynamic based on target language
    */
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;
    let currentListeningWordIndex = null;  // Track which word is being recorded

    // Language code mapping for speech recognition
    const SPEECH_LANG_CODES = {
      'Spanish': 'es-ES',
      'Chinese': 'zh-CN',
      'English': 'en-US'
    };

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.maxAlternatives = 5;
      // Language will be set dynamically based on currentLanguage
    }

    // ============================================================
    // KEY FEATURE: Module Decoding (3-Layer Obfuscation)
    // Core Objective: Load and decode compressed wordpack data
    // Key Behaviors:
    //   - Base64 decode â†’ Zlib decompress â†’ String reverse
    //   - Returns parsed JSON with all wordpacks in an act
    //   - Single function handles all decoding logic (DRY)
    // ============================================================

    /*
      Our wordpack modules are obfuscated using 3 layers of protection:
      1. Base64 encoding - Allows safe transport as JavaScript string
      2. Zlib compression (via pako) - Reduces file size by ~60%
      3. String reversal - Simple salt to prevent casual JSON parsing

      This function reverses all 3 steps to extract the original JSON data.

      INPUT: URL path to obfuscated module (e.g., './SpanishWords/Jsmodules-js/act1-foundation-js.js')
      OUTPUT: JavaScript object containing all wordpacks in that act

      EXAMPLE OUTPUT STRUCTURE:
      {
        "p1_1_greetings__goodbyes": {
          meta: { wordpack: 1, english: "Greetings & Goodbyes", ... },
          words: [
            ["hola amigo", "hello friend (masculine)", "ä½ å¥½æœ‹å‹", "nÇ hÇŽo pÃ©ngyÇ’u", "olÃ¡ amigo"],
            ["hola amiga", "hello friend (feminine)", "ä½ å¥½æœ‹å‹", "nÇ hÇŽo pÃ©ngyÇ’u", "olÃ¡ amiga"],
            ...
          ]
        },
        "p1_2_another_pack": { ... },
        ...
      }
    */
    async function decodeObfuscatedModule(url) {
      try {
        // STEP 1: Import the obfuscated module
        // The module exports a single variable 'w' containing the base64 string
        const module = await import(url);
        const compressedB64 = module.w;

        // STEP 2: Decode base64 to binary
        // atob() converts base64 string to binary string
        // We then convert to Uint8Array for pako
        const compressedBinary = Uint8Array.from(atob(compressedB64), c => c.charCodeAt(0));

        // STEP 3: Decompress with pako (zlib decompression)
        // This inflates the compressed data back to original size
        const decompressedBinary = pako.inflate(compressedBinary);

        // STEP 4: Convert binary to UTF-8 string
        const reversedJson = new TextDecoder('utf-8').decode(decompressedBinary);

        // STEP 5: Reverse the string (undo the salt)
        // Original was reversed character-by-character
        const jsonStr = reversedJson.split('').reverse().join('');

        // STEP 6: Parse JSON to get the original JavaScript object
        const data = JSON.parse(jsonStr);

        return data;
      } catch (error) {
        console.error('Failed to decode module:', url, error);
        throw error;
      }
    }

    // ============================================================
    // KEY FEATURE: Auto-Select First Act and Pack (DRY ENCAPSULATION)
    // Core Objective: Automatically select first available act/pack
    // Key Behaviors:
    //   - Finds first act numerically
    //   - Selects first pack in that act
    //   - Updates UI dropdowns and displays vocabulary
    //   - Used by: initialize(), setupLanguageRadioButtons()
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      This logic was duplicated in initialize() and setupLanguageRadioButtons().
      Now defined ONCE and called from both places.

      "If I needed to change this behavior, how many places would I need to update?"
      Answer: 1 (this function)
    */
    function autoSelectFirstActAndPack() {
      if (!state.loadedData || Object.keys(state.loadedData).length === 0) {
        return;
      }

      // Find first act numerically
      const firstAct = Math.min(...Object.keys(state.loadedData).map(Number));
      state.currentAct = firstAct;
      document.getElementById('actSelect').value = firstAct;

      // Populate pack dropdown for first act
      populatePackDropdown();

      // Auto-select first pack
      const firstActData = state.loadedData[firstAct];
      if (firstActData) {
        const firstPackKey = Object.keys(firstActData)[0];
        state.currentPack = firstPackKey;
        document.getElementById('packSelect').value = firstPackKey;

        // Display vocabulary
        displayVocabulary();
      }
    }

    // ============================================================
    // INITIALIZATION: Load Data on Page Load
    // ============================================================

    /*
      This function runs automatically when the page loads.
      It loads the default language (Spanish) data and populates UI.

      WORKFLOW:
      1. Load all acts for the default language
      2. Populate act dropdown
      3. Populate native language dropdown
      4. Auto-select first act (via encapsulated function)
      5. Display vocabulary
    */
    async function initialize() {
      updateDebugInfo('Initializing... Loading Spanish data (default)');

      // Load data for default language (Spanish)
      await loadLanguageData('Spanish');

      // Setup UI
      setupLanguageRadioButtons();
      setupModeCheckboxes();  // ENCAPSULATED: Single function for all mode checkboxes
      populateActDropdown();
      populateNativeLanguageDropdown();

      // Auto-select first act and pack (ENCAPSULATED - DRY)
      autoSelectFirstActAndPack();

      updateDebugInfo('Initialization complete. Ready to use.');
    }

    // ============================================================
    // LOAD LANGUAGE DATA: Fetches and Decodes All Acts
    // ============================================================

    /*
      Loads all act modules for the specified language.

      INPUT: languageName (string) - 'Spanish', 'Chinese', or 'English'
      OUTPUT: Populates state.loadedData with decoded wordpacks

      PROCESS:
      1. Get module list from LANGUAGE_CONFIG
      2. Loop through each act module
      3. Decode the obfuscated module
      4. Store in state.loadedData[actNumber]
    */
    async function loadLanguageData(languageName) {
      updateDebugInfo(`Loading ${languageName} data...`);

      const config = LANGUAGE_CONFIG[languageName];
      state.loadedData = {};  // Clear previous data

      // Load each act module
      for (const moduleInfo of config.modules) {
        updateDebugInfo(`Loading Act ${moduleInfo.act}: ${moduleInfo.name}...`);

        try {
          const actData = await decodeObfuscatedModule(moduleInfo.path);
          state.loadedData[moduleInfo.act] = actData;
          updateDebugInfo(`âœ“ Act ${moduleInfo.act} loaded (${Object.keys(actData).length} packs)`);
        } catch (error) {
          updateDebugInfo(`âœ— Failed to load Act ${moduleInfo.act}: ${error.message}`);
        }
      }

      updateDebugInfo(`${languageName} data loading complete.`);
    }

    // ============================================================
    // KEY FEATURE: Language Selection (Radio Buttons)
    // Core Objective: Switch between target languages (Spanish/Chinese/English)
    // Key Behaviors:
    //   - Reloads all act data for selected language
    //   - Resets native language to first available option
    //   - Auto-selects first act/pack via encapsulated function (DRY)
    // ============================================================

    /*
      Attaches change event listeners to language radio buttons.
      When user changes language, reload all data for that language.
    */
    function setupLanguageRadioButtons() {
      const radios = document.querySelectorAll('input[name="language"]');
      radios.forEach(radio => {
        radio.addEventListener('change', async (e) => {
          const newLanguage = e.target.value;
          state.currentLanguage = newLanguage;
          state.currentAct = null;
          state.currentPack = null;

          // Reset native language to first available option
          const nativeLanguages = LANGUAGE_CONFIG[newLanguage].nativeLanguages;
          state.currentNativeLanguage = Object.values(nativeLanguages)[0];

          // Reload data for new language
          await loadLanguageData(newLanguage);

          // Update UI
          populateActDropdown();
          populateNativeLanguageDropdown();

          // Auto-select first act and pack (ENCAPSULATED - DRY)
          // Previously this was 15+ lines of duplicated code
          autoSelectFirstActAndPack();
        });
      });
    }

    // ============================================================
    // KEY FEATURE: Mode Checkboxes (DRY ENCAPSULATION)
    // Core Objective: Toggle display modes (multiple choice, typing, pronunciation)
    // Key Behaviors:
    //   - Each checkbox toggles a state flag
    //   - Some modes require state reset (typing, pronunciation)
    //   - All modes refresh vocabulary display on change
    //   - Single configuration-driven function (DRY)
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      Previously we had THREE separate functions:
      - setupMultipleChoiceCheckbox()
      - setupTypingModeCheckbox()
      - setupPronunciationModeCheckbox()

      All followed the same pattern:
      1. Get checkbox by ID
      2. Add change listener
      3. Update state property
      4. (Optionally) Clear some states
      5. Refresh display

      Now we define this ONCE with a configuration array.
      "If I needed to change the checkbox behavior, how many places would I need to update?"
      Answer: 1 (this function)
    */
    function setupModeCheckboxes() {
      // Configuration array: [checkboxId, stateKey, statesToClear]
      const checkboxConfig = [
        { id: 'multipleChoiceMode', stateKey: 'multipleChoiceMode', statesToClear: [] },
        { id: 'typingMode', stateKey: 'typingMode', statesToClear: ['typingStates'] },
        { id: 'pronunciationMode', stateKey: 'pronunciationMode', statesToClear: ['pronunciationStates'] }
      ];

      checkboxConfig.forEach(({ id, stateKey, statesToClear }) => {
        const checkbox = document.getElementById(id);
        if (!checkbox) return;

        checkbox.addEventListener('change', (e) => {
          // Update the state flag
          state[stateKey] = e.target.checked;

          // Clear associated states if specified
          statesToClear.forEach(stateMapKey => {
            if (state[stateMapKey] && typeof state[stateMapKey].clear === 'function') {
              state[stateMapKey].clear();
            }
          });

          // Refresh table with new mode
          displayVocabulary();
        });
      });
    }

    // ============================================================
    // KEY FEATURE: Speech Recognition (Pronunciation Practice)
    // Core Objective: Allow users to practice pronunciation with feedback
    // Key Behaviors:
    //   - Uses Web Speech API for speech-to-text
    //   - Calculates similarity using Levenshtein distance
    //   - Visual feedback (ðŸ”´ recording, ðŸŽ¤ idle)
    //   - Reset state encapsulated for DRY
    // ============================================================

    /*
      ENCAPSULATED FUNCTION (DRY PRINCIPLE)
      Reset listening state appears in 3 places: onresult, onerror, onend
      Now defined ONCE and called from all places.
    */
    function resetListeningState(recordButton) {
      isListening = false;
      currentListeningWordIndex = null;
      if (recordButton) {
        recordButton.textContent = 'ðŸŽ¤';
      }
    }

    /*
      Starts speech recognition for a specific word in the vocabulary table.

      PROCESS:
      1. Check if speech recognition is available
      2. Set recognition language based on target language
      3. Start listening
      4. On result: Calculate similarity, update state, refresh display
      5. On error: Handle gracefully (no-speech, permission denied)

      PARAMETERS:
      - wordIndex: Index of word in the pack (for state tracking)
      - correctWord: The expected word (target language)
      - recordButton: The button element to update visual state

      VISUAL FEEDBACK:
      - Button shows "ðŸ”´" while recording
      - Button shows "ðŸŽ¤" when idle (via resetListeningState - DRY)
    */
    function startListeningForPronunciation(wordIndex, correctWord, recordButton) {
      if (!recognition) {
        alert('Speech recognition is not supported in your browser. Try Chrome or Edge.');
        return;
      }

      if (isListening) return;

      isListening = true;
      currentListeningWordIndex = wordIndex;
      recognition.lang = SPEECH_LANG_CODES[state.currentLanguage] || 'en-US';
      recordButton.textContent = 'ðŸ”´';

      recognition.onresult = (event) => {
        const results = event.results[0];
        let bestMatch = results[0].transcript;
        let bestScore = 0;

        for (let i = 0; i < results.length; i++) {
          const transcript = results[i].transcript;
          const score = calculateSimilarity(correctWord, transcript);
          if (score > bestScore) {
            bestScore = score;
            bestMatch = transcript;
          }
        }

        state.pronunciationStates.set(wordIndex, {
          score: bestScore,
          heard: bestMatch,
          attempted: true
        });

        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);
        updatePronunciationDisplay(wordIndex, recordButton);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);

        if (event.error === 'no-speech') {
          state.pronunciationStates.set(wordIndex, {
            score: 0,
            heard: '(no speech detected)',
            attempted: true
          });
          updatePronunciationDisplay(wordIndex, recordButton);
        } else if (event.error === 'not-allowed') {
          alert('Microphone access denied. Please allow microphone access to use this feature.');
        }
      };

      recognition.onend = () => {
        // ENCAPSULATED - DRY: Reset state via helper function
        resetListeningState(recordButton);
      };

      recognition.start();
    }

    // ============================================================
    // UPDATE PRONUNCIATION DISPLAY: Show Score in Table Cell
    // ============================================================

    /*
      Updates the score column for a word after pronunciation attempt.

      PARAMETERS:
      - wordIndex: Index of word in pack
      - recordButton: The button element (to find the row)
    */
    function updatePronunciationDisplay(wordIndex, recordButton) {
      const pronState = state.pronunciationStates.get(wordIndex);
      if (!pronState) return;

      const row = recordButton.closest('tr');
      if (!row) return;

      // Score cell is the last cell in the row when pronunciation mode is on
      const scoreCell = row.cells[row.cells.length - 1];
      if (scoreCell) {
        scoreCell.textContent = `${pronState.score}%`;
        scoreCell.title = `Heard: "${pronState.heard}"`;
      }
    }

    // ============================================================
    // AUDIO CONTEXT: For Typing Sound Generation
    // ============================================================

    /*
      Creates and returns the Web Audio API context for sound generation.
      This is used for the satisfying typing/scribble sound.
    */
    let audioContext = null;

    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // ============================================================
    // TYPING SOUND: Mechanical Click (Improved from SimpleFlashCards)
    // ============================================================

    /*
      Plays a satisfying mechanical keyboard click sound on every keypress.
      This sound plays for BOTH correct and wrong keypress (instant feedback).

      SOUND CHARACTERISTICS:
      - Very short duration (0.015-0.025 seconds) for crisp click
      - High frequency (2000-3500 Hz) for mechanical feel
      - Random variation in frequency and volume for natural typing feel
      - Sharp decay envelope for crisp, defined click

      USAGE IN GAMES:
      This sound provides immediate tactile feedback that makes typing feel
      satisfying and responsive. It's crucial for engagement - even wrong
      keypresses should "feel good" to maintain flow state.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Slightly cleaner filter chain
      - Better commented for understanding
    */
    function playTypingSound() {
      const ctx = getAudioContext();

      // Very short duration for crisp mechanical click
      const duration = 0.015 + Math.random() * 0.01;  // 0.015-0.025 seconds
      const bufferSize = ctx.sampleRate * duration;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      // Generate sharp click noise with very fast decay
      for (let i = 0; i < bufferSize; i++) {
        const envelope = Math.pow(1 - i/bufferSize, 8);  // Very sharp decay
        const noise = (Math.random() * 2 - 1);
        data[i] = noise * envelope;
      }

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // High frequency bandpass for mechanical click (2000-3500 Hz)
      const bp1 = ctx.createBiquadFilter();
      bp1.type = 'bandpass';
      bp1.frequency.value = 2000 + Math.random() * 1500;  // Random variation
      bp1.Q.value = 4.0;  // High Q for sharp, defined click

      // Mid frequency for body (1000-1500 Hz)
      const bp2 = ctx.createBiquadFilter();
      bp2.type = 'bandpass';
      bp2.frequency.value = 1000 + Math.random() * 500;
      bp2.Q.value = 2.5;

      // Remove low mud
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 400;

      // Moderate volume for satisfying click
      const gain = ctx.createGain();
      gain.gain.value = 0.35 + Math.random() * 0.1;  // 0.35-0.45 with random variation

      // Connect audio chain
      source.connect(hp);
      hp.connect(bp1);
      bp1.connect(bp2);
      bp2.connect(gain);
      gain.connect(ctx.destination);

      source.start();
    }

    // ============================================================
    // LEVENSHTEIN DISTANCE: For Pronunciation Similarity
    // ============================================================

    /*
      Calculates the Levenshtein (edit) distance between two strings.
      This is the minimum number of single-character edits (insertions,
      deletions, or substitutions) required to change one string into another.

      ALGORITHM: Dynamic Programming approach
      - Time complexity: O(m * n) where m and n are string lengths
      - Space complexity: O(m * n) for the DP table

      EXAMPLE:
      - "hola" vs "hola" = 0 (identical)
      - "hola" vs "hole" = 1 (one substitution)
      - "hola" vs "hol" = 1 (one deletion)
      - "hola" vs "holaa" = 1 (one insertion)

      INPUT: Two strings to compare
      OUTPUT: Integer distance (0 = identical, higher = more different)
    */
    function levenshteinDistance(str1, str2) {
      const m = str1.length;
      const n = str2.length;

      // Create DP table
      const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

      // Initialize base cases
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;

      // Fill DP table
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (str1[i - 1] === str2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1];  // No edit needed
          } else {
            dp[i][j] = 1 + Math.min(
              dp[i - 1][j],     // Deletion
              dp[i][j - 1],     // Insertion
              dp[i - 1][j - 1]  // Substitution
            );
          }
        }
      }

      return dp[m][n];
    }

    // ============================================================
    // SIMILARITY PERCENTAGE: Convert Distance to Percentage
    // ============================================================

    /*
      Converts Levenshtein distance to a percentage similarity score.

      FORMULA: ((maxLen - distance) / maxLen) * 100
      - Perfect match = 100%
      - Completely different = 0%

      NORMALIZATION:
      - Both strings are lowercased for comparison
      - Trimmed of whitespace

      EXAMPLES:
      - "hola" vs "hola" = 100%
      - "hola" vs "hole" = 75% (3 of 4 chars match concept)
      - "hello" vs "hola" = 40% (2 edits on length 5)

      INPUT: expected (correct answer), heard (speech recognition result)
      OUTPUT: Integer percentage 0-100
    */
    function calculateSimilarity(expected, heard) {
      const exp = expected.toLowerCase().trim();
      const hrd = heard.toLowerCase().trim();

      if (exp === hrd) return 100;
      if (hrd.length === 0) return 0;

      const distance = levenshteinDistance(exp, hrd);
      const maxLen = Math.max(exp.length, hrd.length);
      const similarity = Math.max(0, ((maxLen - distance) / maxLen) * 100);

      return Math.round(similarity);
    }

    // ============================================================
    // CHARACTER NORMALIZATION: For Typing Comparison
    // ============================================================

    /*
      Normalizes a character for typing comparison.

      NORMALIZATION RULES:
      1. Convert to lowercase
      2. Remove accents/diacritics (Ã¡ â†’ a, Ã± â†’ n, Ã¼ â†’ u, etc.)

      EXAMPLES:
      - 'Ã' â†’ 'a'
      - 'Ã±' â†’ 'n'
      - 'Ãœ' â†’ 'u'
      - 'Ã‰' â†’ 'e'

      WHY THIS MATTERS FOR GAMES:
      Most English keyboards don't have accent keys, so learners type
      'hola' instead of 'hÃ³la'. We want to accept their answer as correct.

      IMPROVEMENT OVER SimpleFlashCards.html:
      - Same logic, but more clearly documented
      - Explains the "why" for future game developers

      INPUT: Single character string
      OUTPUT: Normalized single character (lowercase, no accents)
    */
    function normalizeCharForTyping(char) {
      return char
        .normalize('NFD')                    // Decompose accents (Ã¡ â†’ a + Â´)
        .replace(/[\u0300-\u036f]/g, '')    // Remove accent marks
        .toLowerCase();                      // Convert to lowercase
    }

    // ============================================================
    // POPULATE ACT DROPDOWN: Based on Loaded Data
    // ============================================================

    /*
      Populates the act dropdown with available acts for current language.

      PROCESS:
      1. Get acts from state.loadedData
      2. Get act names from LANGUAGE_CONFIG
      3. Create option elements
      4. Add change event listener
    */
    function populateActDropdown() {
      const actSelect = document.getElementById('actSelect');
      actSelect.innerHTML = '';

      const acts = Object.keys(state.loadedData).map(Number).sort((a, b) => a - b);
      const config = LANGUAGE_CONFIG[state.currentLanguage];

      acts.forEach(actNum => {
        const moduleInfo = config.modules.find(m => m.act === actNum);
        const option = document.createElement('option');
        option.value = actNum;
        option.textContent = `Act ${actNum}: ${moduleInfo.name}`;
        actSelect.appendChild(option);
      });

      // Event listener for act change
      actSelect.addEventListener('change', (e) => {
        state.currentAct = parseInt(e.target.value);
        state.currentPack = null;
        populatePackDropdown();
        displayVocabulary();
      });
    }

    // ============================================================
    // POPULATE PACK DROPDOWN: Based on Selected Act
    // ============================================================

    /*
      Populates the pack dropdown with wordpacks from selected act.

      PROCESS:
      1. Get pack keys from state.loadedData[currentAct]
      2. Extract pack metadata (title in English)
      3. Create option elements
      4. Add change event listener
    */
    function populatePackDropdown() {
      const packSelect = document.getElementById('packSelect');

      if (!state.currentAct) {
        packSelect.innerHTML = '';
        return;
      }

      packSelect.innerHTML = '';

      const actData = state.loadedData[state.currentAct];
      if (!actData) return;

      // Get all pack keys and sort by wordpack number
      const packKeys = Object.keys(actData);
      packKeys.sort((a, b) => {
        const numA = actData[a].meta.wordpack;
        const numB = actData[b].meta.wordpack;
        return numA - numB;
      });

      packKeys.forEach(packKey => {
        const pack = actData[packKey];
        const option = document.createElement('option');
        option.value = packKey;
        option.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;
        packSelect.appendChild(option);
      });

      // Event listener for pack change
      packSelect.addEventListener('change', (e) => {
        state.currentPack = e.target.value;
        displayVocabulary();
      });
    }

    // ============================================================
    // POPULATE NATIVE LANGUAGE DROPDOWN: Based on Current Language
    // ============================================================

    /*
      Populates the "I speak" dropdown with available native languages.
      Available options depend on the column structure of target language.

      EXAMPLE:
      If learning Spanish, can choose: English, Chinese, Pinyin, Portuguese
      If learning Chinese, can choose: English, Spanish, French, Portuguese, etc.
    */
    function populateNativeLanguageDropdown() {
      const nativeSelect = document.getElementById('nativeLanguageSelect');
      nativeSelect.innerHTML = '';

      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const nativeLanguages = config.nativeLanguages;

      Object.entries(nativeLanguages).forEach(([langName, columnIndex]) => {
        const option = document.createElement('option');
        option.value = columnIndex;
        option.textContent = langName;
        if (columnIndex === state.currentNativeLanguage) {
          option.selected = true;
        }
        nativeSelect.appendChild(option);
      });

      // Event listener for native language change
      nativeSelect.addEventListener('change', (e) => {
        state.currentNativeLanguage = parseInt(e.target.value);
        displayVocabulary();
      });
    }

    // ============================================================
    // STRING NORMALIZATION: For Duplicate Detection
    // ============================================================

    /*
      Normalizes strings for comparison to detect duplicates across wordpacks.

      NORMALIZATION PROCESS:
      1. Convert to lowercase
      2. Remove all spaces
      3. Remove all symbols/punctuation

      EXAMPLES:
      - "Hola Amigo" â†’ "holaamigo"
      - "hello, friend!" â†’ "hellofriend"
      - "ä½ å¥½ æœ‹å‹" â†’ "ä½ å¥½æœ‹å‹"

      This catches duplicates that may appear with slight variations:
      - "hola" and "Hola" (case difference)
      - "hello friend" and "hellofriend" (spacing difference)
      - "hello!" and "hello" (punctuation difference)

      INPUT: String to normalize
      OUTPUT: Normalized string (lowercase, no spaces, no symbols)
    */
    function normalizeString(str) {
      return str
        .toLowerCase()
        .replace(/[\s\.,!?;:'"()\[\]{}\-_]/g, '');  // Remove spaces and common symbols
    }

    // ============================================================
    // KEY FEATURE: Multiple Choice Wrong Answers (Act-Wide Pool)
    // Core Objective: Generate diverse, non-duplicate wrong answers
    // Key Behaviors:
    //   - Pulls from ENTIRE ACT (~2,500 words) not just current pack
    //   - Filters duplicates via normalized string comparison
    //   - Uses Fisher-Yates shuffle for uniform randomness
    //   - Works for ANY language (Spanish, Chinese, English)
    // ============================================================

    /*
      Generates random wrong answers for multiple choice mode.

      UPDATED ALGORITHM (Act-Wide Selection):
      Instead of pulling from just the current wordpack (50 words),
      we now pull from the ENTIRE ACT (all wordpacks, ~2,500 words).

      BENEFITS:
      âœ“ More variety (2,500 options vs 50)
      âœ“ Less predictable for players
      âœ“ Better for advanced learners
      âœ“ No additional performance cost (data already in memory)

      PROCESS:
      1. Collect all words from all packs in the current act
      2. Filter out the correct answer (exact match)
      3. Filter out normalized duplicates (case/space/symbol variations)
      4. Shuffle remaining pool using Fisher-Yates
      5. Take first K words as wrong answers (K=4 in this demo)

      EXAMPLE:
      - Act 1 has 50 packs with 50 words each = 2,500 total words
      - Current correct answer: "hola amigo"
      - Normalized: "holaamigo"
      - Filter out: "hola amigo", "Hola Amigo", "hola-amigo" (all normalize to same)
      - Remaining pool: ~2,499 words
      - Randomly select 4 from this pool

      DUPLICATE DETECTION:
      We use normalized string comparison to avoid showing essentially
      the same word with minor variations:
      - "hello" vs "Hello" (different case)
      - "hello friend" vs "hellofriend" (different spacing)
      - "hello!" vs "hello" (different punctuation)

      GAME USAGE:
      Different games need different numbers of wrong answers:
      - Temple Run (3-lane runner): Need 2 wrong answers (3 total choices)
      - Quiz game (4 options): Need 3 wrong answers (4 total choices)
      - This demo: 4 wrong answers to show extensibility

      This algorithm works for ANY language (Spanish, Chinese, English, etc.)
      because it always uses column 0 (target language) from the words array.

      INPUT:
        - actData: Dictionary of all wordpacks in the current act
        - correctAnswer: The correct answer string (to filter out)
        - count: Number of wrong answers to generate (default 4)

      OUTPUT:
        - Array of wrong answer strings from column 0 (target language)
    */
    function generateWrongAnswers(actData, correctAnswer, count = 4) {
      // STEP 1: Normalize the correct answer for comparison
      const normalizedCorrect = normalizeString(correctAnswer);

      // STEP 2: Collect all words from all packs in the act
      const allWords = [];

      // Loop through each pack in the act
      Object.keys(actData).forEach(packKey => {
        const pack = actData[packKey];

        // Loop through each word in this pack
        pack.words.forEach(word => {
          const targetLanguageWord = word[0];  // Column 0 is always target language

          // Filter out the correct answer and normalized duplicates
          if (targetLanguageWord !== correctAnswer) {
            const normalizedWord = normalizeString(targetLanguageWord);

            // Only add if normalized version is different from correct answer
            if (normalizedWord !== normalizedCorrect) {
              allWords.push(targetLanguageWord);
            }
          }
        });
      });

      // STEP 3: Shuffle using Fisher-Yates algorithm for uniform randomness
      for (let i = allWords.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
      }

      // STEP 4: Take first 'count' words (or fewer if pool is small)
      const wrongAnswers = allWords.slice(0, Math.min(count, allWords.length));

      return wrongAnswers;
    }

    // ============================================================
    // KEY FEATURE: Typing Practice (Character-by-Character Input)
    // Core Objective: Let users practice spelling with instant feedback
    // Key Behaviors:
    //   - Accent-insensitive comparison (Ã¡ = a, Ã± = n)
    //   - Auto-skip spaces
    //   - Track wrong letters with visual feedback
    //   - Satisfying click sound on every keypress
    //   - Per-row state (not global) - more modular than SimpleFlashCards
    // ============================================================

    /*
      Handles typing input for a specific word in the vocabulary table.
      This is the CORE TYPING MECHANIC that can be reused in any language game.

      TYPING ALGORITHM (IMPROVED over SimpleFlashCards.html):
      1. Get or initialize typing state for this word
      2. Find next position to type (first untyped non-space character)
      3. Normalize both the typed key and target character (remove accents, lowercase)
      4. Compare:
         - If match: Mark position as typed, play sound
         - If mismatch: Track wrong letter, increment counter, play sound
      5. Update the display (shows Xâ†’letter progressively)

      STATE MANAGEMENT (PER-ROW):
      Each word has its own typing state stored in state.typingStates Map:
      {
        typed: Set(),          // Set of character positions successfully typed
        wrongLetters: [],      // Array of wrong letters attempted
        wrongCount: 0          // Total wrong attempts
      }

      KEY IMPROVEMENTS OVER SimpleFlashCards.html:
      - Per-row state instead of global state (more modular)
      - Simpler state structure (easier to understand)
      - Inline in table (no separate card flipping)
      - Better for debugging/testing multiple words at once

      PARAMETERS:
      - wordIndex: Index of the word in the pack (used as state key)
      - correctWord: The correct answer string (target language)
      - key: The key that was pressed
      - inputElement: The input element to update

      RETURNS: Nothing (updates state and DOM directly)
    */
    function handleTypingInput(wordIndex, correctWord, key, inputElement) {
      // STEP 1: Get or create typing state for this word
      if (!state.typingStates.has(wordIndex)) {
        state.typingStates.set(wordIndex, {
          typed: new Set(),
          wrongLetters: [],
          wrongCount: 0
        });
      }

      const typingState = state.typingStates.get(wordIndex);
      const chars = correctWord.split('');

      // STEP 2: Find next unfilled position (skip already typed and spaces)
      let nextPos = 0;
      for (let i = 0; i < chars.length; i++) {
        if (chars[i] === ' ') {
          typingState.typed.add(i);  // Auto-mark spaces as typed
          continue;
        }
        if (!typingState.typed.has(i)) {
          nextPos = i;
          break;
        }
        if (i === chars.length - 1) {
          // Already completed
          return;
        }
      }

      // STEP 3: Normalize characters for comparison (remove accents, lowercase)
      const normalizedKey = normalizeCharForTyping(key);
      const normalizedTarget = normalizeCharForTyping(chars[nextPos]);

      // STEP 4: Play sound for ANY keypress (instant feedback)
      playTypingSound();

      // STEP 5: Check if correct
      if (normalizedKey === normalizedTarget) {
        // CORRECT! Mark position as typed
        typingState.typed.add(nextPos);
      } else {
        // WRONG! Track the wrong letter and increment counter
        typingState.wrongLetters.push(key.toLowerCase());
        typingState.wrongCount++;
      }

      // STEP 6: Update display to show progress
      updateTypingDisplay(wordIndex, correctWord, inputElement);
    }

    // ============================================================
    // UPDATE TYPING DISPLAY: Show Progress in Input Box
    // ============================================================

    /*
      Updates the typing input box to show current progress.

      DISPLAY FORMAT:
      - Untyped characters: Shown as 'X'
      - Typed characters: Shown as actual letter
      - Spaces: Shown as space (auto-typed)

      EXAMPLE PROGRESSION for "hola amigo":
      Initial:  "XXXX XXXXX"
      After 'h': "hXXX XXXXX"
      After 'o': "hoXX XXXXX"
      After 'l': "holX XXXXX"
      After 'a': "hola XXXXX"
      After 'a': "hola aXXXX"
      ... etc ...
      Final:    "hola amigo"

      PARAMETERS:
      - wordIndex: Index of word (to get state)
      - correctWord: The correct answer
      - inputElement: The input element to update
    */
    function updateTypingDisplay(wordIndex, correctWord, inputElement) {
      const typingState = state.typingStates.get(wordIndex);
      if (!typingState) return;

      const chars = correctWord.split('');
      const display = chars.map((char, i) => {
        if (typingState.typed.has(i)) {
          return char;  // Show actual character if typed
        } else {
          return char === ' ' ? ' ' : 'X';  // Show X for untyped, preserve spaces
        }
      }).join('');

      inputElement.value = display;

      // Also update the wrong letters and count columns
      const row = inputElement.closest('tr');
      if (row) {
        const wrongLettersCell = row.cells[row.cells.length - 2];  // Second to last column
        const wrongCountCell = row.cells[row.cells.length - 1];     // Last column

        if (wrongLettersCell) {
          // Display wrong letters with strikethrough
          wrongLettersCell.innerHTML = typingState.wrongLetters
            .map(letter => `<del>${letter}</del>`)
            .join(' ');
        }

        if (wrongCountCell) {
          wrongCountCell.textContent = typingState.wrongCount;
        }
      }
    }

    // ============================================================
    // KEY FEATURE: Vocabulary Table Display (Multi-Mode)
    // Core Objective: Render vocabulary with optional practice modes
    // Key Behaviors:
    //   - Dynamic column count based on enabled modes
    //   - Supports: basic, multiple choice, typing, pronunciation
    //   - Modes can be combined (columns stack)
    //   - Headers update dynamically to match active modes
    // ============================================================

    /*
      Displays vocabulary for the selected wordpack.

      TABLE MODES:

      BASIC MODE (all modes off):
      - 2 columns: Target language (column 0) and Native language (selected)

      MULTIPLE CHOICE MODE (multipleChoiceMode = true):
      - 6 columns: Target language, Native language, + 4 wrong answers
      - Wrong answers are randomly selected from ALL packs in current act
      - Duplicate filtering applied (normalized string comparison)

      TYPING MODE (typingMode = true):
      - 5 columns: Target language, Native language, Typing input, Wrong letters, Wrong count
      - Interactive typing practice with instant feedback

      PRONUNCIATION MODE (pronunciationMode = true):
      - 4 columns: Target language, Native language, Record button, Score percentage
      - Speech recognition using Web Speech API
      - Levenshtein distance for fuzzy string matching

      MODES CAN BE COMBINED:
      - Multiple modes can be enabled simultaneously
      - Columns are added in order: base â†’ multiple choice â†’ typing â†’ pronunciation

      PROCESS:
      1. Get selected wordpack from state.loadedData
      2. Check which modes are enabled
      3. Update table headers accordingly
      4. Loop through words array
      5. For each word:
         - Display word[0] in column 1 (target language - correct answer)
         - Display word[nativeLanguageIndex] in column 2 (translation)
         - If multiple choice mode: Generate and display 4 wrong answers
         - If typing mode: Add typing input box and tracking columns
         - If pronunciation mode: Add record button and score columns
    */
    function displayVocabulary() {
      const tableBody = document.getElementById('vocabularyTable');
      const packTitleEl = document.getElementById('packTitle');
      const tableHeaderRow = document.getElementById('tableHeaderRow');

      // Clear table
      tableBody.innerHTML = '';

      // Calculate colspan based on active modes
      let totalColumns = 2;  // Base: target language + native language
      if (state.multipleChoiceMode) totalColumns += 4;  // Add 4 wrong answer columns
      if (state.typingMode) totalColumns += 3;  // Add typing input + wrong letters + wrong count
      if (state.pronunciationMode) totalColumns += 2;  // Add record button + percentage score

      // Validate selection
      if (!state.currentAct || !state.currentPack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Please select an act and wordpack</td></tr>`;
        packTitleEl.textContent = 'No pack selected';
        return;
      }

      // Get wordpack data
      const actData = state.loadedData[state.currentAct];
      if (!actData) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Act data not loaded</td></tr>`;
        return;
      }

      const pack = actData[state.currentPack];
      if (!pack) {
        tableBody.innerHTML = `<tr><td colspan="${totalColumns}">Pack not found</td></tr>`;
        return;
      }

      // Update pack title
      packTitleEl.textContent = `Pack ${pack.meta.wordpack}: ${pack.meta.english}`;

      // Get language names
      const config = LANGUAGE_CONFIG[state.currentLanguage];
      const targetLanguage = config.columns[0];  // Column 0 is always target language
      const nativeLanguage = config.columns[state.currentNativeLanguage];

      // ============================================================
      // UPDATE TABLE HEADERS: Based on Mode
      // ============================================================
      /*
        Build headers dynamically based on enabled modes:
        - Base: Target language + Native language (2 columns)
        - Multiple Choice: + 4 wrong answer columns
        - Typing: + Typing input + Wrong letters + Wrong count (3 columns)
      */
      let headers = [];

      // Base columns (always present)
      if (state.multipleChoiceMode) {
        headers.push(`<th>Correct Answer (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.typingMode) {
        headers.push(`<th>Target Word (${targetLanguage})</th>`);
        headers.push(`<th>Translation (${nativeLanguage})</th>`);
      } else if (state.pronunciationMode) {
        headers.push(`<th>Say This (${targetLanguage})</th>`);
        headers.push(`<th>Meaning (${nativeLanguage})</th>`);
      } else {
        headers.push(`<th>I am learning (${targetLanguage})</th>`);
        headers.push(`<th>I speak (${nativeLanguage})</th>`);
      }

      // Multiple choice columns (if enabled)
      if (state.multipleChoiceMode) {
        headers.push('<th>Wrong Answer 1</th>');
        headers.push('<th>Wrong Answer 2</th>');
        headers.push('<th>Wrong Answer 3</th>');
        headers.push('<th>Wrong Answer 4</th>');
      }

      // Typing mode columns (if enabled)
      if (state.typingMode) {
        headers.push('<th>Type Here (X = letter)</th>');
        headers.push('<th>Wrong Letters</th>');
        headers.push('<th>Wrong Count</th>');
      }

      // Pronunciation mode columns (if enabled)
      if (state.pronunciationMode) {
        headers.push('<th>Record ðŸŽ¤</th>');
        headers.push('<th>Score %</th>');
      }

      tableHeaderRow.innerHTML = headers.join('\n');

      // ============================================================
      // POPULATE TABLE ROWS: Generate vocabulary with optional wrong answers
      // ============================================================
      pack.words.forEach((word, index) => {
        const row = document.createElement('tr');

        // COLUMN 1: Target language (correct answer, column 0 from words array)
        const cell1 = document.createElement('td');
        cell1.textContent = word[0];
        row.appendChild(cell1);

        // COLUMN 2: Native language translation (selected column from words array)
        const cell2 = document.createElement('td');
        cell2.textContent = word[state.currentNativeLanguage];
        row.appendChild(cell2);

        // COLUMNS 3-6: Wrong answers (only in multiple choice mode)
        if (state.multipleChoiceMode) {
          /*
            Generate 4 random wrong answers from ALL wordpacks in the current act.
            - Current correct answer: word[0] (target language, column 0)
            - Pool: All words from all packs in the current act (~2,500 words)
            - Filtering: Exclude correct answer and normalized duplicates
            - Each wrong answer is from column 0 (target language)
          */
          const correctAnswer = word[0];
          const wrongAnswers = generateWrongAnswers(actData, correctAnswer, 4);

          // Add each wrong answer as a table cell
          wrongAnswers.forEach(wrongAnswer => {
            const wrongCell = document.createElement('td');
            wrongCell.textContent = wrongAnswer;
            row.appendChild(wrongCell);
          });

          // Handle edge case: If act has fewer than 5 words total,
          // we might have fewer than 4 wrong answers. Fill remaining cells.
          const wrongAnswerCount = wrongAnswers.length;
          for (let i = wrongAnswerCount; i < 4; i++) {
            const emptyCell = document.createElement('td');
            emptyCell.textContent = '(Not enough words in act)';
            row.appendChild(emptyCell);
          }
        }

        // TYPING MODE COLUMNS: Input box + Wrong letters + Wrong count
        if (state.typingMode) {
          /*
            Add typing practice columns for this word:
            1. Typing input box (initialized with "XXXX XXXXX" format)
            2. Wrong letters column (displays struck-through wrong attempts)
            3. Wrong count column (displays total wrong attempts)
          */
          const correctWord = word[0];

          // COLUMN: Typing input box
          const typingCell = document.createElement('td');
          const typingInput = document.createElement('input');
          typingInput.type = 'text';
          typingInput.readOnly = true;  // Prevent direct editing
          typingInput.style.width = '100%';
          typingInput.style.fontFamily = 'monospace';
          typingInput.style.fontSize = '1em';
          typingInput.style.padding = '4px';

          // Initialize display with X's for each letter (preserve spaces)
          const initialDisplay = correctWord.split('').map(char => char === ' ' ? ' ' : 'X').join('');
          typingInput.value = initialDisplay;

          // Add keypress listener to this specific input
          typingInput.addEventListener('keydown', (e) => {
            // Only handle single character keys (not arrow keys, backspace, etc.)
            if (e.key.length === 1) {
              e.preventDefault();  // Prevent default input behavior
              handleTypingInput(index, correctWord, e.key, typingInput);
            }
          });

          // Make input focusable by clicking
          typingInput.addEventListener('click', () => {
            typingInput.focus();
          });

          typingCell.appendChild(typingInput);
          row.appendChild(typingCell);

          // COLUMN: Wrong letters (initially empty)
          const wrongLettersCell = document.createElement('td');
          wrongLettersCell.style.fontFamily = 'monospace';
          row.appendChild(wrongLettersCell);

          // COLUMN: Wrong count (initially 0)
          const wrongCountCell = document.createElement('td');
          wrongCountCell.textContent = '0';
          wrongCountCell.style.textAlign = 'center';
          row.appendChild(wrongCountCell);
        }

        // PRONUNCIATION MODE COLUMNS: Record button + Score percentage
        if (state.pronunciationMode) {
          const correctWord = word[0];

          // COLUMN: Record button
          const recordCell = document.createElement('td');
          const recordButton = document.createElement('button');
          recordButton.textContent = 'ðŸŽ¤';
          recordButton.addEventListener('click', () => {
            startListeningForPronunciation(index, correctWord, recordButton);
          });
          recordCell.appendChild(recordButton);
          row.appendChild(recordCell);

          // COLUMN: Score percentage
          const scoreCell = document.createElement('td');
          const pronState = state.pronunciationStates.get(index);
          if (pronState && pronState.attempted) {
            scoreCell.textContent = `${pronState.score}%`;
            scoreCell.title = `Heard: "${pronState.heard}"`;
          } else {
            scoreCell.textContent = '-';
          }
          row.appendChild(scoreCell);
        }

        tableBody.appendChild(row);
      });

      // Update debug info with active modes
      let modeParts = [];
      if (state.multipleChoiceMode) modeParts.push('Multiple Choice (act-wide pool)');
      if (state.typingMode) modeParts.push('Typing Practice');
      if (state.pronunciationMode) modeParts.push('Pronunciation Practice');
      const modeText = modeParts.length > 0 ? modeParts.join(' + ') : 'Basic (2 columns)';

      // Count total words in act for debug info
      let totalActWords = 0;
      Object.keys(actData).forEach(packKey => {
        totalActWords += actData[packKey].words.length;
      });

      updateDebugInfo(`Displaying Pack ${pack.meta.wordpack}: ${pack.meta.english}\n` +
                      `Words in this pack: ${pack.words.length}\n` +
                      `Total words in Act ${state.currentAct}: ${totalActWords}\n` +
                      `Mode: ${modeText}\n` +
                      `Total columns: ${totalColumns}\n` +
                      `Target language: ${targetLanguage} (column 0)\n` +
                      `Native language: ${nativeLanguage} (column ${state.currentNativeLanguage})`);
    }

    // ============================================================
    // UPDATE DEBUG INFO: Display Technical Details
    // ============================================================

    /*
      Updates the debug information section with current state and messages.
      Useful for developers/LLMs to understand what's happening.
    */
    function updateDebugInfo(message) {
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toLocaleTimeString();
      debugInfo.textContent = `[${timestamp}] ${message}\n\n` +
        `Current State:\n` +
        `- Language: ${state.currentLanguage}\n` +
        `- Act: ${state.currentAct || 'None'}\n` +
        `- Pack: ${state.currentPack || 'None'}\n` +
        `- Native Language Column: ${state.currentNativeLanguage}\n` +
        `- Multiple Choice Mode: ${state.multipleChoiceMode ? 'Enabled' : 'Disabled'}\n` +
        `- Typing Mode: ${state.typingMode ? 'Enabled' : 'Disabled'}\n` +
        `- Pronunciation Mode: ${state.pronunciationMode ? 'Enabled' : 'Disabled'}\n` +
        `- Active Typing States: ${state.typingStates.size}\n` +
        `- Active Pronunciation States: ${state.pronunciationStates.size}\n` +
        `- Speech Recognition: ${recognition ? 'Available' : 'Not Available'}\n` +
        `- Loaded Acts: ${Object.keys(state.loadedData).join(', ') || 'None'}`;
    }

    // ============================================================
    // AUTO-RUN ON PAGE LOAD
    // ============================================================

    /*
      Automatically initialize when DOM is ready.
      This removes the need for a "Run Test" button.
    */
    window.addEventListener('DOMContentLoaded', initialize);

  </script>

</body>
</html>
